 /*
 * Implementation of a secure HTTP server
 *
 * Copyright Mocana Corp 2003-2019. All Rights Reserved.
 * Proprietary and Confidential Material.
 *
 */

#if defined(__ENABLE_DIGICERT_WIN_STUDIO_BUILD__)
#include <windows.h>
#endif

#include "../common/moptions.h"

#if !defined(__ENABLE_DIGICERT_SSL_CLIENT_EXAMPLE__)
#if (defined( __ENABLE_DIGICERT_SSL_SERVER__ ) && !defined( __ENABLE_DIGICERT_SSL_ASYNC_SERVER_API__ )) || \
    defined(__DISABLE_DIGICERT_AUTO_EXAMPLES__)
#if defined(__ENABLE_DIGICERT_EXAMPLES__) || defined(__ENABLE_DIGICERT_BIN_EXAMPLES__)
#ifdef __ENABLE_DIGICERT_SSL_SERVER__

#include "../common/mtypes.h"
#include "../common/mdefs.h"
#include "../common/merrors.h"
#include "../common/mrtos.h"
#include "../common/mtcp.h"
#include "../common/mocana.h"
#include "../common/debug_console.h"
#include "../common/mstdlib.h"
#include "../common/vlong.h"
#include "../common/hash_value.h"
#include "../common/hash_table.h"
#include "../crypto/hw_accel.h"
#include "../common/random.h"
#include "../crypto/pubcrypto.h"
#include "../crypto/pkcs_key.h"
#if defined(__ENABLE_DIGICERT_SSL_SRP__)
#include "../crypto/srp.h"
#endif
#include "../crypto/ca_mgmt.h"

#include "../common/base64.h"
#include "../crypto/rsa.h"
#ifdef __ENABLE_DIGICERT_DSA__
#include "../crypto/dsa.h"
#include "../crypto/dsa2.h"
#endif
#ifdef __ENABLE_DIGICERT_ECC__
#include "../crypto/primefld.h"
#include "../crypto/primeec.h"
#endif
#include "../crypto/keyblob.h"

#include "../common/tree.h"
#include "../common/absstream.h"
#include "../common/memfile.h"
#include "../asn1/parseasn1.h"
#include "../crypto/crypto.h"
#include "../crypto/pkcs7.h"
#include "../crypto/pkcs12.h"
#include "../common/sizedbuffer.h"
#include "../crypto/cert_store.h"
#include "../crypto/crypto_utils.h"
#include "../ssl/ssl.h"

#if (defined(__ENABLE_DIGICERT_MEM_PART__))
#include "../common/mem_part.h"
#endif

#ifdef __ENABLE_DIGICERT_TAP__
#include "../smp/smp_cc.h"
#include "../tap/tap_api.h"
#include "../tap/tap_utils.h"
#include "../tap/tap_smp.h"
#include "../crypto/mocasym.h"
#include "../crypto/mocasymkeys/tap/rsatap.h"
#include "../crypto/mocasymkeys/tap/ecctap.h"
#include "../crypto_interface/cryptointerface.h"
#endif

#ifdef __ENABLE_DIGICERT_DATA_PROTECTION__
#include "../data_protection/file_protect.h"
#endif
/*------------------------------------------------------------------*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "ssl_cert_utils.h"


/*------------------------------------------------------------------*/
/* Hard coded parameter defaults.                                   */
/*------------------------------------------------------------------*/
#if defined(WIN32)
#define DEFAULT_KEYSTORE_DIRECTIORY 	".\\KeyStore"
#else
#define DEFAULT_KEYSTORE_DIRECTIORY 	"./keystore"
#endif

/* #define SSLC_DEF_PORT           	SSL_DEFAULT_TCPIP_PORT */
#define SSLS_DEF_PORT           	(1440)
#define SSLS_DEF_KEYSTORE       	DEFAULT_KEYSTORE_DIRECTIORY
#define SSLS_DEF_SERVERNAME    		"webapptap.securitydemos.net"

#ifndef __DISABLE_DIGICERT_SSL_RSA_SUPPORT__
#define SSLS_DEF_SERVERCERT     	"RSACertCA.der"
#define SSLS_DEF_TRUSTCERT      	"ClientRSACert.der"
#if (defined(__ENABLE_DIGICERT_PEM_DER_PRIVATE_KEY__))
#define SSLS_DEF_SERVERBLOB    		"RSACertCAKey.pem"
#else
#define SSLS_DEF_SERVERBLOB    		"RSACertCAKey.dat"
#endif
#endif

#if (defined(__ENABLE_DIGICERT_ECC__) && defined(__ENABLE_DIGICERT_SSL_ECDH_SUPPORT__))
#undef SSLS_DEF_SERVERCERT
#undef SSLS_DEF_SERVERBLOB
#undef SSLS_DEF_TRUSTCERT
#define SSLS_DEF_SERVERCERT         "ECCCertCA384.der"
#define SSLS_DEF_TRUSTCERT      	"ClientECCCertCA384.der"
#if (defined(__ENABLE_DIGICERT_PEM_DER_PRIVATE_KEY__))
#define SSLS_DEF_SERVERBLOB         "ECCCertCA384Key.pem"
#else
#define SSLS_DEF_SERVERBLOB         "ECCCertCA384Key.dat"
#endif
#endif

#if (defined(__ENABLE_DIGICERT_PKCS12_CERT__))
#undef SSLS_DEF_SERVERCERT
#undef SSLS_DEF_SERVERBLOB
#define SSLS_DEF_SERVERCERT         "RSACertCA.p12"
#if (defined(__ENABLE_DIGICERT_PEM_DER_PRIVATE_KEY__))
#define SSLS_DEF_SERVERBLOB    		"RSACertCAKey.pem"
#else
#define SSLS_DEF_SERVERBLOB    		"RSACertCAKey.dat"
#endif
#endif

#if (defined(__ENABLE_DIGICERT_DSA__))
#undef SSLS_DEF_SERVERCERT
#undef SSLS_DEF_SERVERBLOB
#define SSLS_DEF_SERVERCERT                     "DSACertCA.der"
#define SSLS_DEF_SERVERBLOB                     "DSACertCAKey.dat"
#endif

#if defined(__ENABLE_DIGICERT_WIN_STUDIO_BUILD__)
#define DEF_FILESEP                     '/'
#define DEF_FILEPATH                    "."
#else
#define DEF_FILESEP                     '/'
#define DEF_FILEPATH                    "/tmp"
#endif

#if defined(__ENABLE_DIGICERT_TAP__)
#include "../common/tpm2_path.h"
#define DEF_TAP_KEYSOURCE          "TPM2"
#endif
typedef struct
{
  ubyte     *pCert;
  ubyte4     certLen;
  ubyte     *pKey;
  ubyte4     keyLen;
} P12Content;

#define SAMPLE_PASSWORD_LEN 18
#define SAMPLE_PASSWORD \
    (ubyte)0, (ubyte)'p', (ubyte)0, (ubyte)'a', (ubyte)0, (ubyte)'s', \
    (ubyte)0, (ubyte)'s', (ubyte)0, (ubyte)'w', (ubyte)0, (ubyte)'o', \
    (ubyte)0, (ubyte)'r', (ubyte)0, (ubyte)'d', (ubyte)0, (ubyte)0

/* INIT_HASH is a seed value to throw off attackers */
#define INIT_HASH   (0xab341c12)

sbyte* filePath  = (sbyte *) DEF_FILEPATH;

#if defined(__ENABLE_DIGICERT_PKCS12_CERT__)
MSTATUS SampleContentHandler (
  const void *context,
  contentTypes type,
  ubyte4 extraInfo,
  const ubyte *content,
  ubyte4 contentLen
  );
#endif

#ifdef __ENABLE_DIGICERT_MEM_PART__
extern memPartDescr *gMemPartDescr;
#endif

/*------------------------------------------------------------------*/
/* Parameters filled in from args (or elsewhere)                    */
/*------------------------------------------------------------------*/
static unsigned short  ssls_ServerPort     = SSL_DEFAULT_TCPIP_PORT;
static char * 	       ssls_ServerName     = NULL;
static char * 	       ssls_KeyStore       = NULL;
static char * 	       ssls_ServerCert     = NULL;
static char * 	       ssls_ServerChainIntCert = NULL;
static char * 	       ssls_ServerChainCaCert = NULL;
static char * 	       ssls_ServerBlob     = NULL;
static char * 	       ssls_CACert         = NULL;
static intBoolean      ssls_getArgs_called = 0;
#if (defined(__ENABLE_DIGICERT_TAP__))
#if (defined(__ENABLE_DIGICERT_TAP_REMOTE__))
static unsigned short  taps_ServerPort     = 0;
static char * 	       taps_ServerName     = NULL;
#endif
static char *          tap_ConfigFile      = NULL;
static sbyte *         tap_keySource       = NULL;
static ubyte2          ssls_TapProvider = 0;
#endif
#if (defined(__ENABLE_DIGICERT_TLS13__) && defined(__ENABLE_DIGICERT_TLS13_PSK__))
static intBoolean      ssls_useExternalPsk = 0;
#if defined(__ENABLE_DIGICERT_TLS13_0RTT__)
static sbyte4  ssls_maxEarlyDataSize  = 0;
static sbyte4  ssls_recvEarlyDataSize = 0;
#endif
ubyte*         g_pPSK                = NULL;
ubyte4         g_pPSKLen             = 0;
sbyte*         g_pServerInfo         = NULL;
ubyte4         g_serverInfoLength    = 0;
ubyte*         g_pPSKIdentity        = NULL;
ubyte4         g_pPSKIdentityLength  = 0;
#endif

/*------------------------------------------------------------------*/
/* Forward Declarations                                             */
/*------------------------------------------------------------------*/
static void setStringParameter(char** param, char* value);
static void setFilePath(sbyte *path, sbyte **fname);

#define myPrintNL(a) { \
	DEBUG_PRINTNL(DEBUG_SSL_EXAMPLE, (sbyte*)a); }
#define myPrintInt(a,b) { \
	DEBUG_PRINTSTR1INT1(DEBUG_SSL_EXAMPLE, (sbyte*)a, b); }
#define myPrintIntNL(a,b) { \
	DEBUG_PRINTSTR1INT1(DEBUG_SSL_EXAMPLE, \
	(sbyte*)a, b); DEBUG_PRINTNL(DEBUG_SSL_EXAMPLE, (sbyte*)""); }
#define myPrintStringNL(a,b) { \
	DEBUG_PRINT2(DEBUG_SSL_EXAMPLE, (sbyte*)a, \
	(sbyte*)b); DEBUG_PRINTNL(DEBUG_SSL_EXAMPLE, (sbyte*)""); }
#define myPrintError(a,b) { \
	DEBUG_PRINT(DEBUG_SSL_EXAMPLE, (sbyte*)"----------------> ERROR::"); \
	DEBUG_ERROR(DEBUG_SSL_EXAMPLE, a, b); }
#define myPrintStringError(a,b) { \
	DEBUG_PRINT(DEBUG_DTLS_EXAMPLE, (sbyte*)"----------------> ERROR::"); \
	DEBUG_PRINT2(DEBUG_DTLS_EXAMPLE, a, b); \
	DEBUG_PRINTNL(DEBUG_DTLS_EXAMPLE, (sbyte*)""); }

#define myPrintStatus(fmt, ...) \
    do {\
        printf(fmt"\n", ##__VA_ARGS__);\
    } while (0);

/*------------------------------------------------------------------*/

static RootCertInfo gRootCerts[] =
{
		{kRSACertIdx, SSLS_DEF_TRUSTCERT, 0, 0 }
};

static certStorePtr pSslCertStore;

#ifdef __ENABLE_DIGICERT_TAP__
static TAP_EntityCredentialList *g_pTapEntityCred = NULL;
static TAP_CredentialList       *g_pTapKeyCred    = NULL;
static TAP_ModuleList g_moduleList                = { 0 };
#endif

#define LINE_SIZE                       (1000)
#if defined(__ENABLE_DIGICERT_SSL_EXAMPLE_INTEROP_TEST__)
#define MAX_SSL_CONNECTIONS_ALLOWED     (500)
#else
#define MAX_SSL_CONNECTIONS_ALLOWED     (100)
#endif

static TCP_SOCKET mListenSocket;

static ubyte gFavoriteImage[] = {
0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01,
0x02, 0x01, 0x00, 0x48, 0x00, 0x48, 0x00, 0x00, 0xff, 0xed, 0x0c, 0xba,
0x50, 0x68, 0x6f, 0x74, 0x6f, 0x73, 0x68, 0x6f, 0x70, 0x20, 0x33, 0x2e,
0x30, 0x00, 0x38, 0x42, 0x49, 0x4d, 0x03, 0xed, 0x0a, 0x52, 0x65, 0x73,
0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x10,
0x00, 0x48, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x48, 0x00, 0x00,
0x00, 0x02, 0x00, 0x02, 0x38, 0x42, 0x49, 0x4d, 0x04, 0x0d, 0x18, 0x46,
0x58, 0x20, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x20, 0x4c, 0x69, 0x67,
0x68, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x41, 0x6e, 0x67, 0x6c, 0x65, 0x00,
0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x78, 0x38, 0x42, 0x49, 0x4d,
0x04, 0x19, 0x12, 0x46, 0x58, 0x20, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c,
0x20, 0x41, 0x6c, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x00, 0x00, 0x00,
0x00, 0x04, 0x00, 0x00, 0x00, 0x1e, 0x38, 0x42, 0x49, 0x4d, 0x03, 0xf3,
0x0b, 0x50, 0x72, 0x69, 0x6e, 0x74, 0x20, 0x46, 0x6c, 0x61, 0x67, 0x73,
0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x01, 0x00, 0x38, 0x42, 0x49, 0x4d, 0x04, 0x0a, 0x0e, 0x43, 0x6f, 0x70,
0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x46, 0x6c, 0x61, 0x67, 0x00,
0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x38, 0x42, 0x49, 0x4d, 0x27, 0x10,
0x14, 0x4a, 0x61, 0x70, 0x61, 0x6e, 0x65, 0x73, 0x65, 0x20, 0x50, 0x72,
0x69, 0x6e, 0x74, 0x20, 0x46, 0x6c, 0x61, 0x67, 0x73, 0x00, 0x00, 0x00,
0x00, 0x0a, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
0x38, 0x42, 0x49, 0x4d, 0x03, 0xf5, 0x17, 0x43, 0x6f, 0x6c, 0x6f, 0x72,
0x20, 0x48, 0x61, 0x6c, 0x66, 0x74, 0x6f, 0x6e, 0x65, 0x20, 0x53, 0x65,
0x74, 0x74, 0x69, 0x6e, 0x67, 0x73, 0x00, 0x00, 0x00, 0x48, 0x00, 0x2f,
0x66, 0x66, 0x00, 0x01, 0x00, 0x6c, 0x66, 0x66, 0x00, 0x06, 0x00, 0x00,
0x00, 0x00, 0x00, 0x01, 0x00, 0x2f, 0x66, 0x66, 0x00, 0x01, 0x00, 0xa1,
0x99, 0x9a, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x32,
0x00, 0x00, 0x00, 0x01, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00,
0x00, 0x00, 0x00, 0x01, 0x00, 0x35, 0x00, 0x00, 0x00, 0x01, 0x00, 0x2d,
0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x38, 0x42,
0x49, 0x4d, 0x03, 0xf8, 0x17, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x20, 0x54,
0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x20, 0x53, 0x65, 0x74, 0x74,
0x69, 0x6e, 0x67, 0x73, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0xe8, 0x00, 0x00,
0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0x03, 0xe8, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0x03, 0xe8, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0xe8, 0x00, 0x00,
0x38, 0x42, 0x49, 0x4d, 0x04, 0x08, 0x06, 0x47, 0x75, 0x69, 0x64, 0x65,
0x73, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
0x02, 0x40, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x00, 0x00, 0x38, 0x42,
0x49, 0x4d, 0x04, 0x1e, 0x0d, 0x55, 0x52, 0x4c, 0x20, 0x6f, 0x76, 0x65,
0x72, 0x72, 0x69, 0x64, 0x65, 0x73, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
0x00, 0x00, 0x38, 0x42, 0x49, 0x4d, 0x04, 0x1a, 0x06, 0x53, 0x6c, 0x69,
0x63, 0x65, 0x73, 0x00, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 0x06,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31,
0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x55, 0x00, 0x6e,
0x00, 0x74, 0x00, 0x69, 0x00, 0x74, 0x00, 0x6c, 0x00, 0x65, 0x00, 0x64,
0x00, 0x2d, 0x00, 0x31, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x42, 0x49, 0x4d, 0x04, 0x11,
0x11, 0x49, 0x43, 0x43, 0x20, 0x55, 0x6e, 0x74, 0x61, 0x67, 0x67, 0x65,
0x64, 0x20, 0x46, 0x6c, 0x61, 0x67, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00,
0x38, 0x42, 0x49, 0x4d, 0x04, 0x14, 0x17, 0x4c, 0x61, 0x79, 0x65, 0x72,
0x20, 0x49, 0x44, 0x20, 0x47, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x6f,
0x72, 0x20, 0x42, 0x61, 0x73, 0x65, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
0x00, 0x02, 0x38, 0x42, 0x49, 0x4d, 0x04, 0x0c, 0x15, 0x4e, 0x65, 0x77,
0x20, 0x57, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x73, 0x20, 0x54, 0x68, 0x75,
0x6d, 0x62, 0x6e, 0x61, 0x69, 0x6c, 0x00, 0x00, 0x09, 0x12, 0x00, 0x00,
0x00, 0x01, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00,
0x01, 0x3c, 0x00, 0x00, 0x3c, 0x7c, 0x00, 0x00, 0x08, 0xf6, 0x00, 0x18,
0x00, 0x01, 0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46,
0x00, 0x01, 0x02, 0x01, 0x00, 0x48, 0x00, 0x48, 0x00, 0x00, 0xff, 0xee,
0x00, 0x0e, 0x41, 0x64, 0x6f, 0x62, 0x65, 0x00, 0x64, 0x80, 0x00, 0x00,
0x00, 0x01, 0xff, 0xdb, 0x00, 0x84, 0x00, 0x0c, 0x08, 0x08, 0x08, 0x09,
0x08, 0x0c, 0x09, 0x09, 0x0c, 0x11, 0x0b, 0x0a, 0x0b, 0x11, 0x15, 0x0f,
0x0c, 0x0c, 0x0f, 0x15, 0x18, 0x13, 0x13, 0x15, 0x13, 0x13, 0x18, 0x11,
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x11, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x01,
0x0d, 0x0b, 0x0b, 0x0d, 0x0e, 0x0d, 0x10, 0x0e, 0x0e, 0x10, 0x14, 0x0e,
0x0e, 0x0e, 0x14, 0x14, 0x0e, 0x0e, 0x0e, 0x0e, 0x14, 0x11, 0x0c, 0x0c,
0x0c, 0x0c, 0x0c, 0x11, 0x11, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x11,
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
0x0c, 0x0c, 0x0c, 0x0c, 0xff, 0xc0, 0x00, 0x11, 0x08, 0x00, 0x31, 0x00,
0x69, 0x03, 0x01, 0x22, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01, 0xff,
0xdd, 0x00, 0x04, 0x00, 0x07, 0xff, 0xc4, 0x01, 0x3f, 0x00, 0x00, 0x01,
0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x03, 0x00, 0x01, 0x02, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
0x0a, 0x0b, 0x01, 0x00, 0x01, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x03, 0x04,
0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x10, 0x00, 0x01, 0x04, 0x01,
0x03, 0x02, 0x04, 0x02, 0x05, 0x07, 0x06, 0x08, 0x05, 0x03, 0x0c, 0x33,
0x01, 0x00, 0x02, 0x11, 0x03, 0x04, 0x21, 0x12, 0x31, 0x05, 0x41, 0x51,
0x61, 0x13, 0x22, 0x71, 0x81, 0x32, 0x06, 0x14, 0x91, 0xa1, 0xb1, 0x42,
0x23, 0x24, 0x15, 0x52, 0xc1, 0x62, 0x33, 0x34, 0x72, 0x82, 0xd1, 0x43,
0x07, 0x25, 0x92, 0x53, 0xf0, 0xe1, 0xf1, 0x63, 0x73, 0x35, 0x16, 0xa2,
0xb2, 0x83, 0x26, 0x44, 0x93, 0x54, 0x64, 0x45, 0xc2, 0xa3, 0x74, 0x36,
0x17, 0xd2, 0x55, 0xe2, 0x65, 0xf2, 0xb3, 0x84, 0xc3, 0xd3, 0x75, 0xe3,
0xf3, 0x46, 0x27, 0x94, 0xa4, 0x85, 0xb4, 0x95, 0xc4, 0xd4, 0xe4, 0xf4,
0xa5, 0xb5, 0xc5, 0xd5, 0xe5, 0xf5, 0x56, 0x66, 0x76, 0x86, 0x96, 0xa6,
0xb6, 0xc6, 0xd6, 0xe6, 0xf6, 0x37, 0x47, 0x57, 0x67, 0x77, 0x87, 0x97,
0xa7, 0xb7, 0xc7, 0xd7, 0xe7, 0xf7, 0x11, 0x00, 0x02, 0x02, 0x01, 0x02,
0x04, 0x04, 0x03, 0x04, 0x05, 0x06, 0x07, 0x07, 0x06, 0x05, 0x35, 0x01,
0x00, 0x02, 0x11, 0x03, 0x21, 0x31, 0x12, 0x04, 0x41, 0x51, 0x61, 0x71,
0x22, 0x13, 0x05, 0x32, 0x81, 0x91, 0x14, 0xa1, 0xb1, 0x42, 0x23, 0xc1,
0x52, 0xd1, 0xf0, 0x33, 0x24, 0x62, 0xe1, 0x72, 0x82, 0x92, 0x43, 0x53,
0x15, 0x63, 0x73, 0x34, 0xf1, 0x25, 0x06, 0x16, 0xa2, 0xb2, 0x83, 0x07,
0x26, 0x35, 0xc2, 0xd2, 0x44, 0x93, 0x54, 0xa3, 0x17, 0x64, 0x45, 0x55,
0x36, 0x74, 0x65, 0xe2, 0xf2, 0xb3, 0x84, 0xc3, 0xd3, 0x75, 0xe3, 0xf3,
0x46, 0x94, 0xa4, 0x85, 0xb4, 0x95, 0xc4, 0xd4, 0xe4, 0xf4, 0xa5, 0xb5,
0xc5, 0xd5, 0xe5, 0xf5, 0x56, 0x66, 0x76, 0x86, 0x96, 0xa6, 0xb6, 0xc6,
0xd6, 0xe6, 0xf6, 0x27, 0x37, 0x47, 0x57, 0x67, 0x77, 0x87, 0x97, 0xa7,
0xb7, 0xc7, 0xff, 0xda, 0x00, 0x0c, 0x03, 0x01, 0x00, 0x02, 0x11, 0x03,
0x11, 0x00, 0x3f, 0x00, 0x17, 0xd6, 0x57, 0xd9, 0x67, 0x5e, 0xcc, 0x6b,
0x5c, 0x63, 0x78, 0x11, 0x3a, 0x68, 0xd6, 0x84, 0x2c, 0x7e, 0x98, 0xfb,
0x04, 0x99, 0x2a, 0xef, 0x52, 0xac, 0x3f, 0xeb, 0x0e, 0x61, 0x3f, 0xe9,
0x7f, 0x80, 0x5d, 0x0f, 0x49, 0xc0, 0x65, 0x80, 0x08, 0x5a, 0x87, 0x2f,
0x06, 0x38, 0xff, 0x00, 0x74, 0x34, 0x23, 0x8f, 0x8e, 0x72, 0xbe, 0xe5,
0xe4, 0xee, 0xe9, 0x4e, 0x63, 0x64, 0x02, 0x14, 0x7a, 0x46, 0x26, 0x75,
0x9d, 0x53, 0x1e, 0xbc, 0x76, 0x3e, 0xc2, 0xcb, 0x18, 0xf7, 0x86, 0x4c,
0x06, 0x87, 0x37, 0x73, 0xdf, 0xfb, 0xad, 0xfe, 0xb2, 0xef, 0xed, 0xfa,
0xbe, 0x2d, 0x30, 0xe2, 0x2b, 0xa9, 0xbf, 0x4d, 0xe7, 0xb0, 0x58, 0xf9,
0xfd, 0x6a, 0x9e, 0x9e, 0xfa, 0xba, 0x6f, 0x44, 0x68, 0xaa, 0xb7, 0xd8,
0xc1, 0x91, 0x93, 0x12, 0xfb, 0x3d, 0xd0, 0xe8, 0x27, 0xfe, 0xaf, 0xfe,
0xdb, 0xd8, 0x99, 0x1e, 0x60, 0xcc, 0x18, 0xc4, 0x71, 0x13, 0xdf, 0xe5,
0x8a, 0xe9, 0x60, 0x11, 0x36, 0x4d, 0x01, 0xdb, 0x72, 0xd2, 0xcf, 0xfa,
0x95, 0xf5, 0x83, 0x27, 0x27, 0x23, 0x25, 0x81, 0x8e, 0xae, 0xdb, 0x5e,
0xf6, 0x30, 0xd9, 0xee, 0xda, 0xe7, 0x17, 0x37, 0x9f, 0x67, 0xfd, 0x35,
0x98, 0xfe, 0x81, 0x97, 0x8e, 0xf3, 0x56, 0x4d, 0x6e, 0xae, 0xc1, 0xd9,
0xdf, 0xc3, 0xf3, 0x5c, 0x8e, 0xc7, 0xde, 0x7a, 0xb6, 0x4b, 0xc5, 0xaf,
0x0e, 0x17, 0xd9, 0x04, 0x38, 0xc8, 0x87, 0x3a, 0x17, 0x6f, 0xd3, 0x9d,
0xfb, 0x43, 0x14, 0x63, 0xe6, 0xfe, 0x95, 0xcd, 0xfa, 0x16, 0x9f, 0xa4,
0x3e, 0x69, 0x4f, 0x2e, 0x4c, 0x60, 0x59, 0x12, 0x1e, 0x03, 0x84, 0xaa,
0x38, 0xa1, 0x32, 0x68, 0x10, 0x7c, 0x4f, 0x13, 0xe7, 0x57, 0xf4, 0xb7,
0xd6, 0x24, 0x48, 0x45, 0xfa, 0xb6, 0xeb, 0x2b, 0xeb, 0x98, 0xcd, 0x71,
0x30, 0x37, 0xe9, 0x3a, 0x7f, 0x37, 0x62, 0xea, 0xfa, 0xc7, 0x4d, 0x6d,
0x12, 0xd2, 0x3e, 0x05, 0x73, 0xbd, 0x36, 0xb0, 0xce, 0xbd, 0x8e, 0x47,
0xf2, 0xff, 0x00, 0xf3, 0xdd, 0x89, 0xf1, 0xcb, 0xc7, 0x8e, 0x5f, 0xdd,
0x2b, 0x65, 0x8f, 0x82, 0x71, 0xae, 0xe1, 0xc5, 0xa9, 0x96, 0xde, 0xe8,
0x92, 0x47, 0x99, 0x95, 0x7e, 0xbe, 0x92, 0xe7, 0x36, 0x48, 0x28, 0x9d,
0x22, 0x86, 0xb8, 0x89, 0x5d, 0x97, 0x4f, 0xe9, 0x6d, 0xb6, 0xbd, 0x07,
0x64, 0x73, 0x66, 0xe0, 0x46, 0x2c, 0x3c, 0x42, 0xcb, 0xc2, 0x64, 0xf4,
0xe7, 0xd6, 0x24, 0x48, 0x5a, 0x1f, 0x53, 0x1f, 0x68, 0xeb, 0xac, 0x61,
0x2e, 0x23, 0xd3, 0x78, 0x23, 0x58, 0xd0, 0x4e, 0xab, 0xab, 0xca, 0xfa,
0xbf, 0x8a, 0xd6, 0x9b, 0x73, 0xae, 0x14, 0x50, 0x39, 0x03, 0x57, 0x1f,
0x87, 0xfa, 0xbd, 0x55, 0xe9, 0x7d, 0x67, 0xa6, 0xd3, 0xd5, 0x6b, 0xe9,
0x7d, 0x23, 0x10, 0x55, 0x4d, 0xa1, 0xfe, 0xb6, 0x4b, 0xff, 0x00, 0x9c,
0x7e, 0xd6, 0xb9, 0xe3, 0xf2, 0x7e, 0x7f, 0xfd, 0xb6, 0xc5, 0x19, 0xcf,
0xc7, 0x8e, 0x40, 0x44, 0xcb, 0x43, 0x67, 0xf4, 0x62, 0xbc, 0x61, 0x11,
0x9c, 0x49, 0x3c, 0x3a, 0xed, 0xd4, 0xbd, 0x02, 0x49, 0x24, 0xa8, 0xb6,
0x9f, 0xff, 0xd0, 0xe8, 0x32, 0x7e, 0xa8, 0xf5, 0x2b, 0x7a, 0xae, 0x4e,
0x6b, 0xed, 0xa6, 0x9c, 0x6b, 0x1f, 0xbc, 0x39, 0xce, 0x33, 0x1f, 0xd5,
0xdb, 0xb7, 0xfe, 0x9a, 0xd3, 0xc6, 0xbf, 0xa3, 0x74, 0xc6, 0xed, 0xfb,
0x4f, 0xda, 0xef, 0x1d, 0x99, 0x1b, 0x67, 0xe5, 0x2d, 0xff, 0x00, 0xa6,
0xb9, 0x6f, 0xac, 0x1d, 0x0b, 0xad, 0x64, 0xf5, 0x7c, 0x9c, 0x8a, 0x31,
0xdf, 0x65, 0x2e, 0x70, 0x35, 0xb8, 0x11, 0x1f, 0x45, 0xb3, 0xb5, 0xbb,
0x95, 0x6a, 0xba, 0x57, 0xd6, 0x1a, 0xc4, 0x7d, 0x8e, 0xdf, 0xc3, 0xfb,
0xd5, 0xfe, 0x01, 0x38, 0xc7, 0x8b, 0x28, 0xd8, 0x7a, 0x45, 0x45, 0xa6,
0x27, 0xc3, 0x23, 0x58, 0xce, 0xe7, 0x5d, 0x64, 0xf4, 0xfd, 0x53, 0xaf,
0x3b, 0x22, 0xb2, 0xd0, 0x76, 0x33, 0xf7, 0x07, 0xf1, 0xfd, 0xe5, 0xc9,
0x5b, 0x78, 0xb3, 0xa8, 0x63, 0x81, 0xde, 0xd6, 0x7f, 0xd5, 0x04, 0x7b,
0x3a, 0x67, 0xd6, 0x17, 0x88, 0x18, 0x76, 0xfe, 0x1f, 0xde, 0xa3, 0x85,
0xf5, 0x77, 0xae, 0xfd, 0xbb, 0x1e, 0xdb, 0x71, 0x1e, 0x18, 0xdb, 0x58,
0xe7, 0x92, 0x5a, 0x20, 0x07, 0x02, 0xef, 0xce, 0x52, 0x63, 0x8e, 0x38,
0x03, 0xea, 0x8e, 0xdd, 0xd6, 0x4e, 0x53, 0x99, 0x1e, 0x93, 0xf6, 0x30,
0x37, 0x8a, 0xfa, 0xae, 0x58, 0x3d, 0xaf, 0xb3, 0xfe, 0xad, 0xcb, 0xa5,
0xe9, 0xfd, 0x54, 0x56, 0xc1, 0x05, 0x73, 0xdd, 0x43, 0xea, 0xef, 0x5c,
0x77, 0x50, 0xc9, 0xbe, 0xac, 0x57, 0xb9, 0x8f, 0xba, 0xc7, 0x31, 0xc0,
0xb4, 0xc8, 0x2e, 0x71, 0x69, 0xfa, 0x49, 0xeb, 0xe9, 0x9f, 0x58, 0x58,
0x23, 0xec, 0x76, 0xfe, 0x1f, 0xde, 0x94, 0xe3, 0x8e, 0x71, 0x1e, 0xa8,
0xed, 0xdd, 0x50, 0x94, 0xe2, 0x4f, 0xa4, 0xef, 0xd9, 0xeb, 0x6c, 0xeb,
0x1d, 0x3b, 0x36, 0xbf, 0xb3, 0x75, 0x07, 0x7a, 0x47, 0xfc, 0x1e, 0x40,
0xec, 0x7f, 0x96, 0xb3, 0xf1, 0xbe, 0xad, 0x5a, 0xce, 0xa7, 0x56, 0x75,
0x19, 0xb8, 0xd9, 0x18, 0xcc, 0xdd, 0xab, 0x5c, 0x77, 0x9d, 0xcd, 0x73,
0x34, 0x6b, 0x43, 0xd9, 0xf9, 0xff, 0x00, 0xe9, 0x16, 0x0d, 0xbd, 0x2b,
0xeb, 0x15, 0x82, 0x3e, 0xc7, 0x6f, 0xe1, 0xfd, 0xea, 0xc7, 0x40, 0xe8,
0x1d, 0x62, 0x8e, 0xaf, 0x46, 0x46, 0x46, 0x33, 0x99, 0x53, 0x77, 0xee,
0x73, 0x8b, 0x74, 0x96, 0x3d, 0xa3, 0xf3, 0xb7, 0x7d, 0x22, 0x99, 0xc1,
0x18, 0x46, 0x5c, 0x39, 0x00, 0xd0, 0xfa, 0x74, 0x92, 0xfe, 0x33, 0x29,
0x00, 0x60, 0x4e, 0xa3, 0xd5, 0xac, 0x5d, 0x2e, 0x9f, 0xd3, 0x7e, 0xaf,
0xf4, 0xb0, 0x0e, 0x6f, 0x53, 0x66, 0x55, 0xa3, 0xfc, 0x16, 0x3e, 0xa2,
0x7f, 0x75, 0xce, 0x67, 0xa9, 0xff, 0x00, 0xa2, 0x96, 0xbb, 0x7e, 0xb1,
0xe2, 0xb5, 0x9b, 0x30, 0xea, 0x15, 0x56, 0x38, 0x2e, 0xe5, 0x70, 0xe3,
0xea, 0xdf, 0xd6, 0x0a, 0x8e, 0xe1, 0x86, 0xff, 0x00, 0x91, 0x69, 0xfc,
0x8e, 0x56, 0x59, 0xd3, 0x7e, 0xb0, 0xb4, 0x41, 0xc3, 0xb7, 0xf0, 0xfe,
0xf4, 0x67, 0x8a, 0x12, 0x36, 0x72, 0x09, 0x7d, 0x63, 0x5f, 0x62, 0x23,
0x96, 0x51, 0xd0, 0x40, 0xc7, 0xe8, 0x5d, 0x6e, 0xad, 0xd5, 0x3d, 0x79,
0x2e, 0x76, 0xe3, 0xe6, 0xb3, 0x3e, 0xac, 0xd8, 0x2c, 0xfa, 0xcb, 0x41,
0xf0, 0x6d, 0x9f, 0xf5, 0x0e, 0x40, 0xbb, 0xa4, 0x7d, 0x61, 0xb7, 0x4f,
0xb1, 0xd9, 0xf8, 0x7f, 0x7a, 0xd1, 0xfa, 0xab, 0xd0, 0xba, 0xae, 0x1f,
0x57, 0x66, 0x46, 0x5e, 0x39, 0xae, 0xb6, 0xb1, 0xfe, 0xf2, 0x5b, 0xc9,
0x1b, 0x7b, 0x39, 0x12, 0x21, 0x0c, 0x53, 0x02, 0x51, 0xf9, 0x4f, 0x54,
0x5c, 0xe5, 0x92, 0x3e, 0x93, 0x56, 0x3a, 0x3d, 0xaa, 0x49, 0x24, 0xa8,
0x36, 0xdf, 0xff, 0xd1, 0xda, 0xea, 0x7f, 0x5a, 0x7a, 0xde, 0x1d, 0x9d,
0x53, 0x23, 0x1f, 0x0f, 0x1e, 0xfc, 0x1e, 0x95, 0x73, 0x28, 0xb0, 0x3a,
0xc7, 0xb2, 0xe7, 0x9b, 0x5b, 0x4b, 0x9a, 0xf6, 0x7b, 0x1f, 0x56, 0xda,
0xdf, 0x90, 0xcd, 0xeb, 0x4f, 0xa3, 0x75, 0x4e, 0xa9, 0x77, 0x50, 0xcc,
0xe9, 0x7d, 0x5a, 0xaa, 0x19, 0x93, 0x8b, 0x5d, 0x57, 0x32, 0xcc, 0x67,
0x3c, 0xd6, 0xe6, 0x5d, 0xea, 0x37, 0x8b, 0x80, 0x7b, 0x5f, 0x5b, 0xe9,
0x47, 0xbf, 0xea, 0xff, 0x00, 0x4e, 0xbe, 0x9c, 0xea, 0x6c, 0x6b, 0xb6,
0x75, 0x2b, 0x1b, 0x76, 0x4c, 0x3a, 0x25, 0xcc, 0x15, 0xb5, 0x9b, 0x3f,
0x73, 0xf9, 0x8a, 0xd5, 0x8a, 0xfa, 0x7e, 0x3d, 0x7d, 0x42, 0xee, 0xa2,
0xd0, 0x7e, 0xd1, 0x7d, 0x6c, 0xa6, 0xc3, 0x3a, 0x6d, 0xac, 0xbd, 0xf5,
0xc3, 0x7f, 0xeb, 0xcf, 0x4e, 0x58, 0xd7, 0xeb, 0xdd, 0x56, 0xce, 0x97,
0x82, 0x2e, 0xa6, 0xa1, 0x7e, 0x45, 0xd6, 0xd5, 0x8d, 0x8f, 0x53, 0x9d,
0xb1, 0xa6, 0xdb, 0x9e, 0x29, 0xab, 0xd4, 0xb3, 0x5d, 0x95, 0xb5, 0xce,
0xf7, 0xaa, 0xdd, 0x2f, 0xaa, 0xf5, 0x5f, 0xda, 0xcf, 0xe8, 0xfd, 0x62,
0xaa, 0x1b, 0x92, 0x68, 0xfb, 0x55, 0x17, 0x62, 0xb9, 0xc6, 0xb7, 0x56,
0x1c, 0xda, 0x2c, 0x63, 0xd9, 0x70, 0xf5, 0x2b, 0xb2, 0xbb, 0x1e, 0xcf,
0xf8, 0xc5, 0xa3, 0xd4, 0xba, 0x76, 0x27, 0x53, 0xc3, 0xb3, 0x0b, 0x31,
0x9e, 0xa5, 0x36, 0x44, 0x80, 0x4b, 0x48, 0x2d, 0x3b, 0xd8, 0xf6, 0x3d,
0xbe, 0xe6, 0x3d, 0x8f, 0x6e, 0xe6, 0x39, 0x57, 0xe9, 0x7d, 0x07, 0x0f,
0xa6, 0x5d, 0x6e, 0x4b, 0x1f, 0x76, 0x4e, 0x55, 0xcd, 0x0c, 0x7e, 0x4e,
0x55, 0x8e, 0xb6, 0xcd, 0x8d, 0x25, 0xcc, 0xa5, 0xaf, 0x7f, 0xd0, 0xad,
0xbb, 0xbf, 0x31, 0x15, 0x32, 0xeb, 0xbd, 0x57, 0xf6, 0x47, 0x4c, 0xb3,
0x35, 0xb5, 0xfa, 0xf6, 0x07, 0x32, 0xba, 0x6a, 0x9d, 0xa1, 0xd6, 0x5a,
0xf6, 0xd1, 0x53, 0x5c, 0xff, 0x00, 0xcc, 0x66, 0xfb, 0x3d, 0xef, 0x43,
0xe9, 0x77, 0xfd, 0x61, 0x39, 0x36, 0x51, 0xd5, 0xf1, 0xa8, 0x6d, 0x7b,
0x03, 0xea, 0xca, 0xc5, 0x79, 0x2c, 0x26, 0x76, 0xbb, 0x1e, 0xca, 0xaf,
0xdb, 0x7f, 0xa8, 0xdf, 0xa7, 0xea, 0x6d, 0xf4, 0x55, 0xcc, 0xfc, 0x0c,
0x5e, 0xa3, 0x87, 0x6e, 0x16, 0x63, 0x3d, 0x5c, 0x7b, 0xdb, 0xb6, 0xc6,
0x49, 0x1d, 0xf7, 0x08, 0x73, 0x7d, 0xcd, 0x73, 0x5c, 0x37, 0x31, 0xca,
0x97, 0x49, 0xfa, 0xb9, 0xd3, 0xfa, 0x5e, 0x45, 0xb9, 0x75, 0x3a, 0xec,
0x8c, 0xbb, 0xda, 0x18, 0xfc, 0xac, 0x9b, 0x1d, 0x6d, 0xbb, 0x01, 0x96,
0xd2, 0xd7, 0xbf, 0xe8, 0xd6, 0x92, 0x92, 0x75, 0xee, 0xa8, 0xee, 0x95,
0xd3, 0x5f, 0x97, 0x5d, 0x5e, 0xbd, 0xc5, 0xf5, 0xd5, 0x4d, 0x44, 0xed,
0x0e, 0xb2, 0xd7, 0xb6, 0x8a, 0xb7, 0xbf, 0xf3, 0x19, 0xbe, 0xcf, 0x7a,
0xa3, 0x85, 0xd6, 0x3a, 0xdb, 0x7a, 0xf5, 0x3d, 0x1b, 0xaa, 0x63, 0xe3,
0x34, 0xdb, 0x8c, 0xfc, 0x91, 0x91, 0x8c, 0xf7, 0xb9, 0xa7, 0x63, 0x99,
0x5f, 0xa7, 0xe9, 0xdc, 0xd6, 0x3d, 0x9b, 0x77, 0xad, 0x6e, 0xa1, 0xd3,
0xf1, 0x3a, 0x96, 0x1d, 0xb8, 0x59, 0xb5, 0x8b, 0x71, 0xee, 0x10, 0xf6,
0xea, 0x38, 0x3b, 0x9a, 0xe6, 0xb9, 0xbe, 0xe6, 0xbd, 0x8e, 0x1b, 0xd8,
0xf5, 0x47, 0x03, 0xea, 0xc7, 0x4e, 0xc1, 0xcf, 0x6f, 0x52, 0x6b, 0xf2,
0x2f, 0xcc, 0x6d, 0x46, 0x8f, 0x5f, 0x22, 0xe7, 0xda, 0xe2, 0xc2, 0x43,
0xb6, 0x7e, 0x90, 0xfe, 0x6e, 0xdf, 0x6e, 0xc4, 0x94, 0x9b, 0xeb, 0x07,
0x53, 0x7f, 0x49, 0xe8, 0xd9, 0x7d, 0x4a, 0xb6, 0x0b, 0x5f, 0x8b, 0x59,
0x7b, 0x58, 0xe3, 0x00, 0xc7, 0x63, 0x0a, 0xa7, 0x4a, 0xeb, 0x1d, 0x52,
0xde, 0xaa, 0x7a, 0x6f, 0x54, 0xa2, 0x9a, 0x9f, 0x76, 0x2f, 0xdb, 0x71,
0x9d, 0x8e, 0xf7, 0x3c, 0x06, 0x07, 0xb6, 0x9b, 0x28, 0xb8, 0xd8, 0xd6,
0x6e, 0xb6, 0xb7, 0x5b, 0x5f, 0xe9, 0x19, 0xec, 0x5a, 0x5d, 0x4b, 0xa7,
0xe3, 0x75, 0x3c, 0x1b, 0xb0, 0x32, 0x81, 0x34, 0x64, 0x37, 0x65, 0x81,
0xa6, 0x0c, 0x1f, 0x07, 0x26, 0x6f, 0x4d, 0xc5, 0x6e, 0x7d, 0x79, 0xe0,
0x1f, 0x5e, 0xaa, 0x0e, 0x2b, 0x0c, 0xe9, 0xe9, 0xb9, 0xcc, 0xb5, 0xde,
0xdf, 0xde, 0xdf, 0x4b, 0x12, 0x52, 0x3e, 0xbb, 0xd5, 0x5b, 0xd1, 0xfa,
0x56, 0x47, 0x51, 0x35, 0x9b, 0x8d, 0x21, 0xbb, 0x2a, 0x06, 0x37, 0x3d,
0xee, 0x6d, 0x35, 0x33, 0x77, 0xe6, 0xee, 0xb2, 0xc6, 0x7b, 0x96, 0x65,
0x7d, 0x4b, 0xad, 0xfe, 0xd3, 0xc5, 0xe8, 0xdd, 0x63, 0x1b, 0x14, 0x37,
0xa8, 0x53, 0x7b, 0xfd, 0x5c, 0x77, 0xbd, 0xc0, 0x7a, 0x62, 0xb9, 0xab,
0xd3, 0xb9, 0x8d, 0xfa, 0x3e, 0xb7, 0xd3, 0xff, 0x00, 0x08, 0xb6, 0xf3,
0x70, 0xb1, 0x73, 0xf1, 0x2d, 0xc3, 0xcb, 0xac, 0x5b, 0x8f, 0x7b, 0x4b,
0x2c, 0xac, 0xce, 0xa0, 0xf9, 0x8f, 0x73, 0x56, 0x76, 0x07, 0xd5, 0x7e,
0x9d, 0x83, 0x99, 0x4e, 0x73, 0x6c, 0xc8, 0xbf, 0x27, 0x1d, 0x8f, 0xaa,
0xbb, 0x32, 0x2e, 0x7d, 0xa4, 0x56, 0xf8, 0xfd, 0x14, 0x58, 0x76, 0xec,
0xaf, 0x6f, 0xb1, 0x25, 0x27, 0xc1, 0xe8, 0xd5, 0xe1, 0x66, 0x5b, 0x94,
0xcb, 0xed, 0x78, 0xb5, 0x81, 0x82, 0x87, 0x19, 0xad, 0x90, 0x1a, 0xd9,
0xa9, 0x91, 0xec, 0xf6, 0xd6, 0xd5, 0xa0, 0x92, 0x49, 0x29, 0xff, 0xd2,
0xf4, 0x54, 0x97, 0xcc, 0xa9, 0x27, 0xac, 0x7e, 0x9a, 0x49, 0x7c, 0xca,
0x92, 0x4a, 0x7e, 0x9a, 0x49, 0x7c, 0xca, 0x92, 0x4a, 0x7e, 0x9a, 0x49,
0x7c, 0xca, 0x92, 0x4a, 0x7e, 0x9a, 0x49, 0x7c, 0xca, 0x92, 0x4a, 0x7e,
0x9a, 0x49, 0x7c, 0xca, 0x92, 0x4a, 0x7e, 0x9a, 0x49, 0x7c, 0xca, 0x92,
0x4a, 0x7f, 0xff, 0xd9, 0x38, 0x42, 0x49, 0x4d, 0x04, 0x21, 0x1a, 0x56,
0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x63, 0x6f, 0x6d, 0x70, 0x61,
0x74, 0x69, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x20, 0x69, 0x6e, 0x66,
0x6f, 0x00, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00,
0x00, 0x00, 0x0f, 0x00, 0x41, 0x00, 0x64, 0x00, 0x6f, 0x00, 0x62, 0x00,
0x65, 0x00, 0x20, 0x00, 0x50, 0x00, 0x68, 0x00, 0x6f, 0x00, 0x74, 0x00,
0x6f, 0x00, 0x73, 0x00, 0x68, 0x00, 0x6f, 0x00, 0x70, 0x00, 0x00, 0x00,
0x13, 0x00, 0x41, 0x00, 0x64, 0x00, 0x6f, 0x00, 0x62, 0x00, 0x65, 0x00,
0x20, 0x00, 0x50, 0x00, 0x68, 0x00, 0x6f, 0x00, 0x74, 0x00, 0x6f, 0x00,
0x73, 0x00, 0x68, 0x00, 0x6f, 0x00, 0x70, 0x00, 0x20, 0x00, 0x36, 0x00,
0x2e, 0x00, 0x30, 0x00, 0x00, 0x00, 0x01, 0x00, 0x38, 0x42, 0x49, 0x4d,
0x04, 0x06, 0x0c, 0x4a, 0x50, 0x45, 0x47, 0x20, 0x51, 0x75, 0x61, 0x6c,
0x69, 0x74, 0x79, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x06, 0x00, 0x00,
0x00, 0x01, 0x01, 0x00, 0xff, 0xee, 0x00, 0x0e, 0x41, 0x64, 0x6f, 0x62,
0x65, 0x00, 0x64, 0x40, 0x00, 0x00, 0x00, 0x01, 0xff, 0xdb, 0x00, 0x84,
0x00, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03,
0x02, 0x02, 0x02, 0x03, 0x04, 0x03, 0x02, 0x02, 0x03, 0x04, 0x05, 0x04,
0x04, 0x04, 0x04, 0x04, 0x05, 0x06, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
0x06, 0x06, 0x07, 0x07, 0x08, 0x07, 0x07, 0x06, 0x09, 0x09, 0x0a, 0x0a,
0x09, 0x09, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x01, 0x03, 0x03, 0x03, 0x05, 0x04, 0x05,
0x09, 0x06, 0x06, 0x09, 0x0d, 0x0a, 0x09, 0x0a, 0x0d, 0x0f, 0x0e, 0x0e,
0x0e, 0x0e, 0x0f, 0x0f, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0f, 0x0f, 0x0c,
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0f, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0xff, 0xc0,
0x00, 0x11, 0x08, 0x00, 0x31, 0x00, 0x69, 0x03, 0x01, 0x11, 0x00, 0x02,
0x11, 0x01, 0x03, 0x11, 0x01, 0xff, 0xdd, 0x00, 0x04, 0x00, 0x0e, 0xff,
0xc4, 0x01, 0xa2, 0x00, 0x00, 0x00, 0x07, 0x01, 0x01, 0x01, 0x01, 0x01,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x05, 0x03, 0x02,
0x06, 0x01, 0x00, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x01, 0x00, 0x02, 0x02,
0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x01, 0x00, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
0x0b, 0x10, 0x00, 0x02, 0x01, 0x03, 0x03, 0x02, 0x04, 0x02, 0x06, 0x07,
0x03, 0x04, 0x02, 0x06, 0x02, 0x73, 0x01, 0x02, 0x03, 0x11, 0x04, 0x00,
0x05, 0x21, 0x12, 0x31, 0x41, 0x51, 0x06, 0x13, 0x61, 0x22, 0x71, 0x81,
0x14, 0x32, 0x91, 0xa1, 0x07, 0x15, 0xb1, 0x42, 0x23, 0xc1, 0x52, 0xd1,
0xe1, 0x33, 0x16, 0x62, 0xf0, 0x24, 0x72, 0x82, 0xf1, 0x25, 0x43, 0x34,
0x53, 0x92, 0xa2, 0xb2, 0x63, 0x73, 0xc2, 0x35, 0x44, 0x27, 0x93, 0xa3,
0xb3, 0x36, 0x17, 0x54, 0x64, 0x74, 0xc3, 0xd2, 0xe2, 0x08, 0x26, 0x83,
0x09, 0x0a, 0x18, 0x19, 0x84, 0x94, 0x45, 0x46, 0xa4, 0xb4, 0x56, 0xd3,
0x55, 0x28, 0x1a, 0xf2, 0xe3, 0xf3, 0xc4, 0xd4, 0xe4, 0xf4, 0x65, 0x75,
0x85, 0x95, 0xa5, 0xb5, 0xc5, 0xd5, 0xe5, 0xf5, 0x66, 0x76, 0x86, 0x96,
0xa6, 0xb6, 0xc6, 0xd6, 0xe6, 0xf6, 0x37, 0x47, 0x57, 0x67, 0x77, 0x87,
0x97, 0xa7, 0xb7, 0xc7, 0xd7, 0xe7, 0xf7, 0x38, 0x48, 0x58, 0x68, 0x78,
0x88, 0x98, 0xa8, 0xb8, 0xc8, 0xd8, 0xe8, 0xf8, 0x29, 0x39, 0x49, 0x59,
0x69, 0x79, 0x89, 0x99, 0xa9, 0xb9, 0xc9, 0xd9, 0xe9, 0xf9, 0x2a, 0x3a,
0x4a, 0x5a, 0x6a, 0x7a, 0x8a, 0x9a, 0xaa, 0xba, 0xca, 0xda, 0xea, 0xfa,
0x11, 0x00, 0x02, 0x02, 0x01, 0x02, 0x03, 0x05, 0x05, 0x04, 0x05, 0x06,
0x04, 0x08, 0x03, 0x03, 0x6d, 0x01, 0x00, 0x02, 0x11, 0x03, 0x04, 0x21,
0x12, 0x31, 0x41, 0x05, 0x51, 0x13, 0x61, 0x22, 0x06, 0x71, 0x81, 0x91,
0x32, 0xa1, 0xb1, 0xf0, 0x14, 0xc1, 0xd1, 0xe1, 0x23, 0x42, 0x15, 0x52,
0x62, 0x72, 0xf1, 0x33, 0x24, 0x34, 0x43, 0x82, 0x16, 0x92, 0x53, 0x25,
0xa2, 0x63, 0xb2, 0xc2, 0x07, 0x73, 0xd2, 0x35, 0xe2, 0x44, 0x83, 0x17,
0x54, 0x93, 0x08, 0x09, 0x0a, 0x18, 0x19, 0x26, 0x36, 0x45, 0x1a, 0x27,
0x64, 0x74, 0x55, 0x37, 0xf2, 0xa3, 0xb3, 0xc3, 0x28, 0x29, 0xd3, 0xe3,
0xf3, 0x84, 0x94, 0xa4, 0xb4, 0xc4, 0xd4, 0xe4, 0xf4, 0x65, 0x75, 0x85,
0x95, 0xa5, 0xb5, 0xc5, 0xd5, 0xe5, 0xf5, 0x46, 0x56, 0x66, 0x76, 0x86,
0x96, 0xa6, 0xb6, 0xc6, 0xd6, 0xe6, 0xf6, 0x47, 0x57, 0x67, 0x77, 0x87,
0x97, 0xa7, 0xb7, 0xc7, 0xd7, 0xe7, 0xf7, 0x38, 0x48, 0x58, 0x68, 0x78,
0x88, 0x98, 0xa8, 0xb8, 0xc8, 0xd8, 0xe8, 0xf8, 0x39, 0x49, 0x59, 0x69,
0x79, 0x89, 0x99, 0xa9, 0xb9, 0xc9, 0xd9, 0xe9, 0xf9, 0x2a, 0x3a, 0x4a,
0x5a, 0x6a, 0x7a, 0x8a, 0x9a, 0xaa, 0xba, 0xca, 0xda, 0xea, 0xfa, 0xff,
0xda, 0x00, 0x0c, 0x03, 0x01, 0x00, 0x02, 0x11, 0x03, 0x11, 0x00, 0x3f,
0x00, 0x21, 0xff, 0x00, 0x9c, 0x93, 0xba, 0xd4, 0x75, 0x3f, 0xcf, 0xaf,
0xcc, 0x5b, 0x4b, 0x6b, 0xab, 0x83, 0x0f, 0xe9, 0x08, 0xa1, 0x10, 0x19,
0x1b, 0x80, 0xf4, 0xed, 0xa1, 0x43, 0xf0, 0xd6, 0x94, 0xaa, 0xed, 0x9e,
0xc5, 0xd8, 0x51, 0x8c, 0x34, 0x38, 0xc9, 0x03, 0x97, 0xe9, 0x2f, 0x97,
0xf6, 0xb1, 0x94, 0xb5, 0x73, 0x00, 0x9e, 0x63, 0xee, 0x09, 0x06, 0x81,
0xf9, 0x67, 0x77, 0xa8, 0x44, 0xaf, 0x28, 0x92, 0x5a, 0x8a, 0xee, 0x49,
0xcb, 0xb3, 0x6b, 0xc4, 0x4a, 0x30, 0xe8, 0x0c, 0x86, 0xe8, 0xfd, 0x63,
0xf2, 0xae, 0xe6, 0xce, 0x16, 0x78, 0xd2, 0x48, 0xc8, 0x15, 0xa8, 0x24,
0x64, 0x71, 0x76, 0x88, 0x91, 0x67, 0x97, 0xb3, 0xe8, 0x6c, 0x81, 0xfc,
0xa5, 0xf2, 0x97, 0x9e, 0x75, 0x2f, 0xcd, 0x1f, 0x28, 0xe9, 0x7e, 0x5c,
0xd3, 0x35, 0x4d, 0x62, 0x4b, 0x0d, 0x66, 0xc6, 0xff, 0x00, 0x50, 0x86,
0xc5, 0x64, 0x65, 0x8a, 0xd6, 0x0b, 0x98, 0xda, 0x59, 0xa7, 0x20, 0x84,
0x8d, 0x14, 0x75, 0x67, 0x20, 0x7b, 0xe4, 0xbb, 0x47, 0x51, 0x82, 0x3a,
0x69, 0xca, 0x64, 0x0b, 0x89, 0x02, 0xfb, 0xc8, 0xe4, 0x1a, 0x74, 0x58,
0x33, 0x1d, 0x44, 0x63, 0x00, 0x4d, 0x10, 0x4d, 0x77, 0x5f, 0x57, 0xd3,
0x5e, 0x7c, 0xff, 0x00, 0x9c, 0x2d, 0xff, 0x00, 0x9c, 0x82, 0xf3, 0x3f,
0x99, 0xbc, 0xdd, 0xe6, 0x8b, 0x14, 0xd3, 0x6e, 0x74, 0xdd, 0x6f, 0x5c,
0xd4, 0x35, 0x1d, 0x33, 0x4c, 0x7d, 0x54, 0x0b, 0x93, 0x6f, 0x73, 0x71,
0x24, 0xb1, 0x1e, 0x2e, 0x04, 0x4a, 0x4a, 0x30, 0xd8, 0xc9, 0xb6, 0x68,
0xf4, 0x7e, 0xd3, 0xe8, 0x30, 0xe3, 0x86, 0x33, 0x60, 0x88, 0x80, 0x4f,
0x0e, 0xd6, 0x06, 0xfe, 0x7f, 0x63, 0xb7, 0xd4, 0xfb, 0x3f, 0xac, 0xcb,
0x39, 0x4c, 0x11, 0x44, 0x92, 0x05, 0xef, 0xb9, 0xf9, 0x7d, 0xaf, 0x10,
0xbc, 0xfc, 0x83, 0xf3, 0x57, 0x96, 0xef, 0x9f, 0x49, 0xf3, 0x56, 0x8b,
0x79, 0xa5, 0xea, 0x71, 0x0a, 0xb5, 0xbd, 0xc8, 0x3f, 0x10, 0xe9, 0xca,
0x37, 0x04, 0xa3, 0xa9, 0xec, 0xca, 0x48, 0xf7, 0xcd, 0xa4, 0x7b, 0x63,
0x16, 0x51, 0xc5, 0x8e, 0x40, 0x87, 0x0b, 0xf9, 0x26, 0x78, 0xcf, 0x0c,
0xc1, 0x05, 0x8a, 0xeb, 0xdf, 0x96, 0x37, 0x7a, 0x7c, 0x4e, 0xf1, 0x09,
0x22, 0x2a, 0x2b, 0xb1, 0x39, 0x91, 0x87, 0x5e, 0x24, 0x77, 0x69, 0xcd,
0xa0, 0x31, 0x1b, 0x27, 0xff, 0x00, 0xf3, 0x8d, 0xb3, 0xea, 0x3a, 0x6f,
0xe7, 0x97, 0x92, 0xed, 0x2e, 0x2e, 0x6e, 0x04, 0x31, 0x9d, 0x4e, 0xb0,
0xfa, 0x8d, 0xc0, 0xff, 0x00, 0xb8, 0xdb, 0xaf, 0xd9, 0xad, 0x3a, 0xe5,
0x3d, 0xb8, 0x23, 0x2d, 0x14, 0xc8, 0x03, 0xa7, 0xfb, 0xa0, 0xbd, 0x92,
0x65, 0x1d, 0x5c, 0x01, 0x27, 0xaf, 0xdc, 0x5e, 0x29, 0xa6, 0x59, 0xea,
0xda, 0xfc, 0xe9, 0x1b, 0x5d, 0x5c, 0x4c, 0x8a, 0x68, 0x19, 0xdd, 0x9a,
0x95, 0xf0, 0xa9, 0x39, 0xb5, 0xc9, 0x28, 0x62, 0x1c, 0x83, 0xaf, 0xc7,
0x09, 0xe5, 0x3c, 0xcb, 0xd8, 0x74, 0xdf, 0xca, 0x7b, 0x8b, 0x98, 0x04,
0x8f, 0x1b, 0xb9, 0x23, 0xa9, 0xa9, 0xcd, 0x64, 0xfb, 0x44, 0x02, 0xed,
0x21, 0xd9, 0xd6, 0x18, 0xe7, 0x98, 0xbf, 0x2e, 0xaf, 0x74, 0xc4, 0x67,
0x8b, 0xd4, 0x8f, 0x8d, 0x4d, 0x01, 0x34, 0xcb, 0xf0, 0x6b, 0x84, 0xf9,
0xb4, 0x67, 0xd0, 0x98, 0x8d, 0x9e, 0xc1, 0xff, 0x00, 0x38, 0x67, 0x79,
0xa9, 0xc7, 0xf9, 0xeb, 0xa6, 0x58, 0x4d, 0x3d, 0xdc, 0xb1, 0x3e, 0x95,
0xa8, 0xc7, 0x24, 0x21, 0x9d, 0xa3, 0x55, 0x48, 0x79, 0x82, 0xe2, 0xb4,
0x0b, 0x55, 0x14, 0x3e, 0x34, 0xcd, 0x67, 0xb4, 0xf0, 0x89, 0xd1, 0x12,
0x2b, 0x98, 0x72, 0xbb, 0x02, 0x52, 0x1a, 0xaa, 0x24, 0xf2, 0x2f, 0xd8,
0x7c, 0xf3, 0x47, 0xb9, 0x76, 0x2a, 0xff, 0x00, 0xff, 0xd0, 0x32, 0xfc,
0xc9, 0xd3, 0xe2, 0xbd, 0xff, 0x00, 0x9c, 0x83, 0xfc, 0xca, 0x79, 0x14,
0x1a, 0xeb, 0x4c, 0xbb, 0xfb, 0x22, 0x0c, 0xf5, 0x9d, 0x0c, 0xcc, 0x74,
0x18, 0xbf, 0xaa, 0xf9, 0xd6, 0xa2, 0x02, 0x5a, 0xcc, 0x9e, 0xff, 0x00,
0xd0, 0xfb, 0x1b, 0xf2, 0xa7, 0xc8, 0x56, 0x7a, 0xa4, 0x50, 0x21, 0x8d,
0x6a, 0xc0, 0x76, 0xce, 0x6b, 0xb4, 0x35, 0x66, 0x25, 0xe8, 0xb4, 0x7a,
0x70, 0x43, 0xd9, 0x35, 0x5f, 0xc8, 0x08, 0xb5, 0x69, 0x1e, 0x3b, 0xab,
0x88, 0xb4, 0x7d, 0x22, 0xdc, 0x17, 0xd4, 0x35, 0x49, 0x80, 0xa2, 0x22,
0xee, 0xdc, 0x41, 0x20, 0x13, 0x4e, 0xe4, 0xd0, 0x77, 0x3d, 0xb3, 0x5b,
0x8f, 0xb5, 0xcc, 0x39, 0x6e, 0x7a, 0x07, 0x36, 0x7d, 0x9e, 0x25, 0xcf,
0x60, 0xf9, 0xcf, 0xcf, 0x9f, 0x9d, 0x5a, 0x47, 0xe5, 0xb5, 0xe6, 0x85,
0xf9, 0x5f, 0xf9, 0x0d, 0x63, 0x1e, 0x87, 0xa4, 0xdf, 0xeb, 0x36, 0x50,
0xf9, 0xbb, 0xce, 0xcd, 0x1a, 0xb5, 0xfe, 0xa7, 0xca, 0x75, 0x8e, 0x45,
0x47, 0x65, 0xa8, 0x52, 0xa5, 0x87, 0x32, 0x2b, 0x43, 0x48, 0xc2, 0x0d,
0xdb, 0x75, 0xa4, 0xec, 0xc9, 0x6a, 0xa3, 0x2c, 0xfa, 0xb3, 0xc4, 0x44,
0x4f, 0x0c, 0x7a, 0x47, 0x6f, 0xc6, 0xdf, 0x3b, 0x75, 0x1a, 0xad, 0x78,
0xd3, 0x98, 0xe1, 0xd3, 0x8a, 0x04, 0x8b, 0x3d, 0x4e, 0xff, 0x00, 0x8d,
0xfe, 0x54, 0xf9, 0xa2, 0xd2, 0xfb, 0x5b, 0x93, 0xf3, 0x67, 0xcf, 0x37,
0xa9, 0xae, 0x6a, 0x11, 0xdd, 0x45, 0xe6, 0x8d, 0x50, 0xc1, 0x72, 0x97,
0x52, 0xac, 0x88, 0x12, 0xee, 0x55, 0x4e, 0x2c, 0x1a, 0xa3, 0x8a, 0x8a,
0x0a, 0x74, 0x19, 0xbc, 0x94, 0x60, 0x34, 0xb8, 0xc7, 0x08, 0xae, 0x08,
0xf4, 0x1d, 0xc1, 0xd4, 0xe2, 0x94, 0xce, 0xa2, 0x67, 0x88, 0xfd, 0x47,
0xaf, 0x9b, 0xf5, 0x1f, 0xf2, 0xee, 0xe7, 0xfe, 0x56, 0x3f, 0x95, 0xa3,
0xf2, 0xe7, 0x9e, 0xc0, 0xd6, 0x6e, 0x6d, 0x97, 0x96, 0x97, 0xae, 0xc8,
0x01, 0xb9, 0x43, 0x4f, 0xda, 0x7a, 0x54, 0xb6, 0xdd, 0x7f, 0x68, 0x6c,
0xd5, 0xeb, 0x9c, 0x1e, 0xb2, 0x3f, 0x96, 0xc9, 0xc7, 0x8b, 0x61, 0xd4,
0x74, 0x7b, 0x1d, 0x39, 0xf1, 0xa1, 0xc3, 0x93, 0x7f, 0x37, 0x82, 0xfe,
0x6f, 0xfe, 0x5b, 0xdb, 0xe8, 0x02, 0xe2, 0xdd, 0xe3, 0x5a, 0xaa, 0x96,
0x8d, 0xe9, 0x40, 0xcb, 0xd9, 0x87, 0xcf, 0x36, 0xbd, 0x9d, 0xad, 0x39,
0x37, 0x70, 0x35, 0xba, 0x61, 0x10, 0xf8, 0xd3, 0xf2, 0xdb, 0x4e, 0x8a,
0xcb, 0xf3, 0xe3, 0xc9, 0xae, 0x8a, 0x01, 0x57, 0xd4, 0x86, 0xde, 0xfa,
0x75, 0xd6, 0x74, 0xda, 0xf9, 0x99, 0x68, 0x67, 0xf0, 0xff, 0x00, 0x74,
0x1e, 0x73, 0x4f, 0x01, 0x1d, 0x64, 0x0f, 0xbf, 0xee, 0x2c, 0x4b, 0xf2,
0x8f, 0x43, 0x82, 0xe1, 0xad, 0xf9, 0xa8, 0x24, 0x91, 0x53, 0xf3, 0xcc,
0x9e, 0xd2, 0xca, 0x45, 0xb5, 0x76, 0x76, 0x21, 0xb3, 0xf4, 0xb7, 0xc8,
0x3f, 0x95, 0xd6, 0xba, 0xbe, 0x9e, 0xa5, 0x22, 0x0e, 0xc1, 0x2b, 0x40,
0x37, 0xd8, 0x67, 0x0f, 0xab, 0xd7, 0x98, 0x49, 0xeb, 0xf4, 0xfa, 0x51,
0x20, 0xd7, 0x9a, 0x3f, 0xe7, 0x1f, 0xfc, 0xad, 0x6f, 0x6f, 0x2e, 0xb1,
0xf9, 0x83, 0xe6, 0x58, 0x7c, 0xaf, 0xe5, 0xd8, 0x8f, 0xc6, 0x90, 0x81,
0x25, 0xd4, 0xc0, 0x75, 0x54, 0x14, 0x6a, 0x1a, 0x74, 0xe2, 0xae, 0x7f,
0xc9, 0xc7, 0x07, 0x6b, 0xe5, 0x27, 0x87, 0x0c, 0x78, 0xa5, 0xf6, 0x7e,
0x3e, 0x48, 0xcd, 0xd9, 0xf8, 0xea, 0xf2, 0x4a, 0x83, 0x01, 0xfc, 0xaf,
0xfc, 0xe3, 0xfc, 0xb8, 0xd1, 0x7f, 0x34, 0xb4, 0x5f, 0xca, 0x4f, 0xc9,
0x7f, 0xcb, 0xeb, 0x7d, 0x13, 0x42, 0xd6, 0xe2, 0xbd, 0x3e, 0x62, 0xf3,
0xae, 0xa0, 0xbc, 0xb5, 0x4b, 0xf6, 0xb5, 0xb5, 0x96, 0x64, 0x0a, 0x6a,
0xcc, 0x17, 0x92, 0x54, 0x7a, 0x8c, 0x40, 0x04, 0x85, 0x8d, 0x33, 0x33,
0xb4, 0x3b, 0x37, 0x51, 0x3d, 0x2c, 0xb5, 0x3a, 0x9c, 0x97, 0x28, 0xd5,
0x44, 0x7d, 0x22, 0xc8, 0x1f, 0x8a, 0xf9, 0x97, 0x0b, 0x4b, 0xae, 0xc3,
0x0c, 0xe3, 0x06, 0x08, 0x50, 0x37, 0x72, 0x3c, 0xcd, 0x0f, 0xc7, 0x3f,
0x90, 0x7d, 0x85, 0x9c, 0xc3, 0xb8, 0x76, 0x2a, 0xff, 0x00, 0xff, 0xd1,
0xf6, 0x17, 0x98, 0xbf, 0xe7, 0x12, 0x3f, 0x31, 0xf5, 0x8f, 0xcd, 0x4f,
0x3a, 0x79, 0xf2, 0xef, 0x5e, 0xf2, 0xe7, 0x97, 0xbc, 0xa7, 0xab, 0xea,
0x1f, 0x5d, 0x86, 0xee, 0xf2, 0xea, 0x56, 0x9d, 0x62, 0x60, 0xab, 0x56,
0x8d, 0x61, 0xe0, 0x0d, 0x47, 0x79, 0x07, 0x51, 0xbe, 0x77, 0x38, 0x3d,
0xa1, 0xd3, 0xc3, 0x4b, 0x0c, 0x22, 0x32, 0x94, 0xc0, 0xad, 0x80, 0xaf,
0xbf, 0xf4, 0x3c, 0x9c, 0xfb, 0x17, 0x34, 0xb5, 0x12, 0xca, 0x65, 0x11,
0x12, 0x6f, 0x9e, 0xff, 0x00, 0x77, 0xe9, 0x7b, 0x8f, 0x97, 0x75, 0xef,
0xc9, 0xcf, 0xca, 0x8b, 0x61, 0x6d, 0xfe, 0x34, 0x5f, 0x3f, 0x79, 0x82,
0x11, 0xc1, 0xa2, 0xd3, 0x8a, 0x35, 0xb2, 0xb0, 0xd8, 0xee, 0x8c, 0xf1,
0xad, 0x0e, 0xc7, 0x94, 0x8c, 0x7f, 0xc9, 0xcd, 0x56, 0x6c, 0x3a, 0xbd,
0x61, 0xbe, 0x0e, 0x08, 0xf9, 0xf3, 0xfd, 0x7f, 0x63, 0xb4, 0xc5, 0x93,
0x06, 0x9c, 0x57, 0x17, 0x11, 0xf2, 0x79, 0xd7, 0xe6, 0x97, 0xe7, 0xbc,
0xfe, 0x63, 0xb1, 0x9a, 0xd1, 0x26, 0x5b, 0x1d, 0x34, 0x8f, 0x87, 0x4f,
0x89, 0xbe, 0x13, 0x4e, 0x9e, 0xa1, 0xdb, 0x99, 0x1e, 0xfb, 0x78, 0x01,
0x99, 0x9a, 0x0e, 0xc9, 0x18, 0xa5, 0x7c, 0xcf, 0x7b, 0x8d, 0xab, 0xd7,
0xf1, 0x0a, 0xe8, 0xfc, 0xf6, 0xd4, 0xf5, 0xe8, 0xf5, 0x1f, 0xcc, 0x0f,
0x28, 0x44, 0x8d, 0xcb, 0xd4, 0xd7, 0xb4, 0xf1, 0x41, 0xe1, 0xf5, 0xa8,
0xf3, 0xb2, 0xc7, 0x84, 0xc7, 0x04, 0xcf, 0xf4, 0x4f, 0xdc, 0xf2, 0xb9,
0x73, 0x09, 0x66, 0x80, 0xfe, 0x90, 0xfb, 0xd1, 0x52, 0x6b, 0xd1, 0xe9,
0xff, 0x00, 0x9a, 0xbf, 0x98, 0x11, 0x3b, 0x05, 0x29, 0xe6, 0x8d, 0x5a,
0x95, 0xf0, 0xfa, 0xec, 0xb4, 0xc8, 0x8c, 0x3c, 0x5a, 0x5c, 0x67, 0xfa,
0x11, 0xfb, 0x82, 0x61, 0x98, 0x47, 0x51, 0x31, 0xfd, 0x23, 0xf7, 0xbe,
0xdc, 0xfc, 0xbf, 0xfc, 0xd5, 0x8b, 0x4b, 0xb4, 0x8f, 0x84, 0xe1, 0x48,
0x51, 0xdf, 0x39, 0x5d, 0x67, 0x67, 0x99, 0x97, 0xa5, 0xd3, 0x6b, 0x00,
0x0f, 0x4f, 0xbf, 0xfc, 0xde, 0xfc, 0xba, 0xf3, 0xdd, 0x81, 0xf2, 0xb7,
0xe6, 0x3d, 0xe1, 0xd1, 0x1d, 0x81, 0x5d, 0x23, 0xcd, 0xf0, 0xd0, 0x88,
0x19, 0xb6, 0x02, 0x7d, 0x8d, 0x17, 0xa5, 0x49, 0x1c, 0x4f, 0x7e, 0x27,
0xe2, 0xcc, 0x18, 0x76, 0x76, 0xa3, 0x4f, 0x2f, 0x13, 0x08, 0xbe, 0xf8,
0xfe, 0xa7, 0x2a, 0x7a, 0xdc, 0x39, 0x47, 0x06, 0x43, 0x5d, 0xc5, 0xe4,
0x1e, 0x59, 0xff, 0x00, 0x9c, 0x6b, 0xd4, 0xec, 0xff, 0x00, 0x32, 0xf4,
0x1f, 0x3e, 0xe8, 0x3f, 0x99, 0xbe, 0x4d, 0xf3, 0x57, 0x94, 0x74, 0xe6,
0xbb, 0x6f, 0x56, 0xd6, 0xf5, 0xfe, 0xb9, 0x28, 0xb8, 0xb4, 0x9a, 0x15,
0xe1, 0x0c, 0x51, 0xcd, 0x11, 0xe2, 0x65, 0x0c, 0x7f, 0x7d, 0xd2, 0xa7,
0x36, 0x5a, 0x8e, 0xdb, 0x8c, 0xb4, 0xd2, 0xc3, 0x3c, 0x53, 0x8c, 0xcd,
0x73, 0x1b, 0x6c, 0x41, 0xe7, 0xb1, 0xe9, 0xdc, 0xeb, 0x61, 0xd9, 0x52,
0x19, 0xe3, 0x96, 0x33, 0x8c, 0xa2, 0x2f, 0xae, 0xfb, 0x82, 0x3c, 0xc7,
0xda, 0x94, 0x79, 0x07, 0xf2, 0xe3, 0xfe, 0x71, 0xfb, 0xf2, 0x9d, 0x62,
0x6f, 0x3d, 0x7e, 0x79, 0xe9, 0xde, 0x76, 0xd6, 0x21, 0x00, 0x8d, 0x07,
0xca, 0xa4, 0x4d, 0x10, 0x91, 0x69, 0xfb, 0xb9, 0x25, 0x81, 0xae, 0x18,
0xff, 0x00, 0xb2, 0x31, 0x65, 0xba, 0xcd, 0x6e, 0xbb, 0x59, 0xfd, 0xd6,
0x03, 0x08, 0xf7, 0xcb, 0xf6, 0xd7, 0xe9, 0x63, 0xa4, 0xd2, 0xe9, 0x34,
0xa3, 0xf7, 0x99, 0x84, 0x8f, 0x74, 0x7f, 0x65, 0xfe, 0x87, 0xd1, 0x56,
0xdf, 0xf3, 0x91, 0x7e, 0x57, 0xb4, 0xb3, 0xfa, 0x8f, 0x92, 0x74, 0x28,
0xf4, 0x6d, 0x35, 0x07, 0x18, 0xa7, 0xb9, 0x2a, 0xd3, 0xb0, 0xec, 0x4a,
0x82, 0xc0, 0x1f, 0xf5, 0x9d, 0xf3, 0x4b, 0x2e, 0xc6, 0xc8, 0x4d, 0xe5,
0x95, 0x9f, 0xc7, 0xe3, 0xa3, 0xb6, 0x8f, 0x69, 0x42, 0xaa, 0x02, 0x83,
0xe6, 0x6f, 0xcd, 0x9f, 0xcd, 0x06, 0xd7, 0x84, 0xf3, 0xdd, 0xde, 0xb5,
0xcc, 0x85, 0x48, 0x0c, 0xec, 0x4d, 0x07, 0x80, 0xaf, 0x41, 0xed, 0x9b,
0xbe, 0xcf, 0xd0, 0x78, 0x7b, 0x00, 0xea, 0xf5, 0xba, 0xce, 0x21, 0xb9,
0x78, 0x6f, 0xfc, 0xe3, 0x3e, 0xa2, 0x9a, 0x8f, 0xfc, 0xe4, 0x97, 0x95,
0xd9, 0x4f, 0x21, 0x1d, 0xb6, 0xaa, 0x6b, 0xee, 0x6c, 0x66, 0x1f, 0xab,
0x36, 0xdd, 0xbb, 0x0e, 0x0e, 0xce, 0x9f, 0xbe, 0x3f, 0x78, 0x74, 0xfd,
0x97, 0x3e, 0x2d, 0x6c, 0x7d, 0xc7, 0xee, 0x7e, 0xbd, 0xe7, 0x9b, 0x3d,
0xab, 0xb1, 0x57, 0xff, 0xd2, 0x9e, 0x7f, 0xce, 0x41, 0x7e, 0x45, 0x7e,
0x74, 0xf9, 0x9f, 0xf3, 0x77, 0xce, 0x7e, 0x62, 0xf2, 0xef, 0x93, 0xaf,
0xf5, 0x6d, 0x02, 0xea, 0xea, 0x39, 0xb4, 0x9b, 0xb8, 0xae, 0x20, 0x28,
0x54, 0xdb, 0x42, 0x1c, 0xc7, 0x1b, 0x4c, 0x18, 0x55, 0xd4, 0xd4, 0x71,
0xeb, 0x9e, 0xa3, 0xd8, 0xdd, 0xaf, 0xa3, 0xc3, 0xa4, 0x84, 0x27, 0x30,
0x24, 0x06, 0xfb, 0x1e, 0xf3, 0xe4, 0xf9, 0xe7, 0x6a, 0x76, 0x76, 0xab,
0x2e, 0xa2, 0x53, 0x84, 0x49, 0x8f, 0x4d, 0xc7, 0x70, 0xf3, 0x60, 0xfa,
0x57, 0xe5, 0x57, 0xfc, 0xe4, 0x2e, 0x9c, 0x81, 0x1b, 0xf2, 0xdb, 0x59,
0x21, 0x7b, 0xa8, 0x8f, 0xf5, 0x7a, 0x99, 0x97, 0x93, 0xb4, 0x3b, 0x3e,
0x7f, 0xe5, 0x62, 0xd5, 0x8f, 0x4b, 0xad, 0x8f, 0xf9, 0x33, 0xf6, 0x7e,
0xb4, 0x4e, 0xa3, 0xf9, 0x65, 0xff, 0x00, 0x39, 0x0b, 0x7b, 0x11, 0x44,
0xfc, 0xb5, 0xd6, 0xb7, 0xda, 0xac, 0xb1, 0x8f, 0xf8, 0xdf, 0x23, 0x0d,
0x7e, 0x82, 0x27, 0xfb, 0xd8, 0xb2, 0x9e, 0x9b, 0x5b, 0x21, 0xfd, 0xd9,
0xfb, 0x3f, 0x5a, 0x07, 0xc9, 0x5f, 0xf3, 0x8e, 0xbf, 0x9e, 0x5f, 0xe3,
0x7f, 0x28, 0xeb, 0x1a, 0xb7, 0xe5, 0xfd, 0xfc, 0x3a, 0x7d, 0x9e, 0xb9,
0x61, 0x71, 0x7f, 0x3c, 0xd2, 0xdb, 0xa0, 0x8e, 0x08, 0xae, 0x63, 0x79,
0x18, 0xa9, 0x98, 0x35, 0x02, 0x82, 0x7a, 0x64, 0xf5, 0x5d, 0xb7, 0xa2,
0xf0, 0x67, 0x18, 0xe4, 0x16, 0x62, 0x6b, 0x9f, 0x77, 0xb9, 0xa7, 0x4f,
0xd9, 0x5a, 0xbf, 0x1a, 0x32, 0x94, 0x0d, 0x09, 0x0b, 0xdc, 0x77, 0xfb,
0xd1, 0x3f, 0x98, 0x3f, 0xf3, 0x8f, 0x1f, 0x9e, 0x33, 0xfe, 0x61, 0x79,
0xe7, 0x5e, 0xd2, 0x3c, 0x83, 0x7f, 0x73, 0xa7, 0x6a, 0x1e, 0x61, 0xd4,
0xee, 0xf4, 0xeb, 0x98, 0x65, 0xb6, 0x61, 0x2c, 0x13, 0xdd, 0xc9, 0x24,
0x4e, 0x10, 0x4d, 0xca, 0x8c, 0xac, 0x0e, 0xe3, 0x23, 0xa2, 0xed, 0xad,
0x10, 0xd3, 0xe3, 0x84, 0xb2, 0x0b, 0x11, 0x00, 0xf3, 0xe6, 0x00, 0xf2,
0x4e, 0xa7, 0xb2, 0xf5, 0x67, 0x34, 0xe7, 0x18, 0x1a, 0x32, 0x24, 0x6e,
0x3b, 0xfd, 0xea, 0x9a, 0x77, 0xe5, 0x8f, 0xfc, 0xe4, 0x2d, 0x8c, 0x41,
0x1b, 0xf2, 0xd7, 0x5a, 0xf8, 0x45, 0x2a, 0xab, 0x19, 0xff, 0x00, 0x8d,
0xf0, 0x4f, 0x5f, 0xd9, 0xf2, 0x3f, 0xde, 0xc5, 0xb6, 0x1a, 0x6d, 0x6c,
0x47, 0xf7, 0x67, 0xec, 0x50, 0xd5, 0x7f, 0x2a, 0xff, 0x00, 0xe7, 0x21,
0x75, 0x18, 0xca, 0x2f, 0xe5, 0xae, 0xb2, 0x03, 0x0e, 0xac, 0xb1, 0xff,
0x00, 0xcd, 0x79, 0x2c, 0x7d, 0xa1, 0xd9, 0xf0, 0xff, 0x00, 0x2b, 0x16,
0x39, 0x34, 0xba, 0xd9, 0x0f, 0xee, 0xcf, 0xd9, 0xfa, 0xd9, 0x97, 0xe4,
0x1f, 0xe4, 0x17, 0xe7, 0x17, 0x97, 0xff, 0x00, 0x36, 0xfc, 0xa7, 0xe6,
0x5f, 0x33, 0xf9, 0x22, 0xf3, 0x4e, 0xd1, 0xad, 0x7e, 0xbe, 0xd7, 0xb7,
0xd7, 0x12, 0xdb, 0xd1, 0x3d, 0x5b, 0x0b, 0x88, 0x93, 0x92, 0x89, 0x4b,
0xee, 0xee, 0xa3, 0xa7, 0x7c, 0xc5, 0xed, 0x8e, 0xd8, 0xd2, 0x65, 0xd2,
0xcf, 0x1e, 0x3c, 0x80, 0xc8, 0xd6, 0xdb, 0xf7, 0x8f, 0x26, 0xce, 0xcc,
0xec, 0xcd, 0x4e, 0x3d, 0x44, 0x67, 0x38, 0x50, 0xdf, 0xbb, 0xb8, 0xf9,
0xbc, 0x8a, 0x0f, 0xf9, 0xc7, 0x0f, 0xf9, 0xc8, 0x1d, 0x26, 0x45, 0xb8,
0x8f, 0xf2, 0xe7, 0x52, 0xad, 0x69, 0x48, 0xe4, 0xb6, 0x93, 0xef, 0x11,
0xcc, 0xc7, 0x36, 0x47, 0xb7, 0x34, 0x13, 0xdb, 0xc4, 0x1f, 0x6f, 0xea,
0x70, 0x63, 0xd9, 0x5a, 0xc8, 0x1b, 0x10, 0x3f, 0x31, 0xfa, 0xd9, 0xcd,
0x9f, 0xe5, 0xbf, 0xfc, 0xe4, 0x25, 0xac, 0x41, 0x1b, 0xf2, 0xd7, 0x5b,
0xa8, 0x14, 0xf8, 0x56, 0x33, 0xfa, 0x9f, 0x31, 0x25, 0xae, 0xd0, 0x48,
0xff, 0x00, 0x7b, 0x17, 0x36, 0x3a, 0x7d, 0x60, 0x1f, 0xdd, 0x9f, 0xb3,
0xf5, 0xa4, 0xfa, 0xc7, 0xe5, 0x17, 0xfc, 0xe4, 0x2e, 0xa8, 0x0a, 0x0f,
0xcb, 0x7d, 0x65, 0x43, 0x75, 0x62, 0x23, 0xff, 0x00, 0xaa, 0x99, 0x66,
0x2e, 0xd2, 0xec, 0xf8, 0x7f, 0x95, 0x8b, 0x56, 0x5d, 0x1e, 0xb6, 0x7f,
0xe4, 0xcf, 0xd8, 0xf6, 0x6f, 0xf9, 0xc5, 0x9f, 0xc8, 0xbf, 0xcd, 0x4f,
0x25, 0x7e, 0x6e, 0x69, 0xfe, 0x66, 0xf3, 0x8f, 0x93, 0x6e, 0x34, 0x7d,
0x26, 0xd7, 0x4e, 0xbe, 0x53, 0xa8, 0x4f, 0x35, 0xb3, 0x05, 0x96, 0x68,
0xfd, 0x34, 0x01, 0x63, 0x95, 0x9a, 0xa7, 0x91, 0x1d, 0x33, 0x59, 0xed,
0x07, 0x6b, 0xe9, 0x75, 0x1a, 0x43, 0x8f, 0x14, 0xec, 0x92, 0x36, 0xa3,
0xfa, 0x9c, 0xce, 0xc6, 0xec, 0xdd, 0x46, 0x1d, 0x47, 0x1e, 0x48, 0xd0,
0xa3, 0xdd, 0xfa, 0xdf, 0xa7, 0xb9, 0xc1, 0x3d, 0x73, 0xb1, 0x57, 0xff,
0xd3, 0xf4, 0xd7, 0xe6, 0x77, 0xfc, 0xe5, 0x2f, 0xe7, 0x5f, 0x92, 0xef,
0xff, 0x00, 0x3d, 0x7c, 0xc5, 0xe5, 0xdf, 0xcb, 0x8f, 0x28, 0xf9, 0x93,
0xf2, 0xdf, 0xf2, 0x2f, 0xcc, 0x3a, 0x77, 0x96, 0xf5, 0x6b, 0x7b, 0xad,
0x5a, 0xf6, 0xcb, 0x5c, 0xbe, 0x9f, 0x55, 0xb4, 0xd3, 0xe5, 0x8a, 0x78,
0x38, 0xdb, 0x4d, 0x6c, 0xa9, 0x04, 0x9a, 0x84, 0x7e, 0xa0, 0x63, 0x57,
0x4e, 0x5c, 0x4a, 0x95, 0xf8, 0xf2, 0x0c, 0xc8, 0xbf, 0x27, 0x12, 0x30,
0x06, 0xbb, 0xcb, 0xdc, 0x7f, 0x27, 0x3f, 0x33, 0xbf, 0x34, 0x35, 0x9f,
0xcc, 0x1f, 0xcc, 0x6f, 0xca, 0x7f, 0xce, 0x1d, 0x0f, 0xcb, 0x1a, 0x7f,
0x9b, 0xbc, 0x95, 0xa5, 0xe8, 0x7a, 0xfe, 0x9f, 0xab, 0x79, 0x46, 0xe2,
0xf2, 0x6d, 0x3a, 0xf7, 0x4f, 0xd6, 0xcd, 0xe4, 0x41, 0x4a, 0x5f, 0x46,
0x92, 0xc7, 0x24, 0x12, 0xd9, 0x3a, 0x92, 0x4d, 0x1c, 0x30, 0x20, 0x2d,
0x37, 0x94, 0x49, 0xba, 0x2c, 0x65, 0x11, 0x56, 0x19, 0x6f, 0xe7, 0xb7,
0xe6, 0x95, 0xff, 0x00, 0xe5, 0x2f, 0x91, 0xed, 0xf5, 0xcd, 0x13, 0xcb,
0xf1, 0xf9, 0xa3, 0xcd, 0x3e, 0x62, 0xd7, 0xb4, 0x7f, 0x2a, 0x79, 0x37,
0x43, 0xb8, 0xb9, 0x16, 0x76, 0xb3, 0x6a, 0xda, 0xed, 0xe4, 0x76, 0x56,
0x9f, 0x5a, 0xb9, 0x2a, 0xe6, 0x28, 0x51, 0xe4, 0xe4, 0xe4, 0x29, 0x34,
0x14, 0xda, 0xb5, 0x06, 0x46, 0x82, 0x23, 0x1b, 0x2c, 0x1f, 0xf2, 0xc7,
0xf3, 0x5b, 0xf3, 0x4f, 0xfe, 0x56, 0xc6, 0xa5, 0xf9, 0x27, 0xf9, 0xd7,
0xe5, 0xff, 0x00, 0x2c, 0x59, 0xf9, 0xb6, 0x4f, 0x2a, 0x9f, 0x3a, 0x79,
0x5f, 0xcc, 0x5e, 0x4d, 0xba, 0xbb, 0x9b, 0x4c, 0xbb, 0xd3, 0x21, 0xbc,
0x8b, 0x4f, 0xbb, 0x82, 0x78, 0x2f, 0xd1, 0x67, 0x86, 0x68, 0x67, 0x9a,
0x3a, 0x1a, 0xb2, 0xc8, 0xad, 0x51, 0xc4, 0xa9, 0x18, 0x01, 0x37, 0x45,
0x32, 0x88, 0xab, 0x0c, 0xff, 0x00, 0xf3, 0xd7, 0xf3, 0x4c, 0xfe, 0x4d,
0x7e, 0x59, 0xeb, 0x7e, 0x79, 0x83, 0x44, 0x3e, 0x64, 0xd5, 0x60, 0xb9,
0xd3, 0xf4, 0xbf, 0x2f, 0x68, 0x1e, 0xb0, 0xb6, 0x4b, 0xbd, 0x4b, 0x57,
0xbd, 0x87, 0x4f, 0xb3, 0x8a, 0x5b, 0x86, 0x56, 0x58, 0x63, 0xf5, 0xa7,
0x52, 0xee, 0x46, 0xca, 0x0d, 0x2a, 0x68, 0x09, 0x91, 0xa0, 0x88, 0xc7,
0x88, 0xd2, 0x51, 0xf9, 0x5d, 0xae, 0x7f, 0xce, 0x42, 0x49, 0xe6, 0x2d,
0x5f, 0x40, 0xfc, 0xe8, 0xf2, 0x3f, 0x95, 0xad, 0x74, 0xc4, 0xd3, 0xa1,
0xd4, 0x34, 0x1f, 0x3e, 0xf9, 0x33, 0x51, 0x96, 0x5d, 0x3d, 0xe7, 0x69,
0x0c, 0x73, 0x69, 0x97, 0x36, 0x7a, 0x81, 0x4b, 0xc5, 0x9d, 0x05, 0x24,
0x59, 0x55, 0x0c, 0x2c, 0x9b, 0x72, 0x57, 0x1c, 0x4a, 0x2f, 0xaa, 0xc8,
0x47, 0xa2, 0x6b, 0xf9, 0xed, 0xf9, 0xa3, 0x73, 0xf9, 0x41, 0xf9, 0x6f,
0xa9, 0x79, 0xc3, 0x4d, 0xd0, 0x97, 0xcc, 0xda, 0xec, 0x97, 0xfa, 0x5e,
0x89, 0xe5, 0xad, 0x0a, 0x4b, 0x81, 0x69, 0x0d, 0xce, 0xa7, 0xad, 0x5f,
0x41, 0xa7, 0x59, 0xac, 0xf7, 0x0c, 0x18, 0x47, 0x12, 0xcb, 0x70, 0xac,
0xed, 0x4f, 0xb2, 0x0d, 0x37, 0xc6, 0x46, 0x82, 0xc6, 0x36, 0x69, 0xe5,
0x1e, 0x4c, 0xfc, 0xe0, 0xfc, 0xea, 0xb4, 0xfc, 0xf6, 0xf2, 0xe7, 0xe4,
0x7f, 0xe6, 0xd7, 0x94, 0x3c, 0x9f, 0x69, 0x36, 0xbb, 0xe4, 0xcd, 0x4b,
0xcd, 0x90, 0x79, 0xb7, 0xca, 0x7a, 0x8d, 0xed, 0xcd, 0xbc, 0xad, 0x65,
0x79, 0x6f, 0x6d, 0xf5, 0x71, 0x6d, 0x7b, 0x04, 0x32, 0xc4, 0x53, 0xd6,
0xf8, 0x89, 0x2c, 0x1b, 0xe1, 0x2a, 0x47, 0xc4, 0x8a, 0x04, 0x8d, 0xd1,
0x64, 0x62, 0x2a, 0xc3, 0xd6, 0x3f, 0x3f, 0xff, 0x00, 0x32, 0xef, 0x7f,
0x27, 0x3f, 0x26, 0x7f, 0x31, 0x3f, 0x33, 0xf4, 0xdd, 0x32, 0x0d, 0x66,
0xfb, 0xc9, 0x5a, 0x4c, 0x9a, 0x8d, 0xb6, 0x97, 0x72, 0xed, 0x1c, 0x53,
0xb2, 0x32, 0xaf, 0x07, 0x74, 0xf8, 0x80, 0xf8, 0xbb, 0x61, 0x91, 0xa1,
0x6c, 0x60, 0x2c, 0xd3, 0xce, 0x7f, 0x2b, 0x3f, 0x38, 0x7f, 0x34, 0x75,
0x5f, 0xcd, 0x57, 0xfc, 0xb0, 0xfc, 0xd8, 0xf2, 0x9f, 0x96, 0xf4, 0x2b,
0xdf, 0x30, 0xf9, 0x25, 0x3f, 0x30, 0x3c, 0x97, 0x75, 0xe5, 0x9b, 0xeb,
0xbb, 0xd8, 0xe2, 0xb0, 0x4b, 0xc8, 0xac, 0xae, 0xb4, 0xfb, 0xe7, 0xba,
0x86, 0x1e, 0x77, 0x10, 0x3d, 0xcc, 0x27, 0xd4, 0x8d, 0x55, 0x1c, 0x36,
0xcb, 0xb1, 0xa0, 0x8c, 0x8d, 0xd1, 0x65, 0x28, 0x8a, 0xb0, 0xf4, 0xdf,
0xcf, 0x3f, 0xcd, 0x38, 0x3f, 0x25, 0x7f, 0x2a, 0x7c, 0xdf, 0xf9, 0x97,
0x36, 0x8f, 0x27, 0x98, 0x64, 0xf2, 0xe4, 0x16, 0xeb, 0xa7, 0xe8, 0x51,
0x4a, 0xb0, 0x35, 0xe5, 0xed, 0xf5, 0xd4, 0x36, 0x36, 0x70, 0x19, 0x98,
0x30, 0x8d, 0x5e, 0xe2, 0xe1, 0x03, 0x39, 0x07, 0x8a, 0xd5, 0xa8, 0x69,
0x4c, 0x32, 0x34, 0x2d, 0x8c, 0x63, 0xc4, 0x69, 0xe2, 0x1a, 0x77, 0xe6,
0x37, 0xe7, 0x69, 0xfc, 0xca, 0xf2, 0x27, 0xe4, 0x8f, 0xe7, 0x77, 0x92,
0xfc, 0x91, 0x15, 0xb7, 0xe6, 0xbf, 0x96, 0xfc, 0xcb, 0xa8, 0x36, 0xbf,
0xe5, 0x5d, 0x42, 0xf6, 0xee, 0x38, 0xff, 0x00, 0x45, 0x47, 0x68, 0x24,
0xb4, 0x6b, 0x4b, 0xfb, 0x78, 0xc8, 0x64, 0xfa, 0xd8, 0xac, 0x85, 0x99,
0x64, 0xa8, 0xe2, 0xa9, 0xc5, 0x81, 0x8d, 0x9b, 0xa2, 0xca, 0x85, 0x58,
0xe8, 0xf6, 0x7f, 0x24, 0x7e, 0x4f, 0x58, 0x79, 0x17, 0xce, 0x5a, 0xf7,
0x9b, 0x6c, 0x3c, 0xd5, 0xae, 0xdf, 0xc1, 0xad, 0xd8, 0xc1, 0x63, 0x17,
0x95, 0x6f, 0x2e, 0x15, 0xf4, 0xbb, 0x11, 0x04, 0x70, 0x44, 0x1e, 0xce,
0x05, 0x45, 0xf4, 0x8b, 0x25, 0xba, 0x02, 0x01, 0xe3, 0xd4, 0x80, 0x09,
0x39, 0x21, 0x1a, 0x2c, 0x4c, 0xac, 0x53, 0xd8, 0x72, 0x4c, 0x5f, 0xff,
0xd4, 0xfa, 0x69, 0xae, 0x7e, 0x40, 0xfe, 0x5d, 0xf9, 0x87, 0x47, 0xfc,
0xd3, 0xd0, 0xf5, 0x2b, 0x5b, 0xe7, 0xb0, 0xfc, 0xe2, 0xd6, 0x2c, 0xf5,
0xcf, 0x3a, 0xac, 0x77, 0x4c, 0x8d, 0x25, 0xdd, 0x8c, 0x76, 0x51, 0x42,
0x61, 0x60, 0x3f, 0x76, 0xa1, 0x6c, 0x22, 0xa8, 0x1d, 0x68, 0x7c, 0x73,
0x2f, 0x84, 0x7c, 0xdc, 0x11, 0x32, 0x2b, 0xc9, 0x9a, 0xd8, 0xf9, 0x07,
0xcb, 0xba, 0x77, 0x9f, 0xbc, 0xc3, 0xf9, 0x95, 0x6d, 0x14, 0xe3, 0xcd,
0x1e, 0x67, 0xd1, 0xf4, 0xed, 0x0f, 0x55, 0x99, 0xa5, 0x26, 0x16, 0xb4,
0xd2, 0xa5, 0xb9, 0x9a, 0xd8, 0x24, 0x5d, 0x15, 0x83, 0x5d, 0xc9, 0x53,
0xdf, 0x6f, 0x0c, 0x35, 0xbd, 0xa2, 0xf6, 0xa5, 0x9f, 0x98, 0xdf, 0x97,
0x5e, 0x52, 0xfc, 0xd6, 0xf2, 0x7e, 0xad, 0xe4, 0x5f, 0x3b, 0x69, 0xa7,
0x53, 0xf2, 0xfe, 0xb0, 0x22, 0x33, 0xc5, 0x1c, 0xb2, 0x5b, 0xcd, 0x14,
0xd0, 0x48, 0xb3, 0x41, 0x71, 0x6f, 0x3c, 0x4c, 0xb2, 0x45, 0x2c, 0x32,
0xa2, 0xba, 0x3a, 0x90, 0x41, 0x18, 0x91, 0x61, 0x41, 0x20, 0xd8, 0x61,
0x9f, 0x95, 0xff, 0x00, 0x90, 0xfe, 0x4e, 0xfc, 0xac, 0xd5, 0xf5, 0xcf,
0x33, 0xd8, 0xea, 0x9e, 0x63, 0xf3, 0x8f, 0x9c, 0xfc, 0xc5, 0x6d, 0x0d,
0x86, 0xa9, 0xe7, 0x7f, 0x38, 0x6a, 0xf7, 0x1a, 0xd6, 0xaa, 0xd6, 0x16,
0xce, 0xf2, 0x41, 0x65, 0x1c, 0xf3, 0x9a, 0x45, 0x04, 0x6c, 0xec, 0xdc,
0x11, 0x47, 0x26, 0xf8, 0x9f, 0x93, 0x6f, 0x80, 0x46, 0x93, 0x29, 0x12,
0xcf, 0x3c, 0xfb, 0xe4, 0x4f, 0x2a, 0xfe, 0x66, 0xf9, 0x3f, 0x5e, 0xf2,
0x1f, 0x9d, 0xb4, 0xa4, 0xd6, 0xbc, 0xaf, 0xe6, 0x5b, 0x7f, 0xab, 0x6a,
0xda, 0x73, 0x3b, 0xc6, 0x59, 0x43, 0x2c, 0x88, 0xe9, 0x24, 0x6c, 0xae,
0x8f, 0x1b, 0xa2, 0xba, 0x3a, 0x90, 0xca, 0xc0, 0x30, 0x20, 0x8c, 0x24,
0x5a, 0x01, 0xa3, 0x61, 0xe6, 0xdf, 0x95, 0x3f, 0xf3, 0x8e, 0xbe, 0x40,
0xfc, 0xa4, 0xf3, 0x06, 0xbf, 0xe7, 0x1d, 0x2a, 0xef, 0xcc, 0x1e, 0x6d,
0xf3, 0xcf, 0x99, 0x6d, 0x63, 0xd3, 0xf5, 0x4f, 0x3c, 0xf9, 0xbb, 0x56,
0xb8, 0xd6, 0xb5, 0x63, 0xa7, 0xc2, 0xfe, 0xa4, 0x56, 0x31, 0xdc, 0x5c,
0x1f, 0xdd, 0xc2, 0xac, 0x01, 0xe2, 0xa0, 0x72, 0x21, 0x4b, 0x96, 0x2a,
0x08, 0x02, 0x20, 0x32, 0x94, 0xc9, 0x7a, 0x2f, 0xe6, 0x0f, 0xe5, 0xff,
0x00, 0x94, 0xbf, 0x34, 0xbc, 0x9f, 0xad, 0xf9, 0x0f, 0xcf, 0x3a, 0x42,
0x6b, 0x7e, 0x59, 0xf3, 0x04, 0x2b, 0x16, 0xa1, 0x62, 0xcc, 0xd1, 0xb0,
0x31, 0xba, 0xcb, 0x14, 0xb1, 0x4b, 0x19, 0x57, 0x8e, 0x48, 0xa4, 0x45,
0x74, 0x75, 0x21, 0x95, 0x80, 0x60, 0x6a, 0x30, 0x91, 0x6c, 0x41, 0xa3,
0x61, 0xe5, 0x7e, 0x43, 0xff, 0x00, 0x9c, 0x65, 0xfc, 0xbc, 0xf2, 0x07,
0x9f, 0x2c, 0xff, 0x00, 0x33, 0xed, 0x35, 0x4f, 0x35, 0xf9, 0x9f, 0xcf,
0xd6, 0xba, 0x24, 0xfe, 0x5d, 0x6f, 0x33, 0xf9, 0xa3, 0x5e, 0xbd, 0xd6,
0x6e, 0x25, 0xd3, 0xa6, 0x96, 0x39, 0x84, 0x2d, 0xf5, 0xa7, 0x65, 0x51,
0x19, 0x88, 0x04, 0x08, 0x14, 0x7d, 0xa6, 0x60, 0xce, 0xcc, 0xc4, 0x08,
0x00, 0x6d, 0x91, 0x99, 0x22, 0x9e, 0xa3, 0xf9, 0x8d, 0xe4, 0x0f, 0x2e,
0xfe, 0x69, 0xf9, 0x1f, 0xcc, 0xbf, 0x97, 0x9e, 0x6d, 0x8a, 0x79, 0xfc,
0xb7, 0xe6, 0xcb, 0x36, 0xb0, 0xd6, 0x22, 0xb6, 0x94, 0xc1, 0x2b, 0x42,
0xe4, 0x12, 0x12, 0x45, 0xa9, 0x53, 0x50, 0x37, 0xc2, 0x45, 0x8a, 0x62,
0x0d, 0x1b, 0x43, 0xc1, 0xf9, 0x6d, 0xe5, 0x8b, 0x7f, 0x3d, 0x68, 0xff,
0x00, 0x98, 0xb1, 0xc3, 0x70, 0x3c, 0xcb, 0xa1, 0x79, 0x5a, 0xe3, 0xc9,
0xda, 0x7c, 0xa6, 0x62, 0x61, 0x1a, 0x5d, 0xcd, 0xd5, 0xb5, 0xdc, 0x8a,
0xd1, 0xf4, 0x2f, 0xea, 0x5a, 0x47, 0x46, 0xeb, 0x4a, 0x8e, 0xf8, 0xd6,
0xf6, 0xbc, 0x5b, 0x52, 0x6d, 0xe7, 0x4f, 0x26, 0x79, 0x67, 0xf3, 0x13,
0xca, 0x9a, 0xff, 0x00, 0x91, 0xfc, 0xe5, 0xa4, 0xc5, 0xae, 0x79, 0x5f,
0xcc, 0xf6, 0x72, 0x58, 0x6b, 0x7a, 0x54, 0xc5, 0x95, 0x66, 0x82, 0x51,
0x42, 0x03, 0xc6, 0x55, 0xd1, 0x81, 0xa1, 0x56, 0x52, 0x19, 0x58, 0x06,
0x52, 0x08, 0x07, 0x12, 0x2d, 0x41, 0xad, 0xde, 0x35, 0xe4, 0x4f, 0xf9,
0xc5, 0xff, 0x00, 0xcb, 0xbf, 0x21, 0x79, 0xc3, 0xcb, 0x9e, 0x7f, 0xb5,
0xd5, 0xfc, 0xdd, 0xe6, 0x7f, 0x37, 0xf9, 0x57, 0x4e, 0xbe, 0xd1, 0xb4,
0x5d, 0x6f, 0xcc, 0xfe, 0x60, 0xbd, 0xd5, 0xde, 0x1d, 0x32, 0xf7, 0x87,
0xfa, 0x1a, 0xa5, 0xcb, 0xb4, 0x6b, 0x1c, 0x21, 0x29, 0x1f, 0x15, 0x0d,
0xb9, 0x2e, 0xce, 0xdb, 0xe4, 0x44, 0x00, 0xdd, 0x91, 0x99, 0x22, 0x9f,
0x46, 0xe4, 0xd8, 0x3b, 0x15, 0x7f, 0xff, 0xd5, 0xfb, 0x3d, 0x99, 0xae,
0xbd, 0xd8, 0xab, 0xb1, 0x57, 0x62, 0xae, 0xc5, 0x5d, 0x8a, 0xbb, 0x15,
0x76, 0x2a, 0xec, 0x55, 0xd8, 0xab, 0xb1, 0x57, 0x62, 0xae, 0xc5, 0x5d,
0x8a, 0xbf, 0xff, 0xd9 };

const sbyte* gComplexFile = (sbyte *)
    "<html><head><title>MOCANA</title></head><body>"
    "<TABLE id=\"Table1\" cellSpacing=\"1\" cellPadding=\"1\" width=\"229\" border=\"1\" height=395>"
    "<TR><TD width=100><IMG height=49 width=105 src=\"mocananew1.jpg\" />"
    "<TD><IMG height=49 width=105 src=\"mocananew2.jpg\" /></TR>"
    "<TR><TD width=100><IMG height=49 width=105 src=\"mocananew3.jpg\" />"
    "<TD><IMG height=49 width=105 src=\"mocananew4.jpg\" /></TR>"
    "<TR><TD width=100><IMG height=49 width=105 src=\"mocananew5.jpg\" />"
    "<TD><IMG height=49 width=105 src=\"mocananew6.jpg\" /></TR>"
    "<TR><TD width=100><IMG height=49 width=105 src=\"mocananew7.jpg\" />"
    "<TD><IMG height=49 width=105 src=\"mocananew8.jpg\" /></TR>"
    "<TR><TD width=100><IMG height=49 width=105 src=\"mocananew9.jpg\" />"
    "<TD><IMG height=49 width=105 src=\"mocananewa.jpg\" /></TR>"
    "<TR><TD width=100><IMG height=49 width=105 src=\"mocananewb.jpg\" />"
    "<TD><IMG height=49 width=105 src=\"mocananewc.jpg\" /></TR>"
    "<TR><TD width=100><IMG height=49 width=105 src=\"mocananewd.jpg\" />"
    "<TD><IMG height=49 width=105 src=\"mocananewe.jpg\" /></TR>"
    "<TR><TD width=100><IMG height=49 width=105 src=\"mocananewf.jpg\" />"
    "<TD><IMG height=49 width=105 src=\"mocananewg.jpg\" /></TR>"
    "<TR><TD width=100><IMG height=49 width=105 src=\"mocananewh.jpg\" />"
    "<TD><IMG height=49 width=105 src=\"mocananewi.jpg\" /></TR>"
    "<TR><TD width=100><IMG height=49 width=105 src=\"mocananewj.jpg\" />"
    "<TD><IMG height=49 width=105 src=\"mocananewk.jpg\" /></TR>"
    "<TR><TD width=100><IMG height=49 width=105 src=\"mocananewl.jpg\" />"
    "<TD><IMG height=49 width=105 src=\"mocananewm.jpg\" /></TR>"
    "<TR><TD width=100><IMG height=49 width=105 src=\"mocananewn.jpg\" />"
    "<TD><IMG height=49 width=105 src=\"mocananewo.jpg\" /></TR>"
    "<TR><TD width=100><IMG height=49 width=105 src=\"mocananewp.jpg\" />"
    "<TD><IMG height=49 width=105 src=\"mocananewq.jpg\" /></TR>"
    "<TR><TD width=100><IMG height=49 width=105 src=\"mocananewr.jpg\" />"
    "<TD><IMG height=49 width=105 src=\"mocananews.jpg\" /></TR>"
    "<TR><TD width=100><IMG height=49 width=105 src=\"mocananewt.jpg\" />"
    "<TD><IMG height=49 width=105 src=\"mocananewu.jpg\" /></TR>"
    "<TR><TD width=100><IMG height=49 width=105 src=\"mocananewv.jpg\" />"
    "<TD><IMG height=49 width=105 src=\"mocananeww.jpg\" /></TR>"
    "<TR><TD width=100><IMG height=49 width=105 src=\"mocananewx.jpg\" />"
    "<TD><IMG height=49 width=105 src=\"mocananewy.jpg\" /></TR>"
    "<TR><TD width=100><IMG height=49 width=105 src=\"mocananewz.jpg\" />"
    "<TD><IMG height=49 width=105 src=\"mocananew10.jpg\" /></TR>"
    "<TR><TD width=100><IMG height=49 width=105 src=\"mocananew11.jpg\" />"
    "<TD><IMG height=49 width=105 src=\"mocananew12.jpg\" /></TR>"
    "<TR><TD width=100><IMG height=49 width=105 src=\"mocananew13.jpg\" />"
    "<TD><IMG height=49 width=105 src=\"mocananew14.jpg\" /></TR>"
    "<TR><TD width=100><IMG height=49 width=105 src=\"mocananew15.jpg\" />"
    "<TD><IMG height=49 width=105 src=\"mocananew16.jpg\" /></TR>"
    "</TABLE></body></html>";

/*------------------------------------------------------------------*/

#if defined(__ENABLE_DIGICERT_TLS13_PSK__)

static tls13PSK externalPsk = {
    .isExternal = 1,
    .isPSKavailable = 1,
    .pskTLS13LifetimeHint = 0,
    .pskTLS13AgeAdd = 0,
    .pskTLS13 = {
        0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c,
        0x20, 0x70, 0x73, 0x6b
    },
    .pskTLS13Length = 12,
    .pskTLS13Identity = (ubyte *) "External TLS 1.3 PSK",
    .pskTLS13IdentityLength = 20,
    .obfuscatedTicketAge = 0,
    .hashAlgo = TLS_SHA256,
    .startTime = { 0 },
    .maxEarlyDataSize = 10000,
    .pSelectedTlsVersion = (SSL3_MAJORVERSION << 8) | TLS13_MINORVERSION,
    .selectedCipherSuiteId = 0x1301
};

#endif /* __ENABLE_DIGICERT_TLS13_PSK__ */

/*------------------------------------------------------------------*/

#if defined(WIN32)

#define WIN32_LEAN_AND_MEAN
#define _WIN32_WINNT 0x0400
#include <windows.h>

#if defined(_DEBUG)
#include <crtdbg.h>
#endif

/*------------------------------------------------------------------*/

static BOOL WINAPI HandlerRoutine(DWORD dw)
{
    MOC_UNUSED(dw);

    TCP_CLOSE_SOCKET(mListenSocket);
    return TRUE;
}
#endif

/*------------------------------------------------------------------*/

#ifdef __ENABLE_DIGICERT_SSL_ALERTS__

sbyte4
myAlertCallback(sbyte4 connectionInstance, sbyte4 alertId, sbyte4 alertClass)
{
    MOC_UNUSED(connectionInstance);


    DEBUG_ERROR(DEBUG_SSL_EXAMPLE, (sbyte *)"SSL_EXAMPLE: AlertId: ", alertId);
    DEBUG_ERROR(DEBUG_SSL_EXAMPLE, (sbyte *)"SSL_EXAMPLE: AlertClass: ", alertClass);

    return 0;
}

#endif

#ifdef __ENABLE_DIGICERT_TAP__
static TAP_Context *g_pTapContext;
typedef struct tapContextHandle
{
    TAP_Context           *pTapCtx;
} tapContextHandle;

static hashTableOfPtrs *g_pTapCtxHashTable = NULL;
static tapContextHandle *g_pTapCtxList;

static MSTATUS
SSL_EXAMPLE_allocHashPtrElement(void *pHashCookie, hashTablePtrElement **ppRetNewHashElement)
{
    MSTATUS status = OK;

    if (NULL == (*ppRetNewHashElement = (hashTablePtrElement*) MALLOC(sizeof(hashTablePtrElement))))
        status = ERR_MEM_ALLOC_FAIL;

    return status;
}

/*---------------------------------------------------------------------------*/

static MSTATUS
SSL_EXAMPLE_freeHashPtrElement(void *pHashCookie, hashTablePtrElement *pFreeHashElement)
{
    MSTATUS status = OK;
    struct tapContextHandle *pTempCtx = NULL;
    TAP_ErrorContext *pErrContext = NULL;
    if (NULL == pFreeHashElement)
        return ERR_NULL_POINTER;

    pTempCtx = (struct tapContextHandle *)pFreeHashElement->pAppData;

    if (OK > (status = TAP_uninitContext((TAP_Context **)&(pTempCtx->pTapCtx), pErrContext)))
        goto exit;

    FREE(pTempCtx);
    FREE(pFreeHashElement);

exit:
    return status;
}

static sbyte4 SSL_EXAMPLE_addTAPContext(TAP_Context *pTapCtx, void *pKey)
{
    MSTATUS status = OK;
    struct tapContextHandle *pTempCtx = NULL;
    sbyte4 cmpResult = -1;
    intBoolean ctxFound = FALSE;

    ubyte4 hashValue = 0;

    HASH_VALUE_hashGen(pKey, sizeof(MocAsymKey), INIT_HASH, &hashValue);

    if (OK > (status = HASH_TABLE_findPtr(g_pTapCtxHashTable, hashValue, NULL, NULL, (void **)&pTempCtx, &ctxFound)))
    {
        goto exit;
    }

    if (FALSE == ctxFound)
    {
        if (OK > (status = DIGI_MALLOC((void **)&pTempCtx, sizeof(struct tapContextHandle))))
            goto exit;

        pTempCtx->pTapCtx = pTapCtx;

        if (OK > (status = HASH_TABLE_addPtr(g_pTapCtxHashTable, hashValue, (void *)pTempCtx)))
        {
            goto exit;
        }
    }

exit:
    if (OK > status)
    {
        if (pTempCtx != NULL)
            DIGI_FREE((void **)&pTempCtx);

#ifdef __ENABLE_DIGICERT_DEBUG_CONSOLE__
        DEBUG_ERROR(DEBUG_SSL_TRANSPORT, (sbyte*)"SSL_EXAMPLE_addTAPContext() returns status = ", status);
#endif
    }
    return status;
}

static sbyte4 SSL_EXAMPLE_findTAPContext(void *pKey, TAP_Context **ppTapCtx)
{
    ubyte4 hashValue = 0;
    struct tapContextHandle *pTempCtx = NULL;
    MSTATUS status = ERR_SSL;
    intBoolean ctxFound = FALSE;

    HASH_VALUE_hashGen(pKey, sizeof(MocAsymKey), INIT_HASH, &hashValue);

    if (OK > (status = HASH_TABLE_findPtr(g_pTapCtxHashTable, hashValue, NULL, NULL, (void **)&pTempCtx, &ctxFound)))
    {
        goto exit;
    }

    if (TRUE == ctxFound)
    {
        *ppTapCtx = pTempCtx->pTapCtx;
    }
exit:
    return status;
}

static sbyte4 SSL_EXAMPLE_clearTAPContext()
{
    struct tapContextHandle *pCurrCtx = NULL;
    TAP_ErrorContext *pErrContext = NULL;
    void *pRetHashCookie = NULL;
    MSTATUS status = OK;

    if (NULL != g_pTapCtxHashTable)
    {
        (void) HASH_TABLE_removePtrsTable(g_pTapCtxHashTable, &pRetHashCookie);
        g_pTapCtxHashTable = NULL;
    }
    return status;
}

static sbyte4 SSL_EXAMPLE_getTapContext(TAP_Context **ppTapContext,
                          TAP_EntityCredentialList **ppTapEntityCred,
                          TAP_CredentialList **ppTapKeyCred,
                          void *pKey, TapOperation op, ubyte getContext)
{
    MSTATUS status = OK;
    TAP_ErrorContext *pErrContext = NULL;
    TAP_Module *pModule = NULL;
    TAP_Context *pTempTAPCtx = NULL;
    int remain = 10, count = 0;
    if (pKey == NULL)
    {
        status = ERR_NULL_POINTER;
        goto exit;
    }

    if (NULL == g_pTapCtxHashTable)
    {
        while (remain > 0)
        {
            remain = remain >> 1;
            count++;
        }
        if (OK > (status = HASH_TABLE_createPtrsTable(&g_pTapCtxHashTable, (1 << count) - 1, NULL, SSL_EXAMPLE_allocHashPtrElement, SSL_EXAMPLE_freeHashPtrElement)))
            goto exit;
    }

    if (getContext)
    {
        if (ssls_TapProvider == TAP_PROVIDER_PKCS11)
        {
            int i = 0;
            for (i = 0; i < g_moduleList.numModules; i++)
            {
                /* moduleId:0 is for software */
                if (0 != g_moduleList.pModuleList[i].moduleId)
                {
                    pModule = &g_moduleList.pModuleList[i];
                    break;
                }
            }
        }
        else
        {
            pModule = &g_moduleList.pModuleList[0];
        }

        if (OK > (status = SSL_EXAMPLE_findTAPContext(pKey, &pTempTAPCtx)))
        {
            /* Initialize context on first module */
            status = TAP_initContext(pModule, g_pTapEntityCred,
                                        NULL, &g_pTapContext, pErrContext);
            if (OK != status)
            {
                printf("TAP_initContext : %d\n", status);
                goto exit;
            }
        }

        if (pTempTAPCtx == NULL)
        {
            /* Initialize context on first module */
            status = TAP_initContext(pModule, g_pTapEntityCred,
                                        NULL, &pTempTAPCtx, pErrContext);
            if (OK != status)
            {
                printf("TAP_initContext : %d\n", status);
                goto exit;
            }

            if (OK > (status = SSL_EXAMPLE_addTAPContext(pTempTAPCtx, pKey)))
            {
                goto exit;
            }
        }

        *ppTapContext    = pTempTAPCtx;
        *ppTapEntityCred = g_pTapEntityCred;
        *ppTapKeyCred    = g_pTapKeyCred;
    }
    else
    {
        /* Do NOT free the context. This application uses a global TAP Context */
#if 0
        /* Destroy the TAP context */
        if (OK > (status = TAP_uninitContext(ppTapContext, pErrContext)))
        {
            DEBUG_ERROR(DEBUG_SSL_EXAMPLE, (sbyte*)"SSL_EXAMPLE: TAP_uninitContext failed with status: ", status);
        }
#endif
    }

exit:
    return status;
}

static MSTATUS
SSL_EXAMPLE_TAPInit(ubyte *pTpm2ConfigFile,
                    TAP_EntityCredentialList **ppTapEntityCred,
                    TAP_CredentialList **ppTapKeyCred)
{
    MSTATUS status = OK;
    TAP_ConfigInfoList configInfoList = { 0, };
    TAP_ErrorContext *pErrContext = NULL;
    ubyte gotModuleList = FALSE;
    TAP_EntityCredentialList *pEntityCredentials = { 0 };
    TAP_CredentialList *pKeyCredentials = { 0 };
    TAP_Module *pModule = NULL;
#ifdef __ENABLE_DIGICERT_TAP_REMOTE__
    TAP_ConnectionInfo connInfo = { 0 };
#endif

#if (!defined(__ENABLE_DIGICERT_TAP_REMOTE__))
    status = DIGI_CALLOC((void **)&(configInfoList.pConfig), 1, sizeof(TAP_ConfigInfo));
    if (OK != status)
    {
        printf("Failed to allocate memory, status = %d", status);
        goto exit;
    }

    status = TAP_readConfigFile(pTpm2ConfigFile, &configInfoList.pConfig[0].configInfo, 0);
    if (OK != status)
    {
        printf("Failed to read config file, status = %d", status);
        goto exit;
    }

    configInfoList.count = 1;
    configInfoList.pConfig[0].provider = ssls_TapProvider;
#endif

    status = TAP_init(&configInfoList, pErrContext);
    if (OK != status)
    {
        printf("TAP_init : %d", status);
        goto exit;
    }

#if (defined(__ENABLE_DIGICERT_TAP_REMOTE__))

    connInfo.serverName.bufferLen = DIGI_STRLEN((sbyte *)taps_ServerName)+1;
    status = DIGI_CALLOC ((void **)&(connInfo.serverName.pBuffer), 1, connInfo.serverName.bufferLen);
    if (OK != status)
    goto exit;

    status = DIGI_MEMCPY ((void *)(connInfo.serverName.pBuffer), (void *)taps_ServerName, DIGI_STRLEN((sbyte *)taps_ServerName));
    if (OK != status)
    goto exit;

    connInfo.serverPort = taps_ServerPort;

    status = TAP_getModuleList(&connInfo, ssls_TapProvider, NULL,
                               &g_moduleList, pErrContext);
#else
    status = TAP_getModuleList(NULL, ssls_TapProvider, NULL,
                               &g_moduleList, pErrContext);
#endif
    if (OK != status)
    {
        printf("TAP_getModuleList : %d \n", status);
        goto exit;
    }
    gotModuleList = TRUE;
    if (0 == g_moduleList.numModules)
    {
        printf("No TPM2 modules found\n");
        goto exit;
    }

    if (ssls_TapProvider == TAP_PROVIDER_PKCS11)
    {
        int i = 0;
        for (i = 0; i < g_moduleList.numModules; i++)
        {
            /* moduleId:0 is for software */
            if (0 != g_moduleList.pModuleList[i].moduleId)
            {
                pModule = &g_moduleList.pModuleList[i];
                break;
            }
        }
    }
    else
    {
        pModule = &g_moduleList.pModuleList[0];
    }

    /* For local TAP, parse the config file and get the Entity Credentials */
#if (!defined(__ENABLE_DIGICERT_TAP_REMOTE__))
    status = TAP_getModuleCredentials(pModule,
                                      pTpm2ConfigFile, 0,
                                      &pEntityCredentials,
                                      pErrContext);

    if (OK != status)
    {
        printf("Failed to get credentials from Credential configuration file, status = %d", status);
        goto exit;
    }
#endif

    *ppTapEntityCred = pEntityCredentials;
    *ppTapKeyCred    = pKeyCredentials;

exit:
    /* Free config info */
    if (NULL != configInfoList.pConfig)
    {
        status = TAP_UTILS_freeConfigInfoList(&configInfoList);
        if (OK != status)
            printf("TAP_UTILS_freeConfigInfoList : %d\n", status);
    }

#if (defined(__ENABLE_DIGICERT_TAP_REMOTE__))
    if (connInfo.serverName.pBuffer != NULL)
    {
        DIGI_FREE((void **)&connInfo.serverName.pBuffer);
    }
#endif
    return status;

}
#endif
/*------------------------------------------------------------------*/

#ifdef __ENABLE_DIGICERT_TLS13_PSK__

static sbyte4
SSL_EXAMPLE_funcPtrDeletePSK(sbyte4 connectionInstance,
                                     sbyte *pServerName, ubyte4 serverNameLen,
                                     ubyte *pIdentityPSK, ubyte4 identityLengthPSK,
                                     ubyte *ppsk)
{
    /* TODO Remove the psk */
    return OK;
}

static sbyte4
SSL_EXAMPLE_funcPtrSavePSK(sbyte4 connectionInstance,
                                     ubyte *pServerName, ubyte4 serverNameLen,
                                     ubyte *pIdentityPSK, ubyte4 identityLengthPSK,
                                     ubyte *pPsk, ubyte4 pskLen)
{
    MSTATUS status = OK;

    /* In this application, we store only one PSK.
     * Free, before allocating
     */
    if (g_pPSK != NULL)
    {
        DIGI_FREE((void **)&g_pPSK);
    }

    if (g_pPSKIdentity != NULL)
    {
        DIGI_FREE((void **)&g_pPSKIdentity);
    }

    /* Allocate memory and copy the data */
    if (OK > (status = DIGI_MALLOC((void **)&g_pPSK, pskLen)))
    {
        goto exit;
    }

    if (OK > (status = DIGI_MEMCPY(g_pPSK, pPsk, pskLen)))
    {
        goto exit;
    }

    if (OK > (status = DIGI_MALLOC((void **)&g_pPSKIdentity, identityLengthPSK)))
    {
        goto exit;
    }

    if (OK > (status = DIGI_MEMCPY(g_pPSKIdentity, pIdentityPSK, identityLengthPSK)))
    {
        goto exit;
    }

    g_pPSKIdentityLength = identityLengthPSK;
    g_pServerInfo        = pServerName;
    g_serverInfoLength   = serverNameLen;
    g_pPSKLen            = pskLen;

exit:
    return status;
}

static sbyte4
SSL_EXAMPLE_funcPtrLookupPSKParams(sbyte4 connectionInstance,
                                       ubyte *pIdentityPSK, ubyte4 identityLengthPSK,
                                       ubyte **ppPsk, ubyte4 *pPskLen, intBoolean *pFreeMemory)
{
    MSTATUS status = OK;

    sbyte4 cmpRes = 0;

    if (ppPsk == NULL)
        return -1;

    if (TRUE == ssls_useExternalPsk)
    {
        if (identityLengthPSK != externalPsk.pskTLS13IdentityLength)
        {
            goto exit;
        }

        DIGI_MEMCMP(pIdentityPSK, externalPsk.pskTLS13Identity, identityLengthPSK, &cmpRes);
        if (0 == cmpRes)
        {
            status = SSL_serializePSK(&externalPsk, ppPsk, pPskLen);
            if (OK != status)
            {
                goto exit;
            }
        }

        *pFreeMemory = TRUE;
    }
    else
    {
        DIGI_MEMCMP(pIdentityPSK, g_pPSKIdentity, identityLengthPSK, &cmpRes);
        if (0 == cmpRes)
        {
            *ppPsk = g_pPSK;
            *pPskLen = g_pPSKLen;
        }

        *pFreeMemory = FALSE;
    }

exit:
    return status;
}

static sbyte4
SSL_LOOPBACK2_EXAMPLE_funcPtrGetHintPSK(sbyte4 connectionInstance,
                                        ubyte hintPSK[SSL_PSK_SERVER_IDENTITY_LENGTH],
                                        ubyte4 *pRetHintLength)
{
    MSTATUS status = OK;
    MOC_UNUSED(connectionInstance);

    /* this is a server side callback */

    /* this callback is optional, send back a hint for which psk the server would prefer to use */
    /* no registered callback or just returning zero is fine, if you do not want to send a hint */
#if 0
    (void) DIGI_MEMCPY(hintPSK, "Initial PSK", strlen("Initial PSK"));
    *pRetHintLength = strlen("Initial PSK");
#endif
    if (OK > (status = DIGI_MEMSET((ubyte*)hintPSK, 0x00, SSL_PSK_SERVER_IDENTITY_LENGTH)))
    {
        goto exit;
    }

    if (OK > (status = DIGI_MEMCPY((ubyte*)hintPSK, g_pPSKIdentity, g_pPSKIdentityLength)))
    {
        goto exit;
    }

    *pRetHintLength = g_pPSKIdentityLength;

exit:
    /* return a negative value, if you want the session to abort */
    return status;
}

#if defined(__ENABLE_DIGICERT_TLS13_0RTT__)
sbyte4 SSL_EXAMPLE_getTLS13EarlyData(sbyte4 connectionInstance, ubyte* pData, ubyte4 dataLen, dataState dataState)
{
    printf("Early data received is: ");
    for (int i = 0; i < dataLen; i++)
    {
        printf("%c", pData[i]);
    }
    printf("\n");
    return 0;
}
#endif /* __ENABLE_DIGICERT_TLS13_0RTT__ */
#endif /* __ENABLE_DIGICERT_TLS13_PSK__ */

#ifdef __ENABLE_DIGICERT_SSL_PSK_SUPPORT__
#if !defined(__ENABLE_DIGICERT_TLS13__)
static sbyte4
SSL_LOOPBACK2_EXAMPLE_funcPtrGetHintPSK(sbyte4 connectionInstance,
                                        ubyte hintPSK[SSL_PSK_SERVER_IDENTITY_LENGTH],
                                        ubyte4 *pRetHintLength)
{
    MOC_UNUSED(connectionInstance);

    /* this is a server side callback */

    /* this callback is optional, send back a hint for which psk the server would prefer to use */
    /* no registered callback or just returning zero is fine, if you do not want to send a hint */
    (void) DIGI_MEMCPY(hintPSK, "hello", 5);
    *pRetHintLength = 5;

    /* return a negative value, if you want the session to abort */
    return 0;
}
#endif


static sbyte4
SSL_LOOPBACK2_EXAMPLE_funcPtrLookupPSK(sbyte4 connectionInstance,
                                       ubyte *pIdentityPSK, ubyte4 identityLengthPSK,
                                       ubyte retPSK[SSL_PSK_MAX_LENGTH], ubyte4 *pRetLengthPSK)
{
    MOC_UNUSED(connectionInstance);
    MOC_UNUSED(pIdentityPSK);
    MOC_UNUSED(identityLengthPSK);

    /* this is a server side callback */

    /* what we're suppose to do is look up the identity passed in, */
    /* based on that return a specific shared key, instead we're */
    /* going to return the hardwired pre-shared key */

    /* here we return the preshared secret... keep this safe! */
    (void) DIGI_MEMCPY(retPSK, "the eagle flies at midnight.", 28);
    *pRetLengthPSK = 28;    /* note: make sure your lengths are correct!  */

    /* return a negative value, if you want the session to abort */
    return 0;
}

#endif /* __ENABLE_DIGICERT_SSL_PSK_SUPPORT__ */

#if defined(__ENABLE_DIGICERT_TLS13__)
static sbyte4
SSL_EXAMPLE_keyUpdate(sbyte4 connectionInstance)
{
    return SSL_sendKeyUpdateRequest(connectionInstance, 1 /* update_request */);
}
#endif

#ifdef __ENABLE_DIGICERT_SSL_SRP__
static sbyte4
SSL_EXAMPLE_SRPCallback(sbyte4 connectionInstance, const ubyte* identity,
                     ubyte4 identityLength, sbyte4* numBits,
                     ubyte salt[SSL_PSK_SERVER_IDENTITY_LENGTH],
                     ubyte4* saltLength,
                     ubyte** verifier, ubyte4* verifierLength)
{
    intBoolean differ;
    sbyte4 status;


    static const ubyte scott_salt[] =
    {
        0xa1, 0x45, 0xbe, 0x68, 0xf9, 0xec, 0x2c, 0xbe, 0xd7, 0x49, 0xc3, 0x61,
        0xa6, 0x57, 0xd1, 0x26, 0x8f, 0xdc, 0x6c, 0x3e, 0x7c, 0xee, 0x53, 0x4b,
    };


    /* support only one identity : scott/tiger, using 4096 group */
    /* verify this is the correct identity */
    if (5 != identityLength)
    {
        status = ERR_FALSE;
        goto exit;
    }

    DIGI_CTIME_MATCH((const ubyte*) "scott", identity, 5, &differ);

    if (differ)
    {
        status = ERR_FALSE;
        goto exit;
    }

    *numBits = 4096;
    *saltLength = sizeof(scott_salt);

    DIGI_MEMCPY( salt, scott_salt, *saltLength);

    /* in real implementations, the server does not know the password and
     would store only a precomputed verifier; for testing, computing the
     verifiter on the fly is convenient */
    if (OK > ( status = SRP_computeVerifier(scott_salt, *saltLength,
                        (ubyte*) "scott", 5, (ubyte*) "tiger", 5, 4096,
                        verifier, verifierLength)))
    {
        goto exit;
    }

exit:
    return status;
}
#endif

#if defined(__ENABLE_DIGICERT_SSL_HEARTBEAT_RFC_6520__)
sbyte4 heartbeatCallback(sbyte4 connectionInstance, sbyte4 status, ubyte heartbeatType)
{
    MOC_UNUSED(connectionInstance);
    MOC_UNUSED(heartbeatType);

    return status;
}
#endif

/*------------------------------------------------------------------*/

static void
SSL_EXAMPLE_sendError(sbyte4 connectionInstance, sbyte* errStr)
{
    sbyte reply[1024];
    sbyte4  ret;

    DEBUG_PRINT(DEBUG_SSL_EXAMPLE, (sbyte *)"SSL_EXAMPLE: Sending error back: ");
    DEBUG_PRINTNL(DEBUG_SSL_EXAMPLE, errStr);

    (void) sprintf((char *)reply, "HTTP/1.0 %s\r\n\r\n", errStr);

    ret = SSL_send(connectionInstance, reply, DIGI_STRLEN((const sbyte *)reply));

    if (0 > ret)
    {
    	myPrintError("SSL_EXAMPLE: SSL_send return error: ", ret);
    }
}

/*------------------------------------------------------------------*/

static void
SSL_EXAMPLE_sendTextFile(sbyte4 connectionInstance, sbyte* fileName, sbyte* httpVer)
{
    sbyte    *reply = NULL;
    sbyte    hardReply[1152];
    sbyte    body[1024];
    sbyte4   ret;
    ubyte4   replyLen = 0;
    sbyte    *tempFile = NULL;
	int body_len = 0;

    MOC_UNUSED(httpVer);

    DEBUG_PRINT3(DEBUG_SSL_EXAMPLE, (sbyte *)"SSL_EXAMPLE: SSL_EXAMPLE_sendTextFile /tmp", fileName, (sbyte *)" back");
    setStringParameter((char **)((usize *)&tempFile),(char *)fileName);
    setFilePath(filePath,&tempFile);
    if (OK == DIGICERT_readFile((char *)tempFile,(ubyte **)&reply,(ubyte4 *)((usize *)&replyLen))){
        ret = SSL_send(connectionInstance, reply, DIGI_STRLEN((const sbyte *)reply));
     }
    else{
       (void) sprintf((char *)body, "<html><head><title>Reading file</title></head><body>"
                   "Failed to read file /tmp/%s</body></html>", fileName);

       body_len = DIGI_STRLEN((const sbyte *)body);
       (void) sprintf((char *)hardReply, "HTTP/1.0 200 OK\r\nContent-type: text/html\r\nContent-length: %d\r\n\r\n%s",
        body_len, body);
        ret = SSL_send(connectionInstance, hardReply, DIGI_STRLEN((const sbyte *)hardReply));
     }

    if (0 > ret)
    {
        DEBUG_ERROR(DEBUG_SSL_EXAMPLE, (sbyte *)"SSL_EXAMPLE: SSL_send return error: ", ret);
    }

    /* resource stored in "reply" was allocated in DIGICERT_readFile().  Must free it. */
    /* this function is (void) so no need for return value */
    (void) CONVERT_FREE(reply);
    /*tempFile has been used and must free it.*/
    if (NULL != tempFile)
       (void) DIGI_FREE((void **)&tempFile);

}

/*------------------------------------------------------------------*/

static void
SSL_EXAMPLE_sendAutoGeneratedFile(sbyte4 connectionInstance, sbyte* fileName, sbyte* httpVer)
{
    sbyte    body[1024];
    sbyte    reply[1152];
    sbyte4   ret;
    int      body_len;

    MOC_UNUSED(httpVer);

    DEBUG_PRINT3(DEBUG_SSL_EXAMPLE, (sbyte *)"SSL_EXAMPLE: TestSendAutoGeneratedFile ", fileName, (sbyte *)" back");

    (void) sprintf((char *)body, "<html><head><title>TestSendAutoGeneratedFile</title></head><body>"
                   "This is the content of the file %s</body></html>", fileName);

    body_len = DIGI_STRLEN((const sbyte *)body);
    (void) sprintf((char *)reply, "HTTP/1.0 200 OK\r\nContent-type: text/html\r\nContent-length: %d\r\n\r\n%s",
        body_len, body);

    ret = SSL_send(connectionInstance, reply, DIGI_STRLEN((const sbyte *)reply));

    if (0 > ret)
    {
        DEBUG_ERROR(DEBUG_SSL_EXAMPLE, (sbyte *)"SSL_EXAMPLE: SSL_send return error: ", ret);
    }
}


/*------------------------------------------------------------------*/

static void
SSL_EXAMPLE_sendImageFile(sbyte4 connectionInstance, sbyte* httpVer)
{
    sbyte    reply[1024];
    sbyte4   ret;
    int      image_size;
    MOC_UNUSED(httpVer);

    DEBUG_PRINT(DEBUG_SSL_EXAMPLE, (sbyte *)"SSL_EXAMPLE: TestSendImageFile");

    image_size = sizeof(gFavoriteImage);
    (void) sprintf((char *) reply,
    	"HTTP/1.0 200 OK\r\nContent-type: image/jpeg\r\nContent-length: %d\r\n\r\n",
        image_size);

    ret = SSL_send(connectionInstance, reply, DIGI_STRLEN((const sbyte *)reply));
    if ( ret > 0)
    {
        (void) SSL_send( connectionInstance, (sbyte *)gFavoriteImage, sizeof(gFavoriteImage));
    }

    if (0 > ret)
    {
        DEBUG_ERROR(DEBUG_SSL_EXAMPLE, (sbyte *)"SSL_EXAMPLE: SSL_send return error: ", ret);
    }
}

/*------------------------------------------------------------------*/

static void
SSL_EXAMPLE_sendHTMLFile(sbyte4 connectionInstance, sbyte* httpVer)
{
    sbyte    reply[1024];
    sbyte4   ret;
    ubyte4   lenFile;
    MOC_UNUSED(httpVer);

    DEBUG_PRINT(DEBUG_SSL_EXAMPLE, (sbyte *)"SSL_EXAMPLE: TestSendHTMLFile");

    lenFile = DIGI_STRLEN((const sbyte *)gComplexFile);
    (void) sprintf((char *)reply,
        "HTTP/1.0 200 OK\r\nContent-type: text/html\r\nContent-length: %d\r\n\r\n",
        lenFile);

    ret = SSL_send(connectionInstance, reply, DIGI_STRLEN((const sbyte *)reply));
    if ( ret > 0)
    {
        (void) SSL_send(connectionInstance, (sbyte *)gComplexFile, lenFile);
    }

    if (0 > ret)
    {
        DEBUG_ERROR(DEBUG_SSL_EXAMPLE, (sbyte *)"SSL_EXAMPLE: SSL_send return error: ", ret);
    }
}


/*------------------------------------------------------------------*/

static void
SSL_EXAMPLE_sendPseudoFile(sbyte4 connectionInstance, sbyte* fileName, sbyte* httpVer)
{
    ubyte4 fileNameLen;

    fileNameLen = DIGI_STRLEN((const sbyte *) fileName);

    if ( fileNameLen > 4)
    {
        /* jpg ? */
        sbyte* extension = fileName + fileNameLen - 4;
        if ( (*extension++ == '.') && (tolower(*extension++) == 'j') &&
             (tolower(*extension++) == 'p') && (tolower(*extension++) == 'g'))
        {
            SSL_EXAMPLE_sendImageFile( connectionInstance, httpVer);
            return;
        }

        /* htm ? */
        extension = fileName + fileNameLen - 4;
        if (*extension++ == '.' && tolower(*extension++) == 'h' &&
            tolower(*extension++) == 't' && tolower(*extension++) == 'm')
        {
            SSL_EXAMPLE_sendHTMLFile( connectionInstance, httpVer);
            return;
        }
    }

    SSL_EXAMPLE_sendAutoGeneratedFile(connectionInstance, fileName, httpVer);

}


/*------------------------------------------------------------------*/

static void
SSL_EXAMPLE_sendBigResponseA(sbyte4 connectionInstance, sbyte* fileName, sbyte* httpVer)
{
    sbyte4 size = LINE_SIZE * 1;
    sbyte reply[500];
    sbyte line[LINE_SIZE];
    sbyte4 j;
    sbyte4 ret;
    MOC_UNUSED(httpVer);

    switch (fileName[2])
    {
        case 'a': size =    10 * LINE_SIZE;  break;
        case 'b': size =   100 * LINE_SIZE;  break;
        case 'c': size =   500 * LINE_SIZE;  break;
        case 'd': size =  1000 * LINE_SIZE;  break;
        case 'e': size =  2000 * LINE_SIZE;  break;
        case 'f': size =  5000 * LINE_SIZE;  break;
        case 'g': size = 10000 * LINE_SIZE;  break;
    }


    for (j = 0; j < LINE_SIZE; j++)
        line[j] = '.'; /*'0' + j % 10;*/

    for (j = 0; j < LINE_SIZE; j += 100)
        line[j] = '|'; /*'0' + j % 10;*/

#if 0
    line[0]   = '<';
    line[1]   = 'h';
    line[2]   = 't';
    line[3]   = 'm';
    line[4]   = 'l';
    line[5]   = '>';
#endif

    line[996]   = '<';
    line[997]   = 'b';
    line[998]   = 'r';
    line[999]   = '>';


    DEBUG_PRINT3(DEBUG_SSL_EXAMPLE, (sbyte *)"SSL_EXAMPLE: Sending response ", fileName, (sbyte *)" back");

    size += (12 + 14);

    (void) sprintf((char *)reply, "HTTP/1.0 200 OK\r\nContent-type: text/html\r\nContent-length: %d\r\n\r\n<html><body>", size);
    ret = SSL_send(connectionInstance, reply, DIGI_STRLEN((const sbyte *)reply));

    if (0 > ret)
    {
        DEBUG_ERROR(DEBUG_SSL_EXAMPLE, (sbyte *)"SSL_EXAMPLE: SSL_send return error: ", ret);
        return;
    }

    for (j = 0; j < size / LINE_SIZE; j++)
    {
        ubyte4 bs;
        sbyte buf[40];
        (void) sprintf((char *)buf, "%d_bytes_", (j+1) * LINE_SIZE);


        for (bs = 0; bs < DIGI_STRLEN((const sbyte *)buf); bs++)
        {
            line[bs] = buf[bs];
        }
        ret = SSL_send(connectionInstance, line, LINE_SIZE);

        if (0 > ret)
        {
            DEBUG_ERROR(DEBUG_SSL_EXAMPLE, (sbyte *)"SSL_EXAMPLE: SSL_send return error: ", ret);
            return;
        }
    }

    (void) sprintf((char *)reply, "</body></html>\r\n\r\n");

    ret = SSL_send(connectionInstance, reply, DIGI_STRLEN((const sbyte *)reply));

    if (0 > ret)
        DEBUG_ERROR(DEBUG_SSL_EXAMPLE, (sbyte *)"SSL_EXAMPLE: SSL_send return error: ", ret);

}

/*------------------------------------------------------------------*/

static void
SSL_EXAMPLE_sendBigResponseB(sbyte4 connectionInstance, sbyte* fileName, sbyte* httpVer)
{
    sbyte4     size        = 100000;
    sbyte      *reply;
    sbyte      *body;
    sbyte4     j;
    sbyte4     body_len;
    sbyte4     ret;
    MOC_UNUSED(httpVer);

    if (NULL == (reply = MALLOC(size)))
    {
        (void) printf("Can't allocate memory in SSL_EXAMPLE_sendBigResponseB()\n");
        return;
    }
    if (NULL == (body = MALLOC(size)))
    {
        (void) printf("Can't allocate memory in SSL_EXAMPLE_sendBigResponseB()\n");
        (void) DIGI_FREE((void **)&reply);
        return;
    }

    (void) sprintf((char *)body, "<html><head><title>SSL TestSendBigResponse</title></head>"
                "<body>SSL TestSendBigResponse %s<br><pre>",
                fileName);

    while (size - 2000 > (body_len = DIGI_STRLEN((const sbyte *)body)))
    {
        char tempNum[20] = {0};

        (void) strcat((char *) body, "|<--- body length ");
        (void) sprintf(tempNum, "%d    ", body_len);
        (void) strcat((char *) body, tempNum);
        for (j = 0; j < 30; j++)
        {
            (void) strcat((char *) body, "@@@@@@@@@@@@@@@@@@@ ");
            (void) sprintf(tempNum, "%d ", DIGI_STRLEN((const sbyte *)body));
            (void) strcat((char *) body, tempNum);     
        }
        (void) strcat((char *) body, "\n");
    }
    (void) strcat((char *) body, "</body></html>");

    DEBUG_PRINT3(DEBUG_SSL_EXAMPLE, (sbyte *)"SSL_EXAMPLE: Sending file ", fileName, (sbyte *)" back");

    body_len = DIGI_STRLEN((const sbyte *)body);
    (void) sprintf((char *) reply,
        "HTTP/1.0 200 OK\r\nContent-type: text/html\r\nContent-length: %d\r\n\r\n%s\r\n\r\n",
        body_len, body);

    ret = SSL_send(connectionInstance, reply, DIGI_STRLEN((const sbyte *)reply));

    if (0 > ret)
        DEBUG_ERROR(DEBUG_SSL_EXAMPLE, (sbyte *)"SSL_EXAMPLE: SSL_send return error: ", ret);

    (void) DIGI_FREE((void **)&body);
    (void) DIGI_FREE((void **)&reply);
}


/*------------------------------------------------------------------*/

static void
SSL_EXAMPLE_sendBigResponseC(sbyte4 connectionInstance, sbyte* fileName, sbyte* httpVer)
{
    sbyte4  msgSize;
    sbyte4  numReps;
    sbyte*  pRepeatBlock = NULL;
    sbyte*  pHttpHeader  = NULL;
    sbyte*  pHtmlHeader  = NULL;
    sbyte   htmlTail[128];
    sbyte   lengthTag[32];
    sbyte4  lengthTagLen;
    MSTATUS status;
    int     htmlHeader_len;
    int     htmlTail_len;
    int     fileNameStrLen = 0;

    MOC_UNUSED(httpVer);

    fileNameStrLen = DIGI_STRLEN(fileName);

    if (NULL == (pHttpHeader = MALLOC(128)))
    {
        status = ERR_MEM_ALLOC_FAIL;
        goto exit;
    }

    if (NULL == (pHtmlHeader = MALLOC(fileNameStrLen + 128)))
    {
        status = ERR_MEM_ALLOC_FAIL;
        goto exit;
    }

    if (40 > (msgSize = atoi((const char *)(2 + fileName))))
    {
        /* default to 8000 byte messages, if less than 40 bytes */
        msgSize = 8000;
    }

    /* we will send ~2 billion bytes per page load */
    /* numReps = 2000000000UL / msgSize; */

    /* we will send ~4 million bytes per page load */
    /* comment out the next line, if you want the test to run for a long time */
    numReps = 4000000UL / msgSize;

    if (NULL == (pRepeatBlock = MALLOC(msgSize)))
    {
        status = ERR_MEM_ALLOC_FAIL;
        goto exit;
    }

    DEBUG_PRINT3(DEBUG_SSL_EXAMPLE, (sbyte *)"SSL_EXAMPLE_sendBigResponseC: Sending file ", fileName, (sbyte *)" back");

    (void) DIGI_MEMSET((ubyte *)pRepeatBlock, '@', msgSize);
    (void) DIGI_MEMCPY(pRepeatBlock, "|<--- ", 6);

    (void) sprintf((char *)lengthTag, " [%d] --->|<br>", msgSize);
    lengthTagLen = DIGI_STRLEN((const sbyte *)lengthTag);
    (void) DIGI_MEMCPY(msgSize - lengthTagLen + pRepeatBlock, lengthTag, lengthTagLen);

    /* first form the html header and tail, so we can accurately calculate the entire message size */
    (void) sprintf((char *)pHtmlHeader, "<html><head><title>SSL TestSendBigResponse</title></head><body>SSL TestSendBigResponse %s<br><pre>", fileName);
    (void) sprintf((char *)htmlTail, "</body></html>\r\n\r\n");
    htmlHeader_len = DIGI_STRLEN((const sbyte *)pHtmlHeader);
    htmlTail_len = DIGI_STRLEN((const sbyte *)htmlTail);
    (void) sprintf((char *)pHttpHeader,
    	"HTTP/1.0 200 OK\r\nContent-type: text/html\r\nContent-length: %d\r\n\r\n",
    	msgSize * numReps + htmlHeader_len + htmlTail_len);

    /* send HTTP header */
    if (OK > (status = (MSTATUS) SSL_send(connectionInstance, pHtmlHeader, DIGI_STRLEN((const sbyte *)pHttpHeader))))
        goto exit;

    /* send start of HTML body */
    if (OK > (status = (MSTATUS) SSL_send(connectionInstance, pHtmlHeader, DIGI_STRLEN((const sbyte *)pHtmlHeader))))
        goto exit;

    while (numReps)
    {
        if (OK > (status = (MSTATUS) SSL_send(connectionInstance, pRepeatBlock, msgSize)))
            goto exit;

        numReps--;
    }

    /* send start of HTML end */
    if (OK > (status = (MSTATUS) SSL_send(connectionInstance, pHtmlHeader, DIGI_STRLEN((const sbyte *)htmlTail))))
        goto exit;

exit:
    DEBUG_ERROR(DEBUG_SSL_EXAMPLE, (sbyte *)"SSL_EXAMPLE_sendBigResponseC: Return status = ", status);

    (void) DIGI_FREE((void **)&pRepeatBlock);

    if (NULL != pHttpHeader)
    {
        (void) DIGI_FREE((void **)&pHttpHeader);
    }
    if (NULL != pHtmlHeader)
    {
        (void) DIGI_FREE((void **)&pHtmlHeader);
    }


} /* SSL_EXAMPLE_sendBigResponseC */


/*------------------------------------------------------------------*/

static sbyte4
SSL_EXAMPLE_processRequest(sbyte4 connectionInstance, sbyte* lpBuf)
{
    sbyte szSeps[] = " \n";
    sbyte *cpToken, *fileName, *httpVer;
    sbyte4 status = OK;

    /* strtok() can return NULL */
    cpToken = (sbyte *)strtok( (char *)lpBuf, (const char *)szSeps);
    if (NULL == cpToken)
    {
        SSL_EXAMPLE_sendError(connectionInstance, (sbyte *)"Bad token");
        goto exit;
    }

    if (0 != strcmp((const char *)cpToken, "GET") && 0 != strcmp((const char *)cpToken, "get"))
    {
        /* Send "not implemented" error */
        SSL_EXAMPLE_sendError(connectionInstance, (sbyte *)"501 Not Implemented");
        goto exit;
    }

    /* Get the file name */
    fileName = (sbyte *)strtok(NULL, (const char *)szSeps);
    if (fileName == NULL)
    {
        /* Send "bad request" error */
        SSL_EXAMPLE_sendError(connectionInstance, (sbyte *)"400 Bad Request");
        goto exit;
    }

    httpVer = (sbyte *)strtok(NULL, (const char *)szSeps);
    if (httpVer == NULL)
    {
        /* Send "bad request" error */
        SSL_EXAMPLE_sendError(connectionInstance, (sbyte *)"400 Bad Request");
        goto exit;
    }

    switch (fileName[1])
    {
        case 'a':
            SSL_EXAMPLE_sendBigResponseA(connectionInstance, fileName, httpVer);
            break;
        case 'b':
            SSL_EXAMPLE_sendBigResponseB(connectionInstance, fileName, httpVer);
            break;
        case 'c':
            SSL_EXAMPLE_sendBigResponseC(connectionInstance, fileName, httpVer);
            break;
        case 'x':
            SSL_EXAMPLE_sendTextFile(connectionInstance, fileName, httpVer);
            break;
        case 'q':
            status = 'q';
            break;
        default:
            SSL_EXAMPLE_sendPseudoFile(connectionInstance, fileName, httpVer);
            break;
    }

exit:
    return status;
}


/*------------------------------------------------------------------*/
#if 0  /* reference to this function commented out in this file */
static sbyte4
SSL_EXAMPLE_resetTimer(sbyte4 connectionInstance, ubyte4 *msTimeout)
{
    sbyte4 status  = 0;
    ubyte4 newTimeout = 10000;
    static ubyte count = 0;

    printf("Resetting the timeout to %d\n", newTimeout);
    if (count < 3)
    {
        *msTimeout = newTimeout;
        count++;
    }
    else
    {
        *msTimeout = 0;
    }

    return status;
}
#endif /* function not referenced */

static sbyte4
SSL_EXAMPLE_getRequest(sbyte4 connectionInstance)
{
    sbyte    buff[1024]  = { 0 };
    sbyte4     found       = FALSE;
    sbyte4     received    = 0;
    sbyte4     isPending   = 0;
    sbyte4     status;

    while (!found)
    {
        sbyte4 nRet;

        if ((0 > (status = SSL_recv(connectionInstance, buff + received, 1024 - received, &nRet, 0 /*!!!!*/))) ||
            (0 > nRet))
        {
            DEBUG_ERROR(DEBUG_SSL_EXAMPLE, (sbyte *)"SSL_EXAMPLE: SSL_Receive returned error ", status);
            goto exit;
        }

        received += nRet;
        found = (received > 4) && (0 == strcmp("\r\n\r\n", (const char *)buff + received - 4));
    }
#ifdef __ENABLE_DIGICERT_SSL_REHANDSHAKE_EXAMPLE__
    /* Demo of timer based rehandshake */
    while (1)
        SSL_checkRehandshakeTimer(connectionInstance);
#endif
    DEBUG_PRINT3(DEBUG_SSL_EXAMPLE, (sbyte *)"SSL_EXAMPLE: Request =\n", (sbyte *)CRLF, buff);
    (void) SSL_recvPending(connectionInstance, &isPending);
    DEBUG_ERROR(DEBUG_SSL_EXAMPLE, (sbyte *)"SSL_EXAMPLE: bytes pending = ", isPending);

    status = SSL_EXAMPLE_processRequest(connectionInstance, buff);

    if (0 > status)
        DEBUG_ERROR(DEBUG_SSL_EXAMPLE, (sbyte *)"SSL_EXAMPLE: SSL_EXAMPLE_processRequest return error: ", status);

exit:
    return status;
}

/*------------------------------------------------------------------*/
static ubyte* protocols[] = { (ubyte *) "super_secret_256", (ubyte *) "http/1.1" };
static sbyte4 SSL_EXAMPLE_ALPNCallback(sbyte4 connectionInstance,
                                    ubyte** out[],
                                    sbyte4* outlen,
                                    ubyte* in,
                                    sbyte4 inlen)
{
    MSTATUS status = OK;

    printf("Inside SSL_EXAMPLE_ALPNCallback\n");

    *outlen = 2;
    *out = (ubyte**)protocols;

    return status;
}
#ifndef __DISABLE_DIGICERT_SSL_CERTIFICATE_CALLBACK__
#if defined(__ENABLE_ALL_DEBUGGING__)
static void
PrintBytes( ubyte* buffer, sbyte4 len)
{
    sbyte4 i;

    for ( i = 0; i < len; ++i)
    {
        DEBUG_HEXBYTE(DEBUG_SSL_TRANSPORT, buffer[i]);
        DEBUG_PRINT(DEBUG_SSL_TRANSPORT, (sbyte*)" ");

        if ( i % 16 == 15)
        {
            DEBUG_PRINTNL(DEBUG_SSL_TRANSPORT, (sbyte*)"");
        }
    }

    DEBUG_PRINTNL(DEBUG_SSL_TRANSPORT, (sbyte*)"");
}
#endif /* __ENABLE_ALL_DEBUGGING__ */

/* This function can be extended to do additional
 * certificate handling by the application */
static MSTATUS SSL_EXAMPLE_getCertAndStatusCallback(sbyte4 connectionInstance,
                                                    struct certChain* pCertChain,
                                                    MSTATUS validationstatus)
{
#ifdef __ENABLE_ALL_DEBUGGING__
    int i;
    ubyte4 numOfCerts;
    CERTCHAIN_numberOfCertificates(pCertChain, &numOfCerts);
    printf("SSL_EXAMPLE_getCertAndStatusCallback. Peer certificate : \n");
    for(i = 0; i < numOfCerts; i++)
    {
        ubyte* certData;
        ubyte4 certLen;
        CERTCHAIN_getCertificate(pCertChain, i, (const ubyte**)&certData, &certLen);
        PrintBytes(certData, certLen);
        printf("\n");
    }

    printf("SSL_EXAMPLE_getCertAndStatusCallback. Peer certificate stack validation status = %d \n", validationstatus);
    printf("SSL_EXAMPLE_getCertAndStatusCallback. Connection Instance = %d \n", connectionInstance);
#endif /* __ENABLE_ALL_DEBUGGING__ */
    return validationstatus;
}
#endif /* __DISABLE_DIGICERT_SSL_CERTIFICATE_CALLBACK__ */

#ifdef __ENABLE_DIGICERT_SSL_INVALID_CERTIFICATE_CALLBACK__
static MSTATUS SSL_EXAMPLE_invalidCertCallback(sbyte4 connectionInstance, MSTATUS status)
{
    MSTATUS newStatus = OK;
#ifdef __ENABLE_ALL_DEBUGGING__
    printf("SSL_EXAMPLE_invalidCertCallback; status = %d\n", status);
    printf("SSL_EXAMPLE_invalidCertCallback; resetting status to %d\n", newStatus);
#endif

    return newStatus;
}
#endif

#ifdef __ENABLE_DIGICERT_OCSP_CLIENT__
sbyte4 myOcspStatusCallback(
    sbyte4 connectionInstance, const ubyte *pCert, ubyte4 certLen,
    ubyte *pOcspResp, ubyte4 ocspRespLen, sbyte4 ocspStatus)
{
    MOC_UNUSED(connectionInstance);

    DEBUG_PRINTNL(DEBUG_SSL_EXAMPLE, (sbyte *) "SSL_EXAMPLE: OCSP Message status");

    if (NULL != pCert)
    {
        DEBUG_PRINTNL(DEBUG_SSL_EXAMPLE, (sbyte *) "Certificate provided");
    }
    else
    {
        DEBUG_PRINTNL(DEBUG_SSL_EXAMPLE, (sbyte *) "Certificate missing");
    }

    if (OK != ocspStatus)
    {
        DEBUG_PRINTNL(DEBUG_SSL_EXAMPLE, (sbyte *) "Received invalid OCSP message from peer");
    }
    else
    {
        DEBUG_PRINTNL(DEBUG_SSL_EXAMPLE, (sbyte *) "Received valid OCSP message from peer");
    }

    return ocspStatus;
}
#endif /* __ENABLE_DIGICERT_OCSP_CLIENT__ */

/*------------------------------------------------------------------*/

static intBoolean needToDie = 0;

static void
startHttpsThread(void* hsocketClient)
{
    sbyte4  connectionInstance;
    sbyte4  status = OK;
    TCP_SOCKET  socketClient = (sbyte4)((usize) hsocketClient);

#ifdef __ENABLE_DIGICERT_OCSP_CLIENT__
    ubyte* issuerCertData = NULL;
    ubyte4 issuerCertLen = 0;
    char * fullpath = NULL;
#endif

    if (0 > (connectionInstance = SSL_acceptConnection(socketClient, pSslCertStore)))
    {
		myPrintError("startHttpsThread: SSL_acceptConnection failed::status ", connectionInstance);
#if !defined(__ENABLE_DIGICERT_SSL_EXAMPLE_INTEROP_TEST__)
        needToDie = 1;
#endif
        goto exit;
    }

#ifdef __ENABLE_DIGICERT_OCSP_CLIENT__
        //if (OK > (status = SSL_setOcspResponderUrl(connectionInstance, "http://127.0.0.1:8907")))
        //{
        //       myPrintError("startHttpsThread: SSL_setOcspResponderUrl failed::status ", status);
        //}
        /*For OCSP request add the issuer cert to the server cert store.
         Note: Not required if the server cert is root cert or the entire server cert chain is already added to cert store as an identity*/

#ifdef __ENABLE_DIGICERT_SSL_MUTUAL_AUTH_SUPPORT_EXAMPLE__
        if (ssls_CACert)
        {
            SSL_CERT_UTILS_getFullPath(ssls_KeyStore, ssls_CACert, &fullpath);
        }
        else
#endif
        {
            SSL_CERT_UTILS_getFullPath(ssls_KeyStore, "ocsp_ca.der", &fullpath);
        }

        if (OK > (status = DIGICERT_readFile(fullpath,&issuerCertData,&issuerCertLen)))
            goto exit;

        /*Add root certs as trust point*/
        if (OK > (status = CERT_STORE_addTrustPoint(pSslCertStore,issuerCertData,issuerCertLen)))
            goto exit;

	if (fullpath)
	    FREE(fullpath);

#endif /* __ENABLE_DIGICERT_OCSP_CLIENT__*/

#ifndef __DISABLE_DIGICERT_ALPN_CALLBACK__
    if (OK > (status = SSL_setAlpnCallback(connectionInstance, SSL_EXAMPLE_ALPNCallback)))
    {
        myPrintError("startHttpsThread: SSL_EXAMPLE_ALPNCallback failed::status ", status);
        SSL_closeConnection(connectionInstance);
        goto exit;
    }
#endif

#ifndef __ENABLE_DIGICERT_SSL_MUTUAL_AUTH_SUPPORT_EXAMPLE__
 if (OK > (status = SSL_setSessionFlags(connectionInstance,SSL_FLAG_NO_MUTUAL_AUTH_REQUEST)))
    {
        myPrintError("startHttpsThread: SSL_EXAMPLE_setSession failed::status ", status);
        SSL_closeConnection(connectionInstance);
        goto exit;
    }
#endif

#if ((defined(__ENABLE_DIGICERT_TLS13__)) && (defined(__ENABLE_DIGICERT_TLS13_PSK__)) && defined(__ENABLE_DIGICERT_TLS13_0RTT__))
    if (ssls_maxEarlyDataSize > 0 )
    {
        if (OK > (status = SSL_setMaxEarlyDataSize(connectionInstance, ssls_maxEarlyDataSize)))
        {
            myPrintError("startHttpsThread: SSL_setMaxEarlyDataSize failed::status ", status);
        }

        if (OK > (status = SSL_setReceiveApplicationDataCallback(SSL_EXAMPLE_getTLS13EarlyData)))
        {
            myPrintError("startHttpsThread: SSL_setReceiveApplicationDataCallback failed::status ", status);
        }
    }

    if (ssls_recvEarlyDataSize > 0 )
    {
        if (OK > (status = SSL_setRecvEarlyDataSize(connectionInstance, ssls_recvEarlyDataSize)))
        {
            myPrintError("startHttpsThread: SSL_setRecvEarlyDataSize failed::status ", status);
        }
    }
#endif

#ifndef __DISABLE_DIGICERT_SSL_CERTIFICATE_CALLBACK__
    if(OK > (status = SSL_setCertAndStatusCallback(connectionInstance,
            SSL_EXAMPLE_getCertAndStatusCallback)))
    {
        myPrintError("startHttpsThread: SSL_EXAMPLE_getCertAndStatusCallback failed::status ", status);
    }
#endif

#ifdef __ENABLE_DIGICERT_SSL_MUTUAL_AUTH_SUPPORT_EXAMPLE__
    status = SSL_setSessionFlags(connectionInstance, SSL_FLAG_REQUIRE_MUTUAL_AUTH);
#if defined(__ENABLE_DIGICERT_OCSP_CLIENT__)
    SSL_setOCSPCallback(myOcspStatusCallback);

    /* Responder Ids; configure a list of trusted responder certificates */
    /* Note: Also set the correct trusted Responder Cert count */
    char *pTrustedResponderCertsPath[] =
    {
        /*"ca/demoCA/cacert.der",*/
        /*"../client/servercert.der",*/
        /*"ca/newcert4.der"*/
        /*"gdroot-g2.der"*/
        NULL
    };
    ubyte4 trustedRespondercertCount = 0;

    if (OK > (MSTATUS) SSL_setCertifcateStatusRequestExtensions(connectionInstance,
                                                                   pTrustedResponderCertsPath,
                                                                   trustedRespondercertCount, NULL, 0))
    {
        goto exit;
    }

#endif /*__ENABLE_DIGICERT_OCSP_CLIENT__*/
#endif

#ifdef __ENABLE_DIGICERT_SSL_INVALID_CERTIFICATE_CALLBACK__
    if (OK > (status =  SSL_setInvalidCertCallback(connectionInstance,
                SSL_EXAMPLE_invalidCertCallback)))
    {
        myPrintError("startHttpsThread: SSL_EXAMPLE_invalidCertCallback failed::status ", status);
    }
#endif
#if defined(__ENABLE_DIGICERT_SSL_HEARTBEAT_RFC_6520__)
    {
        ubyte value = peerAllowedToSend;
        status = SSL_enableHeartbeatSupport(connectionInstance, value, heartbeatCallback);
    }
#endif
#if defined(__ENABLE_DIGICERT_EXTENDED_MASTERSECRET_RFC7627__)
    {
        ubyte4 value = 1;
        SSL_ioctl(connectionInstance, SSL_SET_USE_EXTENDED_MASTERSECRET, (void *)((uintptr)value));
    }
#endif

#if defined(__ENABLE_DIGICERT_TLS13__)
    {
        ubyte4 value = 1;
        SSL_ioctl(connectionInstance, SSL_ENABLE_TLS13_SESSION_TICKETS, (void *)((uintptr)value));
    }
#endif

    if (0 > (status = SSL_negotiateConnection(connectionInstance)))
    {
		myPrintError("startHttpsThread: SSL_negotiateConnection failed::status ", status);


#ifdef __ENABLE_DIGICERT_SSL_ALERTS__
            {
                /* example code for sending alerts on error/close */
                sbyte4  alertId;
                sbyte4  alertClass;

                if (0 <= SSL_lookupAlert(connectionInstance, status, &alertId, &alertClass))

                    (void) SSL_sendAlert(connectionInstance, alertId, alertClass);
            }
#endif
        (void) SSL_closeConnection(connectionInstance);
        connectionInstance = -1;
        goto exit;
    }

#if defined(__ENABLE_DIGICERT_SSL_EXAMPLE_GRACEFUL_SHUTDOWN__)
    sbyte4 found = FALSE;
    while(!found)
    {
        sbyte buff[2048] = {0};
        sbyte4 nRet;

        if (0 > (status = SSL_recv(connectionInstance, buff, 2048, &nRet, 0 /*!!!!*/)))
        {
            DEBUG_ERROR(DEBUG_SSL_EXAMPLE, (sbyte *)"SSL_EXAMPLE: SSL_Receive returned error ", status);
            goto exit;
        }
        found = (0 == strcmp("q\n", (const char *)buff));
    }

    if (found)
    {
        needToDie = 1;
        (void) SSL_closeConnection(connectionInstance);
        connectionInstance = -1;
        goto exit;
    }
#endif

    if ('q' == SSL_EXAMPLE_getRequest(connectionInstance))
    {
#if defined(__ENABLE_DIGICERT_SSL_EXAMPLE_INTEROP_TEST__)
        needToDie = 0;
#else
        needToDie = 1;
#endif
    }

    /* Use the correct flag name if server is initiating the heartbeart message exchange */
#if defined(__xENABLE_DIGICERT_SSL_HEARTBEAT_RFC_6520__)
    status = SSL_sendHeartbeatMessage(connectionInstance);
    while(1)
    {
        sbyte buff[2048] = {0};
        sbyte4 nRet;

        if (0 > (status = SSL_recv(connectionInstance, buff, 2048, &nRet, 0 /*!!!!*/)))
        {
            DEBUG_ERROR(DEBUG_SSL_EXAMPLE, (sbyte *)"SSL_EXAMPLE: SSL_Receive returned error ", status);
            goto exit;
        }
    }

    if ('q' == SSL_EXAMPLE_getRequest(connectionInstance))
    {
#if defined(__ENABLE_DIGICERT_SSL_EXAMPLE_INTEROP_TEST__)
        needToDie = 0;
#else
        needToDie = 1;
#endif
    }
#endif

#if defined(__ENABLE_DIGICERT_TLS13__) && defined(__ENABLE_DIGICERT_SSL_MUTUAL_AUTH_SUPPORT_EXAMPLE__)
    if (OK > (status = SSL_sendPosthandshakeAuthCertificateRequest(connectionInstance)))
    {
        goto exit;
    }

    if ('q' == SSL_EXAMPLE_getRequest(connectionInstance))
    {
#if defined(__ENABLE_DIGICERT_SSL_EXAMPLE_INTEROP_TEST__)
        needToDie = 0;
#else
        needToDie = 1;
#endif
    }

#endif

#if 0
    /* This while loop is required to try to read the certificate and certificate verify in case of post-handshake auth */
    while(1)
    {
        sbyte buff[2048] = {0};
        sbyte4 nRet;

        if (0 > (status = SSL_recv(connectionInstance, buff, 2048, &nRet, 0 /*!!!!*/)))
        {
            DEBUG_ERROR(DEBUG_SSL_EXAMPLE, (sbyte *)"SSL_EXAMPLE: SSL_Receive returned error ", status);
            goto exit;
        }
    }
    /* SSL_EXAMPLE_getRequest(connectionInstance); */
#endif

exit:
    if (0 < connectionInstance)
        (void) SSL_closeConnection(connectionInstance);

    (void) TCP_CLOSE_SOCKET((TCP_SOCKET)socketClient);
#ifdef __ENABLE_DIGICERT_OCSP_CLIENT__
    if (issuerCertData != NULL)
        DIGI_FREE((void **)&issuerCertData);
#endif
}


/*------------------------------------------------------------------*/

static sbyte4
SSL_EXAMPLE_startFakeServer(ubyte2 portNo)
{
    MSTATUS	status;

    if (0 > (status = TCP_LISTEN_SOCKET((TCP_SOCKET *)&mListenSocket, portNo)))
    {
    	myPrintError("SSL_EXAMPLE: Could not create listen socket::status ", status);
        /* DEBUG_PRINTNL(DEBUG_SSL_EXAMPLE, (sbyte *)"SSL_EXAMPLE: Could not create listen socket"); */
        goto exit;
    }


#if defined(WIN32)
    SetConsoleCtrlHandler( HandlerRoutine, TRUE);
#endif

    myPrintStatus("SSL_EXAMPLE: Server listening on port %hu", portNo);
    DIGICERT_log(MOCANA_SSL, LS_INFO, (sbyte *)"SSL server listening for clients");

    /* Loop forever accepting connections */
    while (0 == needToDie)
    {
        RTOS_THREAD tid;

        /* Block on accept() */
        TCP_SOCKET socketClient;

        /* Block on accept() */
        myPrintStringNL("SSL_EXAMPLE: Server waiting on TCP_ACCEPT_SOCKET.", "")
        status = TCP_ACCEPT_SOCKET(&socketClient, mListenSocket, &needToDie);

        if (status < 0)
        {
            myPrintStatus("SSL_EXAMPLE_startFakeServer: TCP_ACCEPT_SOCKET() failed.")
#if !defined(__ENABLE_DIGICERT_SSL_EXAMPLE_INTEROP_TEST__)
            goto exit;
#endif
        }

        if (TRUE == needToDie)
         {
            myPrintStatus("SSL_EXAMPLE_startFakeServer: TCP_ACCEPT_SOCKET() passed.")
#if defined(__ENABLE_DIGICERT_SSL_EXAMPLE_INTEROP_TEST__)
            needToDie = 0;
#else
            goto exit;
#endif
         }

        DEBUG_ERROR(DEBUG_SSL_EXAMPLE, (sbyte *)"SSL_EXAMPLE: Connection accepted on socket: ", socketClient);

        if (OK > RTOS_createThread(startHttpsThread, (void *)((usize)socketClient), SSL_SERVER_SESSION, &tid))
        {
            myPrintStringNL("SSL_EXAMPLE_startFakeServer: RTOS_createThread() failed.", "")
            (void) TCP_CLOSE_SOCKET(socketClient);
#if defined(__ENABLE_DIGICERT_SSL_EXAMPLE_INTEROP_TEST__)
            needToDie = 0;
#else
            goto exit;
#endif
        }

#if (!defined(__OSE_RTOS__))
    if ( tid !=0 ) /* segmentation fault caused if tid is zero and we try and destroy it */
            RTOS_destroyThread( tid); /* not interested by the thread anymore */
#endif
    }

exit:
    (void) TCP_CLOSE_SOCKET(mListenSocket);
    return status;
}

#ifdef __ENABLE_DIGICERT_SSL_NEW_HANDSHAKE__
sbyte4
newHandShakeUpcall(sbyte4 connectionInstance, sbyte4 *pRetDoRehandshake, sbyte4 *pRetDoSessionResumption)
{
    *pRetDoRehandshake = FALSE;
    *pRetDoSessionResumption = FALSE;

    (void) SSL_sendAlert(connectionInstance, SSL_ALERT_NO_RENEGOTIATION, SSLALERTLEVEL_WARNING);

    return OK;
}
#endif

#ifdef __ENABLE_DIGICERT_SSL_REHANDSHAKE_EXAMPLE__
static sbyte4
SSL_rehandshakeAlert(sbyte4 connectionInstance)
{
    ubyte  buff[1024];
    sbyte4 bytesReceived;
    MSTATUS status;
    status = SSL_initiateRehandshake(connectionInstance);
    if (OK > status)
    {
        DEBUG_ERROR(DEBUG_SSL_EXAMPLE, "SSL_EXAMPLE: SSL_initiateRehandshake return error: ", status);
    }
    /* Call to SSL_recv required to read ClientHello */
    status = SSL_recv(connectionInstance, (sbyte*) buff, 1024, &bytesReceived, 5000);
    if (ERR_TCP_READ_TIMEOUT != status)
    {
        DEBUG_ERROR(DEBUG_SSL_EXAMPLE, "SSL_EXAMPLE: SSL_recv return error: ", status);
    }
    else
    {
        status = OK;
    }
    return 0;
}
#endif

#if defined(__ENABLE_DIGICERT_PKCS12_CERT__)
MSTATUS SampleContentHandler (const void *context, contentTypes type,
  ubyte4 extraInfo,
  const ubyte *content,
  ubyte4 contentLen
  )
{
  MSTATUS status;
  P12Content *pCertAndKey = (P12Content *)context;
  ubyte *pBuffer = NULL;
  /* We are going to be passed either a cert or a key. Copy whatever we are
   * passed and store it in the appropriate field of the context.
   */
  status = DIGI_MALLOC ((void **)&pBuffer, contentLen);
  if (OK != status)
    goto exit;

  status = DIGI_MEMCPY ((void *)pBuffer, (void *)content, contentLen);
  if (OK != status)
    goto exit;

  /* In a real app, it is possible to have several certs. This sample assumes a
   * P12 structure will contain only one cert. That is, we're going to have a
   * private key and its associated cert. But it is possible to have several
   * certs, such as a collection of CA and root certs, or even a key, its cert,
   * and the CA and root cert all in one bundle.
   * If you want to handle that possibility, you will have to write different
   * code than this sample.
   */
  if ( (CERT == type) && (X509 == extraInfo) )
  {
    if (NULL != pCertAndKey->pCert)
    {
      DIGI_FREE ((void **)&(pCertAndKey->pCert));
    }
    pCertAndKey->pCert = pBuffer;
    pCertAndKey->certLen = contentLen;
    pBuffer = NULL;
  }
  else if (KEYINFO == type)
  {
    if (NULL != pCertAndKey->pKey)
    {
      DIGI_FREE ((void **)&(pCertAndKey->pKey));
    }
    pCertAndKey->pKey = pBuffer;
    pCertAndKey->keyLen = contentLen;
    pBuffer = NULL;
  }
  else
  {
    status = ERR_NOT_IMPLEMENTED;
  }

exit:

  if (NULL != pBuffer)
  {
    DIGI_FREE ((void **)&pBuffer);
  }

  return (status);
}

#else /* __ENABLE_DIGICERT_PKCS12_CERT__ */

#if defined(__RTOS_WIN32__)

static TCHAR
WIN32_getch()
{
    DWORD mode, cc;
    TCHAR c = 0;
    HANDLE h = GetStdHandle (STD_INPUT_HANDLE);

    if (h == NULL)
    {
        return 0; /* Error */
    }
    GetConsoleMode (h, &mode);
    SetConsoleMode (h, mode & ~(ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT));

    ReadConsole (h, &c, 1, &cc, NULL);

    SetConsoleMode  (h, mode);
    return c;
}

static MSTATUS getPassword(
    ubyte *pBuffer,
    ubyte4 bufferLen,
    ubyte4 *pOutLen
    )
{
    ubyte4 i;
    int c = 0;

    printf ("Enter PEM pass phrase : ");

    i = 0;
    do
    {
        c = WIN32_getch();

        switch (c)
        {
            case 0x00:
                break;

            case 0x08:          /* backspace */
                if (i > 1)
                    --i;
                break;

            case 0x0D:
                break;

            default:
                if (c >= 20)
                {
                    if (i < bufferLen)
                    {
                        pBuffer[i++] = c;
                    }
                }
                break;
        }
    } while (c != 0x0D);

    printf("\n");

    *pOutLen = i;

    return OK;
}

#elif defined( __RTOS_LINUX__) || defined(__RTOS_VXWORKS__) || defined(__RTOS_CYGWIN__) || \
      defined(__RTOS_SOLARIS__) || defined(__RTOS_IRIX__) || defined(__RTOS_OPENBSD__) || \
      defined(__RTOS_ANDROID__) || defined(__RTOS_FREEBSD__) || defined(__RTOS_OSX__)

char *getpass(const char *);

static MSTATUS getPassword(
    ubyte *pBuffer,
    ubyte4 bufferLen,
    ubyte4 *pOutLen
    )
{
    MSTATUS status;
    sbyte *pPassword;
    ubyte4 passwordLen;

    *pOutLen = 0;

    /* The "getpass" function has been deprecated by GCC, however GCC
     * still has the implementation compiled into their libraries.
     * If this symbol is undefined during a build then it most likely
     * means that GCC has completely removed the function. In that case
     * the getpass function call should be updated.
     */
#ifdef __RTOS_ANDROID__
    pPassword = NULL;
#else
    pPassword = (sbyte *) getpass("Enter PEM pass phrase : ");
#endif

    status = ERR_NULL_POINTER;
    if (NULL == pPassword)
        goto exit;

    passwordLen = DIGI_STRLEN(pPassword);

    if (passwordLen > bufferLen)
        passwordLen = bufferLen;

    status = DIGI_MEMCPY(pBuffer, (ubyte *) pPassword, passwordLen);
    if (OK != status)
        goto exit;

    *pOutLen = passwordLen;

exit:

    if (pPassword)
    {
        DIGI_MEMSET((ubyte *)pPassword, 0, passwordLen);
    }
    return status;
}

#endif /* ifdef __RTOS_WIN32__ */
#endif /* if/else __ENABLE_DIGICERT_PKCS12_CERT__ */

#define MAX_LEN 1024
static sbyte4
initUpcallsAndCertStores()
{
    int i;
    certDescriptor certDesc = {0};
    certDescriptor certDescs[3] = {0};
    SizedBuffer* certificates = malloc(sizeof(SizedBuffer) * 3);
    ubyte4 numCerts = 1;
    MSTATUS status;
    char * fullpath = NULL;
    ubyte4 contentsLen;
    ubyte *pContents = NULL;
    ubyte* CACertData = NULL;
    ubyte4 CACertLength = 0;
    AsymmetricKey asymKey;
    /* Read PKCS8 , handle encryoted PEM */
#ifndef __ENABLE_DIGICERT_PKCS12_CERT__
    ubyte* pw = NULL;
    ubyte4 pwLen = 0;
    ubyte *pKeyBlob = NULL;
    ubyte4 keyBlobLength = 0;
#endif
    ubyte4 byteCount = 2048; /* bytes */
#ifdef __ENABLE_DIGICERT_SSL_REHANDSHAKE_EXAMPLE__
    ubyte4 timerCount = 3000; /* seconds */
#endif

#ifdef __ENABLE_DIGICERT_TAP__
    MocAsymKey  pMocAsymKey = NULL;
    ubyte* pBlob = NULL;
    ubyte4 blobLength = 0;

#endif

#if defined(__ENABLE_DIGICERT_PKCS12_CERT__)
    /* ubyte4 keyBlobLen; */
    ubyte pPassword[SAMPLE_PASSWORD_LEN] = {
        SAMPLE_PASSWORD
    };

    P12Content certAndKey = {
        NULL, 0, NULL, 0
    };

    ASN1_ITEMPTR pP12Item = NULL;
    CStream cStream;
    MemFile memFile;
#endif
    hwAccelDescr hwAccelCtx = 0;

    if (OK > (status = (MSTATUS)HARDWARE_ACCEL_OPEN_CHANNEL(MOCANA_SSL, &hwAccelCtx)))
    {
        goto exit;
    }

    SSL_Settings_Ioctl(SSL_SETTINGS_MAX_BYTE_COUNT, (void*)((uintptr)byteCount));
#if defined(__ENABLE_DIGICERT_TLS13__)
    SSL_setFuncPtrKeyUpdateRequest(SSL_EXAMPLE_keyUpdate);
#endif

#ifdef __ENABLE_DIGICERT_SSL_NEW_HANDSHAKE__
    SSL_sslSettings()->funcPtrNewHandshakeCallback = newHandShakeUpcall;
#endif

#ifdef __ENABLE_DIGICERT_SSL_REHANDSHAKE_EXAMPLE__
    SSL_Settings_Ioctl(SSL_SETTINGS_MAX_TIMER_COUNT, timerCount);

    SSL_setFuncPtrClientRehandshakeRequest(SSL_rehandshakeAlert);
#endif
#ifdef __ENABLE_DIGICERT_SSL_ALERTS__
    SSL_setFuncPtrAlertCallback(myAlertCallback);
#endif
#if defined( __ENABLE_DIGICERT_SSL_PSK_SUPPORT__) && !defined(__ENABLE_DIGICERT_TLS13__)
    SSL_setFuncPtrGetHintPSK(SSL_LOOPBACK2_EXAMPLE_funcPtrGetHintPSK);
    SSL_setFuncPtrLookupPSK(SSL_LOOPBACK2_EXAMPLE_funcPtrLookupPSK);
#endif

#if defined(__ENABLE_DIGICERT_TLS13__) && defined(__ENABLE_DIGICERT_TLS13_PSK__)
    SSL_setServerSavePSKCallback(SSL_EXAMPLE_funcPtrSavePSK);
    SSL_setServerLookupPSKCallback(SSL_EXAMPLE_funcPtrLookupPSKParams);
    SSL_setServerDeletePSKCallback(SSL_EXAMPLE_funcPtrDeletePSK);
    SSL_setFuncPtrGetHintPSK(SSL_LOOPBACK2_EXAMPLE_funcPtrGetHintPSK);
#endif

#ifdef __ENABLE_DIGICERT_SSL_SRP__
    SSL_setFuncPtrSRPCallback(SSL_EXAMPLE_SRPCallback);
#endif

#if 0
    /* Enable to Verify the application controlled SSL stack timer reset */
    SSL_sslSettings()->funcPtrSSLHandleTimeout   = SSL_EXAMPLE_resetTimer;
#endif

#if defined(__ENABLE_DIGICERT_PKCS12_CERT__)
    SSL_CERT_UTILS_getFullPath(ssls_KeyStore, ssls_ServerCert, &fullpath);
    if(NULL != fullpath)
    {

        if (OK > (status = DIGICERT_readFile(fullpath,
            &pContents, &contentsLen)))
        {
            myPrintStringError("initUpcallsAndCertStores::DIGICERT_readFile()::file ", fullpath);
            goto exit;
        }

        status = CRYPTO_initAsymmetricKey (&asymKey);
        if (OK != status)
            goto exit;
        /* For the P12 calls, we need to DER decode first.*/
        status = (MSTATUS)MF_attach (&memFile, contentsLen, pContents);
        if (OK != status)
            goto exit1;

        CS_AttachMemFile (&cStream, &memFile);

        status = ASN1_Parse (cStream, &pP12Item);
        if (OK != status)
            goto exit1;

        /* Call this function to read the P12 data.
         * The handler is what we're doing with the extracted data. In this case,
         * we're simply copying the data.
         */
        status = PKCS12_ExtractInfo (
        MOC_SYM(handle) MOC_ASYM(handle) pP12Item, cStream, (ubyte *)pPassword, 18,
            NULL, NULL, (void *)&certAndKey, SampleContentHandler);
        if (OK != status)
            goto exit1;

        /* From P12, we have the key data in DER format, but the key store needs it
         * as key blob.
         */
        if (NULL != certAndKey.pKey)
        {
            status = CRYPTO_deserializeAsymKey (
            certAndKey.pKey, certAndKey.keyLen, NULL, &asymKey);
            if (OK != status)
                goto exit1;
        }

        status = CRYPTO_serializeAsymKey(&asymKey, mocanaBlobVersion2, &certDesc.pKeyBlob, &certDesc.keyBlobLength);
        if (OK != status)
            goto exit1;
        /*status = CA_MGMT_convertPKCS8KeyToKeyBlob (
        certAndKey.pKey, certAndKey.keyLen, &pKeyBlob, &keyBlobLen);
        if (OK != status)
            goto exit;*/

        certificates[0].length = certAndKey.certLen;
        certificates[0].data = certAndKey.pCert;
        /*certDesc.pKeyBlob = pKeyBlob;
        certDesc.keyBlobLength = keyBlobLen;*/
exit1:
        CRYPTO_uninitAsymmetricKey(&asymKey, NULL);

        if (pP12Item)
            TREE_DeleteTreeItem((TreeItem *)pP12Item);
        if (OK > status)
            goto exit;

    }
#else /* not define __ENABLE_DIGICERT_PKCS12_CERT__ */
    SSL_CERT_UTILS_getFullPath(ssls_KeyStore, ssls_ServerCert, &fullpath);
    if(NULL != fullpath)
    {
#if defined(__ENABLE_DIGICERT_DATA_PROTECTION__)
        status = DPM_readSignedFile(fullpath, &(certDescs[0].pCertificate), &(certDescs[0].certLength), TRUE, DPM_CERTS);
#else
        status = DIGICERT_readFile(fullpath, &(certDescs[0].pCertificate), &(certDescs[0].certLength));
#endif
        if (OK > status)
        {
            myPrintStringError("initUpcallsAndCertStores::DIGICERT_readFile()::file ", fullpath);
	        goto exit;
        }
    }

    if (NULL != ssls_ServerChainIntCert)
    {
        SSL_CERT_UTILS_getFullPath(ssls_KeyStore, ssls_ServerChainIntCert, &fullpath);
        if(NULL != fullpath)
        {
    #if defined(__ENABLE_DIGICERT_DATA_PROTECTION__)
            status = DPM_readSignedFile(fullpath, &(certDescs[1].pCertificate), &(certDescs[1].certLength), TRUE, DPM_CERTS);
    #else
            status = DIGICERT_readFile(fullpath, &(certDescs[1].pCertificate), &(certDescs[1].certLength));
    #endif
            if (OK > status)
            {
                myPrintStringError("initUpcallsAndCertStores::DIGICERT_readFile()::file ", fullpath);
                goto exit;
            }
            numCerts++;
        }
    }

    if (NULL != ssls_ServerChainCaCert)
    {
        SSL_CERT_UTILS_getFullPath(ssls_KeyStore, ssls_ServerChainCaCert, &fullpath);
        if(NULL != fullpath)
        {
    #if defined(__ENABLE_DIGICERT_DATA_PROTECTION__)
            status = DPM_readSignedFile(fullpath, &(certDescs[numCerts].pCertificate), &(certDescs[numCerts].certLength), TRUE, DPM_CERTS);
    #else
            status = DIGICERT_readFile(fullpath, &(certDescs[numCerts].pCertificate), &(certDescs[numCerts].certLength));
    #endif
            if (OK > status)
            {
                myPrintStringError("initUpcallsAndCertStores::DIGICERT_readFile()::file ", fullpath);
                goto exit;
            }
            numCerts++;
        }
    }

    SSL_CERT_UTILS_getFullPath(ssls_KeyStore, ssls_ServerBlob, &fullpath);
    if(NULL != fullpath)
    {
#if (defined(__ENABLE_DIGICERT_TAP__) && !defined(__ENABLE_DIGICERT_TAP_EXTERN__))

        if (OK != (status = SSL_EXAMPLE_TAPInit(tap_ConfigFile,
                                                &g_pTapEntityCred,
                                                &g_pTapKeyCred)))
        {
            myPrintError("SSL_EXAMPLE_InitializeTapContext failed::status: ", status);
            goto exit;
        }

        if (OK > (status = CRYPTO_INTERFACE_registerTapCtxCallback((void *)&SSL_EXAMPLE_getTapContext)))
            goto exit;
#endif

#if defined(__ENABLE_DIGICERT_DATA_PROTECTION__)
        status = DIGICERT_readFileEx(fullpath, &pContents, &contentsLen, TRUE);
#else
        status = DIGICERT_readFile(fullpath, &pContents, &contentsLen);
#endif
        if (OK > status)
        {
            myPrintStringError("initUpcallsAndCertStores::DIGICERT_readFile()::file ", fullpath);
            goto exit;
        }

        status = CRYPTO_initAsymmetricKey (&asymKey);
        if (OK != status)
            goto exit;

        if (OK > (status = CRYPTO_deserializeAsymKey (
                MOC_ASYM(hwAccelCtx) pContents, contentsLen, NULL, &asymKey)))
        {

            /* Convert the PEM to DER before calling PKCS8 function */
            if ( OK > (status = CA_MGMT_decodeCertificate( pContents, contentsLen,
                                                            &pKeyBlob, &keyBlobLength)))
            {
                goto exit;
            }

            if (OK > (status = PKCS_getPKCS8KeyEx(MOC_HW(0) pKeyBlob, keyBlobLength, (ubyte*)"", 0, &asymKey)))
            {
                if (ERR_PKCS8_ENCRYPTED_KEY == status)
                {
                    if (OK > (status = DIGI_CALLOC((void**)&pw, 1, MAX_PASSWORD_SIZE)))
                    {
                        goto exit1;
                    }

                    /* Invoke the password callback. The callback will take care of casting the callback information
                     * into the appropriate type. Upon success the password should be placed in the buffer and
                     * the function should output the length of the password as well. If the operation failed then
                     * the output length should be 0 and the status should indicate the type of error that occured.
                     */
                    status = getPassword(pw, MAX_PASSWORD_SIZE, &pwLen);
                }
                if ( (OK != status) || (0 >= pwLen) )
                    goto exit1;

                if (OK > (status = PKCS_getPKCS8KeyEx(MOC_HW(0) pKeyBlob, keyBlobLength, pw, pwLen, &asymKey)))
                    goto exit1;
            }
        }
        if (OK > (status = CRYPTO_serializeAsymKey(MOC_ASYM(hwAccelCtx) &asymKey, mocanaBlobVersion2, &certDesc.pKeyBlob, &certDesc.keyBlobLength)))
        {
            goto exit1;
        }
exit1:
        CRYPTO_uninitAsymmetricKey(&asymKey, NULL);
        if (pw != NULL)
        {
            DIGI_MEMSET(pw, 0, pwLen);
            FREE(pw);
        }

        if (OK != status)
            goto exit;
    }

    i = 0;
    while (i < numCerts)
    {
        certificates[i].data = certDescs[i].pCertificate; certDescs[i].pCertificate = NULL;
        certificates[i].length = certDescs[i].certLength;
        i++;
    }

#endif /* End if else __ENABLE_DIGICERT_PKCS12_CERT__ */

    if (OK > (status = CERT_STORE_createStore(&pSslCertStore))) {
		goto exit;
     }

    if (OK > (status = CERT_STORE_addIdentityWithCertificateChain(
            pSslCertStore, certificates, numCerts, certDesc.pKeyBlob, certDesc.keyBlobLength))) {
        goto exit;
    }

    i = 0;
    while (i < numCerts)
    {
        if (NULL != certDescs[i].pCertificate)
        {
            FREE(certDescs[i].pCertificate); certDescs[i].pCertificate = 0;
        }

        if (NULL != certDescs[i].pKeyBlob)
        {
            FREE(certDescs[i].pKeyBlob); certDescs[i].pKeyBlob = 0;
        }
        i++;
    }

#if defined(__ENABLE_DIGICERT_PKCS12_CERT__)
    if (certAndKey.pCert != NULL)
    {
        DIGI_FREE((void **)&(certAndKey.pCert));
        certAndKey.certLen = 0;
    }

    if (certAndKey.pKey != NULL)
    {
        DIGI_FREE((void **)&(certAndKey.pKey));
        certAndKey.keyLen = 0;
    }

#endif

    if (ssls_CACert)
    {
        SSL_CERT_UTILS_getFullPath(ssls_KeyStore, ssls_CACert, &fullpath);
        if (NULL != fullpath)
        {
#if defined(__ENABLE_DIGICERT_DATA_PROTECTION__)
            status = DPM_readSignedFile(fullpath, &CACertData, &CACertLength, TRUE, DPM_CA_CERTS);
#else
            status = DIGICERT_readFile(fullpath, &CACertData, &CACertLength);
#endif
            if (OK > status)
            {
                myPrintStringError("initUpcallsAndCertStores::DIGICERT_readFile()::file ", fullpath);
                goto exit;
            }
#ifdef __ENABLE_DIGICERT_CV_CERT__
            if (0x7F == CACertData[0])
            {
                /* If the first byte is 0x7F, this could be a CV Cert. Try to add it as a
                * trustpoint. */
                status = CERT_STORE_CVC_addTrustPoint(pSslCertStore, CACertData, CACertLength);
                if (OK != status)
                {
                    myPrintError("initUpcallsAndCertStores::CERT_STORE_CVC_addTrustPoint::status ", status);
                    goto exit;
                }
            }
            else
#endif
            {

                if (OK > (status = CERT_STORE_addTrustPoint(pSslCertStore, CACertData, CACertLength)))
                {
                    myPrintError("initUpcallsAndCertStores::CERT_STORE_addTrustPoint::status: ", status);
                    goto exit;
                }
            }
        }

    }
    else
    {
        for (i = 0 ; i < COUNTOF(gRootCerts); ++i)
        {
          SSL_CERT_UTILS_getFullPath(ssls_KeyStore, gRootCerts[i].fileName, &fullpath);
            if(NULL != fullpath)
            {
                if (OK <= DIGICERT_readFile(fullpath,
                    &gRootCerts[i].certData, &gRootCerts[i].certLength))
                {
#ifdef __ENABLE_DIGICERT_CV_CERT__
                    if (0x7F == gRootCerts[i].certData[0])
                    {
                        /* If the first byte is 0x7F, this could be a CV Cert. Try to add it as a
                        * trustpoint. */
                        status = CERT_STORE_CVC_addTrustPoint(pSslCertStore, gRootCerts[i].certData, gRootCerts[i].certLength);
                        if (OK != status)
                        {
                            myPrintError("initUpcallsAndCertStores::CERT_STORE_CVC_addTrustPoint::status ", status);
                            goto exit;
                        }
                    }
                    else
#endif
                    {
                        if (OK > (status = CERT_STORE_addTrustPoint(pSslCertStore,
                                                                    gRootCerts[i].certData,
                                                                    gRootCerts[i].certLength)))
                        {

                            goto exit;
                        }
                    }
                }
                else
                {
                    myPrintStringError("initUpcallsAndCertStores::DIGICERT_readFile()::file ", fullpath);
                }
                if(gRootCerts[i].certData)
                    DIGI_FREE((void**)&gRootCerts[i].certData);
            }

        }
    }


exit:
	if (fullpath)
		FREE(fullpath);

    if (certDesc.pCertificate)
    {
        FREE(certDesc.pCertificate);
        certDesc.pCertificate = 0;
    }

    if (certDesc.pKeyBlob)
    {
        FREE(certDesc.pKeyBlob);
        certDesc.pKeyBlob = 0;
    }

    if (pContents)
    {
        DIGI_FREE((void **)&pContents);
    }

    if (CACertData)
    {
        DIGI_FREE((void **)&CACertData);
    }

#ifndef __ENABLE_DIGICERT_PKCS12_CERT__
    if (pKeyBlob)
        DIGI_FREE ((void**)&pKeyBlob);
#endif

    for (i = 0 ; i < COUNTOF(gRootCerts); ++i)
    {
        if(gRootCerts[i].certData)
            FREE(gRootCerts[i].certData);
    }

    if (certificates)
        CRYPTO_UTILS_freeCertificates(&certificates, numCerts);

#ifdef __ENABLE_DIGICERT_TAP__
    CRYPTO_uninitAsymmetricKey(&asymKey, NULL);

    if (pBlob)
    {
        DIGI_FREE((void **)&pBlob);
    }

#endif

    HARDWARE_ACCEL_CLOSE_CHANNEL(MOCANA_SSL, &hwAccelCtx);

    return status;
}

static sbyte4
uninitUpcallsAndCertStores()
{
    MSTATUS status;

    if (NULL != ssls_ServerName)
    {
        DIGI_FREE((void **)&ssls_ServerName);
    }
    if (NULL != ssls_KeyStore)
    {
        DIGI_FREE((void **)&ssls_KeyStore);
    }
    if (NULL != ssls_ServerCert)
    {
        DIGI_FREE((void **)&ssls_ServerCert);
    }
    if (NULL != ssls_ServerChainIntCert)
    {
        DIGI_FREE((void **)&ssls_ServerChainIntCert);
    }
    if (NULL != ssls_ServerChainCaCert)
    {
        DIGI_FREE((void **)&ssls_ServerChainCaCert);
    }
    if (NULL != ssls_ServerBlob)
    {
        DIGI_FREE((void **)&ssls_ServerBlob);
    }
#ifdef __ENABLE_DIGICERT_SSL_MUTUAL_AUTH_SUPPORT_EXAMPLE__
    if (NULL != ssls_CACert)
    {
        DIGI_FREE((void **)&ssls_CACert);
    }
#endif

    if (OK > (status = SSL_CERT_UTILS_releaseCertificateInfos()))
   	{
    	goto exit;
    }
   	if (OK > (status = CERT_STORE_releaseStore(&pSslCertStore)))
   	{
    	goto exit;
    }

 exit:
    return status;
}

#if (defined(__ENABLE_DIGICERT_TAP__))
static void uninitTAP()
{
    MSTATUS status;
    TAP_ErrorContext *pErrContext = NULL;
#if (defined(__ENABLE_DIGICERT_TAP_REMOTE__))
    if (NULL != taps_ServerName)
    {
        DIGI_FREE((void **)&taps_ServerName);
    }
#endif
    if (NULL != tap_ConfigFile)
    {
        DIGI_FREE((void **)&tap_ConfigFile);
    }

    /* Free module list */
    status = TAP_freeModuleList(&g_moduleList);
    if (OK != status)
        printf("TAP_freeModuleList : %d\n", status);

    if (g_pTapEntityCred)
    {
        TAP_UTILS_clearEntityCredentialList(g_pTapEntityCred);
        DIGI_FREE((void **)&g_pTapEntityCred);
    }

    if (g_pTapKeyCred)
    {
        TAP_UTILS_clearCredentialList(g_pTapKeyCred);
        DIGI_FREE((void **)&g_pTapKeyCred);
    }

#if defined(__ENABLE_DIGICERT_TAP_DEFER_UNLOADKEY__)
    (void) SSL_TAP_clearKeyAndToken();
#endif

    (void) SSL_EXAMPLE_clearTAPContext();

    TAP_uninit(pErrContext);
}
#endif

/*------------------------------------------------------------------*/
static
void setFilePath(sbyte *path, sbyte **fname)
{
   sbyte *fullPath;
   ubyte4 fullPathLen;

   if ((*fname == NULL) || (path == NULL)) {
      return;
   }

   fullPathLen = DIGI_STRLEN(path) + DIGI_STRLEN(*fname) + 2; /* +2 for file seperator and ending null */
   if (NULL == (fullPath = MALLOC(fullPathLen)))
       return;
   (void) DIGI_MEMCPY(fullPath, path, DIGI_STRLEN(path));
   fullPath[DIGI_STRLEN(path)] = DEF_FILESEP;
   (void) DIGI_MEMCPY(&fullPath[DIGI_STRLEN(path) + 1], *fname, DIGI_STRLEN(*fname));

   fullPath[fullPathLen - 1] = '\0';
   *fname = fullPath;
}

/*------------------------------------------------------------------*/
void
setStringParameter(char** param, char* value)
{
	*param = MALLOC((DIGI_STRLEN((const sbyte *)value))+1);
        if (NULL == *param)
            return;
	(void) DIGI_MEMCPY(*param, value, DIGI_STRLEN((const sbyte *)value));
	(*param)[DIGI_STRLEN((const sbyte *)value)] = '\0';
}

/*------------------------------------------------------------------*/

static void
SSL_EXAMPLE_displayHelp(char *prog)
{

	(void) printf(" Usage: %s\n", prog);
	(void) printf(" <options>\n");
	(void) printf("  options:\n");
	(void) printf("    -h | ?                             Help\n");
	(void) printf("    -ssl_port <port>                   SSL server port\n");
	(void) printf("    -ssl_servername <server_name>      SSL server name\n");
	(void) printf("    -ssl_certpath <path_to_files>      directory path to the cert files\n");
	(void) printf("    -ssl_server_cert <cert_name>       name of the server cert \n");
	(void) printf("    -ssl_server_chain_ca <cert_name>   name of the server root CA cert\n");
	(void) printf("    -ssl_server_chain_int <cert_name>  name of the server intermediate CA cert\n");
	(void) printf("    -ssl_server_keyblob <blob_name>    name of the server keyblob\n");
#ifdef __ENABLE_DIGICERT_SSL_MUTUAL_AUTH_SUPPORT_EXAMPLE__
	(void) printf("    -ssl_ca_cert <cert_name>           name of the CA cert \n");
#endif
#if defined(__ENABLE_DIGICERT_TLS13__) && defined(__ENABLE_DIGICERT_TLS13_PSK__)
	(void) printf("    -ssl_external_psk                     specifies to use an external PSK for TLS 1.3\n");
#ifdef __ENABLE_DIGICERT_TLS13_0RTT__
    (void) printf("    -ssl_max_early_data_size  <size>      specifies the max allowed early data size\n");
#endif
#endif
#if (defined(__ENABLE_DIGICERT_TAP__))
#if (defined(__ENABLE_DIGICERT_TAP_REMOTE__))
	(void) printf("    -tap_server_port <tap_server_port> TAP server port\n");
	(void) printf("    -tap_server_name <tap_server_name> TAP server name\n");
#endif
	(void) printf("    -tap_keysource <TPM2|TPM1.2|PKCS11> key source\n");
	(void) printf("    -tap_config_file <tap_config_file> TAP config file\n");
#endif
    (void) printf("\n");
} /* SSL_EXAMPLE_displayHelp */


/*------------------------------------------------------------------*/

extern sbyte4
SSL_EXAMPLE_getArgs(int argc, char *argv[])
{
	sbyte4 status = 0;
	int i;
	char *temp;

	int portSet=0, keyStoreSet=0, serverCertSet=0, serverBlobSet=0;
	int serverNameSet=0;

#if (defined(__ENABLE_DIGICERT_TAP__))
    int tapConfigFileSet = 0;
    int keySourceSet=0;
#if (defined(__ENABLE_DIGICERT_TAP_REMOTE__))
    int tapServerNameSet = 0;
    int tapServerPortSet = 0;
#endif
#endif

    if ((2 <= argc) && (('?' == argv[1][0]) || (('-' == argv[1][0]) && ('h' == argv[1][1]))))
    {
        SSL_EXAMPLE_displayHelp(argv[0]);
        return -1;
    }


#ifdef __ENABLE_DIGICERT_DEBUG_CONSOLE__
/*	myPrintIntNL("Argc= ", argc);   */
/*	for (i = 0; i < argc; i++) {    */
/*		myPrintInt("Argv[", i); */
/*		myPrintStringNL("]= ", argv[i]); */
/*	}  */
#endif

	ssls_getArgs_called++;
	for (i = 1; i < argc; i++)
	{
		if (DIGI_STRCMP((const sbyte *)argv[i], (const sbyte *)"-ssl_port") == 0)
		{
			if (++i < argc)
			{
				temp = argv[i];
				ssls_ServerPort = (unsigned short) DIGI_ATOL((const sbyte *)temp,NULL);
				portSet = 1;
			}
			continue;
		}
		else if (DIGI_STRCMP((const sbyte *)argv[i], (const sbyte *)"-ssl_servername") == 0)
		{
			{
				if (++i < argc)
				{
					setStringParameter(&ssls_ServerName, argv[i]);
					serverNameSet = 1;
				}
				continue;
			}
		}
		else if (DIGI_STRCMP((const sbyte *)argv[i], (const sbyte *)"-ssl_certpath") == 0)
		{
			{
				if (++i < argc)
				{
					setStringParameter(&ssls_KeyStore, argv[i]);
					keyStoreSet = 1;
				}
				continue;
			}
		}
		else if (DIGI_STRCMP((const sbyte *)argv[i], (const sbyte *)"-ssl_server_cert") == 0)
		{
			{
				if (++i < argc)
				{
					setStringParameter(&ssls_ServerCert, argv[i]);
					serverCertSet = 1;
				}
				continue;
			}
		}
		else if (DIGI_STRCMP((const sbyte *)argv[i], (const sbyte *)"-ssl_server_chain_int") == 0)
		{
			{
				if (++i < argc)
				{
					setStringParameter(&ssls_ServerChainIntCert, argv[i]);
					serverCertSet = 1;
				}
				continue;
			}
		}
		else if (DIGI_STRCMP((const sbyte *)argv[i], (const sbyte *)"-ssl_server_chain_ca") == 0)
		{
			{
				if (++i < argc)
				{
					setStringParameter(&ssls_ServerChainCaCert, argv[i]);
					serverCertSet = 1;
				}
				continue;
			}
		}
        else if (DIGI_STRCMP((const sbyte *)argv[i], (const sbyte *)"-ssl_server_keyblob") == 0)
		{
			{
				if (++i < argc)
				{
					setStringParameter(&ssls_ServerBlob, argv[i]);
					serverBlobSet = 1;
				}
				continue;
			}
		}
#ifdef __ENABLE_DIGICERT_SSL_MUTUAL_AUTH_SUPPORT_EXAMPLE__
		else if (DIGI_STRCMP((const sbyte *)argv[i], (const sbyte *)"-ssl_ca_cert") == 0)
		{
			{
				if (++i < argc)
				{
					setStringParameter(&ssls_CACert, argv[i]);
				}
				continue;
			}
		}
#endif
#if defined(__ENABLE_DIGICERT_TLS13__) && defined(__ENABLE_DIGICERT_TLS13_PSK__)
        else if (DIGI_STRCMP((const sbyte *)argv[i], (const sbyte *)"-ssl_external_psk") == 0)
        {
            {
                ssls_useExternalPsk = TRUE;
                continue;
            }
        }
#ifdef __ENABLE_DIGICERT_TLS13_0RTT__
        else if (DIGI_STRCMP((const sbyte *)argv[i], (const sbyte *)"-ssl_max_early_data_size") == 0)
        {
            {
                if (++i < argc)
                {
                    ssls_maxEarlyDataSize = atoi(argv[i]);
                }
                continue;
            }
        }
#endif
#endif
#if (defined(__ENABLE_DIGICERT_TAP__))
#if (defined(__ENABLE_DIGICERT_TAP_REMOTE__))
		else if (DIGI_STRCMP((const sbyte *)argv[i], (const sbyte *)"-tap_server_name") == 0)
		{
			{
				if (++i < argc)
				{
					setStringParameter(&taps_ServerName, argv[i]);
					tapServerNameSet = 1;
				}
				continue;
			}
		}
        else if (DIGI_STRCMP((const sbyte *)argv[i], (const sbyte *)"-tap_server_port") == 0)
		{
			if (++i < argc)
			{
				temp = argv[i];
				taps_ServerPort = (unsigned short) DIGI_ATOL((const sbyte *)temp,NULL);
				tapServerPortSet = 1;
			}
			continue;
		}
#endif
        else if (DIGI_STRCMP((const sbyte *)argv[i], (const sbyte *)"-tap_keysource") == 0)
        {
            if (++i < argc)
            {
                setStringParameter((char**)&tap_keySource, argv[i]);
                keySourceSet = 1;
            }
            continue;
        }
        else if (DIGI_STRCMP((const sbyte *)argv[i], (const sbyte *)"-tap_config_file") == 0)
		{
			{
				if (++i < argc)
				{
					setStringParameter(&tap_ConfigFile, argv[i]);
					tapConfigFileSet = 1;
				}
				continue;
			}
		}
#endif
	}

	/*Set defaults if nothing entered from command line*/
	if (!portSet)
	{
		ssls_ServerPort = SSLS_DEF_PORT;
	}
	if (!serverNameSet)
	{
		setStringParameter(&ssls_ServerName, SSLS_DEF_SERVERNAME);
	}
	if (!keyStoreSet)
	{
		setStringParameter(&ssls_KeyStore, SSLS_DEF_KEYSTORE);
	}
	if (!serverCertSet)
	{
		setStringParameter(&ssls_ServerCert, SSLS_DEF_SERVERCERT);
	}
	if (!serverBlobSet)
	{
		setStringParameter(&ssls_ServerBlob, SSLS_DEF_SERVERBLOB);
	}
#if (defined(__ENABLE_DIGICERT_TAP__))
#if (defined(__ENABLE_DIGICERT_TAP_REMOTE__))
    if (!tapServerNameSet)
    {
    	myPrintNL("Mandatory argument tap_server_name NOT set");
        status = ERR_SSL;
    }
    if (!tapServerPortSet)
    {
    	myPrintNL("Mandatory argument tap_server_port NOT set");
        status = ERR_SSL;
    }
#endif
    if (!keySourceSet)
    {
        setStringParameter((char**)&tap_keySource, DEF_TAP_KEYSOURCE);
    }
    if (!tapConfigFileSet)
    {
        setStringParameter(&tap_ConfigFile, TPM2_CONFIGURATION_FILE);
    }
    if(DIGI_STRCMP((const sbyte *)tap_keySource, (const sbyte *)"TPM2") == 0)
    {
        ssls_TapProvider = TAP_PROVIDER_TPM2;
    }
    else if(DIGI_STRCMP((const sbyte *)tap_keySource, (const sbyte *)"PKCS11") == 0)
    {
        ssls_TapProvider = TAP_PROVIDER_PKCS11;
    }
    else
    {
        status = ERR_TAP_NO_PROVIDERS_AVAILABLE;
    }
#endif
    return status;
}

/* This is only for build the SSL client using Microsoft Visual Studio project */
#ifdef __ENABLE_DIGICERT_WIN_STUDIO_BUILD__
int main(int argc, char *argv[])
{
	void* dummy = NULL;
#else
extern int
SSL_EXAMPLE_main(void* dummy)
{
#endif

	MSTATUS	status;
	sbyte4 ret;

        /* assign unused parameter to not used variable */
        MOC_UNUSED(dummy);

#ifdef __ENABLE_DIGICERT_MEM_PART__
    if (NULL != gMemPartDescr)
    {
        /* make sure it's thread-safe! */
        MEM_PART_enableMutexGuard(gMemPartDescr);
    }
#endif

#ifdef __ENABLE_DIGICERT_WIN_STUDIO_BUILD__
	if (OK > ( status = (MSTATUS) SSL_EXAMPLE_getArgs(argc, argv))) /* Initialize parameters to default values */
		return (int) status;
#endif

#ifdef __ENABLE_DIGICERT_DEBUG_CONSOLE__
	myPrintNL("Entering SSL_EXAMPLE_main...");
	myPrintIntNL("ssls_ServerPort: ", ssls_ServerPort);
	myPrintStringNL("ssls_ServerName: ", ssls_ServerName);
	myPrintStringNL("ssls_KeyStore: ", ssls_KeyStore);
	myPrintStringNL("ssls_ServerCert: ", ssls_ServerCert);
	myPrintStringNL("ssls_ServerChainIntCert: ", ssls_ServerChainIntCert);
	myPrintStringNL("ssls_ServerChainCaCert: ", ssls_ServerChainCaCert);
	myPrintStringNL("ssls_ServerBlob: ", ssls_ServerBlob);
#endif

#if defined(__ENABLE_DIGICERT_WIN_STUDIO_BUILD__) && !defined(__DISABLE_DIGICERT_INIT__)
	if (OK > (status = DIGICERT_initDigicert()))
      goto exit;
#endif

	gMocanaAppsRunning++; /* key generation can take time */

	if (OK > (status = (MSTATUS) SSL_init(MAX_SSL_CONNECTIONS_ALLOWED, MAX_SSL_CONNECTIONS_ALLOWED)))
		goto exit;

	if (OK > (status = SSL_CERT_UTILS_populateCertificateDir(ssls_KeyStore)))
	{
        if (status != ERR_FILE_EXISTS)
        {
		  myPrintError("SSL_CERT_UTILS_populateCertificateStore::status: ", status);
		  goto exit;
		}
		 else
		{
		   goto init_store;
		}
	}

	if (OK > (status = SSL_CERT_UTILS_releaseCertificateInfos()))
	{
		myPrintError("SSL_CERT_UTILS_releaseCertificateInfos::status: ", status);
		goto exit;
	}

init_store:

	if (OK > (status = (MSTATUS) initUpcallsAndCertStores()))
	{
		myPrintError("initUpcallsAndCertStores::status: ", status);
		goto exit;
	}

	/* change default settings here */
	if (OK > (status = (MSTATUS) SSL_EXAMPLE_startFakeServer(ssls_ServerPort)))
	{
		myPrintError("SSL_EXAMPLE_startFakeServer::status: ", status);
	}

	 /* in your design, you will want to wait for upper layer to signal it's dead */
	 RTOS_sleepMS(2000);

exit:
	if (OK > (ret = uninitUpcallsAndCertStores()))
	{
		myPrintError("uninitUpcallsAndCertStores::ret: ", ret);
	}
#if defined(__ENABLE_DIGICERT_TAP__)
    uninitTAP();
#endif
/* Incase of TAP Remoting enabled - SSL Init is already invoked by TAP Client */
#ifndef __ENABLE_DIGICERT_TAP_REMOTE__

	if (OK > (ret = SSL_shutdownStack()))
	{
		myPrintError("SSL_shutdownStack::status: ", ret);
	}
#endif


	myPrintIntNL("SSL_EXAMPLE: ret: ", ret);
	myPrintIntNL("SSL_EXAMPLE: status: ", status);

#if (defined(__ENABLE_DIGICERT_TLS13__) && defined(__ENABLE_DIGICERT_TLS13_PSK__))
    (void) DIGI_FREE((void **)&g_pPSK);
    (void) DIGI_FREE((void **)&g_pPSKIdentity);
#endif
    (void) DIGI_FREE((void **)&ssls_ServerName);
	(void) DIGI_FREE((void **)&ssls_KeyStore);
	(void) DIGI_FREE((void **)&ssls_ServerCert);
	(void) DIGI_FREE((void **)&ssls_ServerChainIntCert);
	(void) DIGI_FREE((void **)&ssls_ServerChainCaCert);
	(void) DIGI_FREE((void **)&ssls_ServerBlob);
	(void) DIGI_FREE((void **)&ssls_CACert);
#if (defined(__ENABLE_DIGICERT_TAP__))
    if (tap_keySource != NULL) {
        FREE(tap_keySource);
        tap_keySource = NULL;
    }
#endif

	gMocanaAppsRunning--;

	return status;
}

#endif /* __ENABLE_DIGICERT_SSL_SERVER__ */
#endif /* __ENABLE_DIGICERT_EXAMPLES__ */

#endif /*(defined( __ENABLE_DIGICERT_SSL_SERVER__ ) && !defined( __ENABLE_DIGICERT_SSL_ASYNC_SERVER_API__ )) || defined(__DISABLE_DIGICERT_AUTO_EXAMPLES__) */
#endif /* !defined(__ENABLE_DIGICERT_SSL_CLIENT_EXAMPLE__) */
