/**
 * @file fapi2_credential.c
 * @brief This file contains code and structures required to implement the TPM2 privacy CA
 * credential activation protocol.
 *
 * @flags
 *  To enable this file's functions, the following flags must be defined in
 * moptions.h:
 *
 *  + \c \__ENABLE_DIGICERT_TPM2__
 *
 * Copyright 2025 DigiCert Project Authors. All Rights Reserved.
 * 
 * DigiCert® TrustCore and TrustEdge are licensed under a dual-license model:
 * - **Open Source License**: GNU AGPL v3. See: https://github.com/digicert/trustcore-test/blob/main/LICENSE
 * - **Commercial License**: Available under DigiCert’s Master Services Agreement. See: https://github.com/digicert/trustcore-test/blob/main/LICENSE_COMMERCIAL.txt  
 *   or https://www.digicert.com/master-services-agreement/
 * 
 * *For commercial licensing, contact DigiCert at sales@digicert.com.*
 *
 */
#include "../../../../common/moptions.h"

#if (defined(__ENABLE_DIGICERT_TPM2__))
#include "../../../../common/mtypes.h"
#include "../../../../common/merrors.h"
#include "../../../../common/mocana.h"
#include "../../../../common/mdefs.h"
#include "../../../../common/mstdlib.h"
#include "../../../../crypto/hw_accel.h"
#include "../../../../common/base64.h"
#include "../../../../common/debug_console.h"
#include "../tpm_common/tpm_error_utils.h"
#include "fapi2_credential.h"
#include "fapi2.h"
#include "fapi2_internal.h"

/*
 * This API is used as a part of the TPM specification credential protection protocol,
 * to activate a credential supplied by a CA. Activation of a credential typically means
 * a successful unwrapping of a symmetric key that was used by the CA to wrap a certificate.
 * The secret can only be unwrapped if the TPM has the asymmetric encryption key and the key
 * for which the credential applies, loaded inside the TPM.
 * See TPM2 specs for more details on the credential protection protocol.
 * Make and active API's dont check to see if the decryption key is a fixed TPM key and
 * if the private portion was actually generated by the TPM. This is a policy decision
 * to be made by the credential provider. This API, supports activating a credential for
 * virtually any key. The only restriction it places is that the keys cannot be external
 * keys and that the encryption key(EK) is a storage key. These are essentially the minimum
 * rules enforced by the TPM so we check it in software to avoid having to go to the TPM
 * in case these rules are violated.
 */
TSS2_RC FAPI2_CREDENTIAL_activate(
        FAPI2_CONTEXT *pCtx,
        CredentialActivateIn *pIn,
        CredentialActivateOut *pOut
)
{
    TSS2_RC rc = TSS2_SYS_RC_GENERAL_FAILURE;
    TSS2_RC exit_rc = TSS2_RC_SUCCESS;
    FAPI2_OBJECT *pActivateKey = NULL;
    FAPI2_OBJECT *pDecryptKey = NULL;
    TPMT_PUBLIC *pActivatePublic = NULL;
    TPMT_PUBLIC *pDecryptPublic = NULL;
    ActivateCredentialIn activateIn = { 0 };
    ActivateCredentialOut activateOut = { 0 };
    MOCTPM2_OBJECT_HANDLE *pActivateKeyHandle = NULL;
    MOCTPM2_OBJECT_HANDLE *pActivateAuthSession = NULL;
    MOCTPM2_OBJECT_HANDLE *pDecryptKeyHandle = NULL;
    MOCTPM2_OBJECT_HANDLE *pDecryptAuthSession = NULL;
    ContextFlushObjectIn flushObjectIn = { 0 };

    if (!pCtx || !pIn || !pOut)
    {
        rc = TSS2_SYS_RC_BAD_REFERENCE;
        DB_PRINT("%s.%d Invalid pointer inputs, rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    TPM2B_SIZE_CHECK(&pIn->activateKey, TPM2B_MAX_SIZE(&pIn->activateKey));
    TPM2B_SIZE_CHECK(&pIn->decryptKey, TPM2B_MAX_SIZE(&pIn->decryptKey));
    TPM2B_SIZE_CHECK(&pIn->secretBlob, TPM2B_MAX_SIZE(&pIn->secretBlob));
    TPM2B_SIZE_CHECK(&pIn->encryptedSeed, TPM2B_MAX_SIZE(&pIn->encryptedSeed));

    rc = FAPI2_CONTEXT_lookupObject(pCtx, &pIn->activateKey, &pActivateKey);
    if (TSS2_RC_SUCCESS != rc)
    {
        DB_PRINT("%s.%d Unable to find activate key object, rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    rc = FAPI2_CONTEXT_lookupObject(pCtx, &pIn->decryptKey, &pDecryptKey);
    if (TSS2_RC_SUCCESS != rc)
    {
        DB_PRINT("%s.%d Unable to find decrypt key object, rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    if ((pActivateKey->authValueRequired) && (!pActivateKey->authValueValid))
    {
        rc = TSS2_FAPI_RC_NOT_PERMITTED;
        DB_PRINT("%s.%d Activate Key does not have authValue set, rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    if ((pDecryptKey->authValueRequired) && (!pDecryptKey->authValueValid))
    {
        rc = TSS2_FAPI_RC_NOT_PERMITTED;
        DB_PRINT("%s.%d Decrypt Key does not have authValue set, rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    /*
     * Decrypt key cannot be external, since it is must be a restricted decryption key
     * which can only be created inside the TPM.
     * Activate key can be external, but MUST NOT be. Ideally, a CA would never issue
     * a key that is not fixedTpm and not restricted. FAPI also creates attestation keys
     * as restricted signing keys and external keys cannot be an attestation key.
     * Therefore, we disallow activating credentials for external keys. This should really
     * never happen.
     */
    if (pActivateKey->isExternal || pDecryptKey->isExternal)
    {
        rc = TSS2_FAPI_RC_NOT_PERMITTED;
        DB_PRINT("%s.%d External keys cannot be used for credential activation, rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    pActivatePublic = &pActivateKey->public.objectPublic.publicArea;
    pDecryptPublic = &pDecryptKey->public.objectPublic.publicArea;

    /*
     * Decrypt key must be a restricted decryption key.
     */
    if (!(pDecryptPublic->objectAttributes & TPMA_OBJECT_RESTRICTED) ||
            !(pDecryptPublic->objectAttributes & TPMA_OBJECT_DECRYPT))
    {
        rc = TSS2_FAPI_RC_NOT_PERMITTED;
        DB_PRINT("%s.%d Decrypt Key is not a restricted decryption key, rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    if ((pActivatePublic->type != TPM2_ALG_RSA) && (pActivatePublic->type != TPM2_ALG_ECC))
    {
        rc = TSS2_SYS_RC_BAD_VALUE;
        DB_PRINT("%s.%d Activate Key type not ECC or RSA., rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    if ((pDecryptPublic->type != TPM2_ALG_RSA) && (pDecryptPublic->type != TPM2_ALG_ECC))
    {
        rc = TSS2_SYS_RC_BAD_VALUE;
        DB_PRINT("%s.%d Decrypt Key type not ECC or RSA., rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    /*
     * Create handle for the Activate key. This will load the key into the TPM, if needed.
     */

    rc = FAPI2_UTILS_loadObjectTree(pCtx, pActivateKey, &pActivateKeyHandle);
    if (TSS2_RC_SUCCESS != rc)
    {
        DB_PRINT("%s.%d Failed to create handle for activate key."
                ", rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    /*
     * Create handle for the decrypt key. This will load the key into the TPM, if needed.
     */
    rc = FAPI2_UTILS_loadObjectTree(pCtx, pDecryptKey, &pDecryptKeyHandle);
    if (TSS2_RC_SUCCESS != rc)
    {
        DB_PRINT("%s.%d Failed to create handle for decrypt key."
                ", rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    /*
     * Since the authRole for the activate handle is admin role, we use a regular
     * HMAC session. Using a policy session requires the inclusion of TPM2_PolicyCommandCode
     * term and has not yet been implemented.
     */
    rc = FAPI2_UTILS_startSession(pCtx, &pActivateAuthSession);
    if (TSS2_RC_SUCCESS != rc)
    {
        DB_PRINT("%s.%d Failed to Start session."
                ", rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    rc = FAPI2_UTILS_getObjectAuthSession(pCtx, pDecryptKey, &pDecryptAuthSession);
    if (TSS2_RC_SUCCESS != rc)
    {
        DB_PRINT("%s.%d Failed to Start session."
                ", rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    activateIn.pActivateHandle = pActivateKeyHandle;
    activateIn.pAuthActivateHandle = &pActivateKey->authValue;
    activateIn.pAuthSessionActivateHandle = pActivateAuthSession;
    activateIn.pKeyHandle = pDecryptKeyHandle;
    activateIn.pAuthKeyHandle = &pDecryptKey->authValue;
    activateIn.pAuthSessionKeyHandle = pDecryptAuthSession;
    activateIn.pCredentialBlob = &pIn->secretBlob;
    activateIn.pSecret = &pIn->encryptedSeed;

    rc = SAPI2_OBJECT_ActivateCredential(pCtx->pSapiCtx, &activateIn, &activateOut);
    if (TSS2_RC_SUCCESS != rc)
    {
        DB_PRINT("%s.%d Failed to Activate Credential."
                ", rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    pOut->secret = activateOut.certInfo;

    rc = TSS2_RC_SUCCESS;
exit:
    if (pActivateAuthSession)
    {
        exit_rc = FAPI2_UTILS_closeSession(pCtx,
                &pActivateAuthSession);
        if (TSS2_RC_SUCCESS == rc)
            rc = exit_rc;
    }

    if (pDecryptAuthSession)
    {
        exit_rc = FAPI2_UTILS_closeSession(pCtx,
                &pDecryptAuthSession);
        if (TSS2_RC_SUCCESS == rc)
            rc = exit_rc;
    }

    if (pActivateKeyHandle)
    {
        exit_rc = FAPI2_UTILS_destroyHandle(pCtx, &pActivateKeyHandle);
        if (TSS2_RC_SUCCESS == rc)
            rc = exit_rc;
    }

    if (pDecryptKeyHandle)
    {
        exit_rc = FAPI2_UTILS_destroyHandle(pCtx, &pDecryptKeyHandle);
        if (TSS2_RC_SUCCESS == rc)
            rc = exit_rc;
    }

    if (pActivateKey)
    {
        flushObjectIn.objName = pActivateKey->objectName;
        exit_rc = FAPI2_CONTEXT_flushObject(pCtx, &flushObjectIn);
        if (TSS2_RC_SUCCESS == rc)
            rc = exit_rc;
    }

    if (pDecryptKey)
    {
        flushObjectIn.objName = pDecryptKey->objectName;
        exit_rc = FAPI2_CONTEXT_flushObject(pCtx, &flushObjectIn);
    }

    if (TSS2_RC_SUCCESS == rc)
        rc = exit_rc;

    return rc;
}

/*
 * This is a helper API that can be used by a credential provider(that has TPM hardware/emulator),
 * to create a credential blob per the credential protection protocol, that can only
 * be decrypted by the TPM to which the secret is wrapped. The typical use for this
 * API is on a CA server that has a TPM or a TPM emulator and does not want to
 * implement the credential creation protocol, since it is already available on the
 * TPM. This is also useful for testing the make/activate credential protocol.
 * See TPM2 specs for more details on the credential protection protocol.
 * This API requires a context since it uses the TPM directly to create the credential blob.
 * Make and active API's dont check to see if the decryption key is a fixed TPM key and
 * if the private portion was actually generated by the TPM. This is a policy decision
 * to be made by the credential provider. This API, supports activating a credential for
 * virtually any key. The only restriction it places is that the keys cannot be external
 * keys and that the encryption key(EK) is a storage key. These are essentially the minimum
 * rules enforced by the TPM so we check it in software to avoid having to go to the TPM
 * in case these rules are violated.
 */
TSS2_RC FAPI2_CREDENTIAL_make(
        FAPI2_CONTEXT *pCtx,
        CredentialMakeIn *pIn,
        CredentialMakeOut *pOut
)
{
    TSS2_RC rc = TSS2_SYS_RC_GENERAL_FAILURE;
    TSS2_RC exit_rc = TSS2_RC_SUCCESS;
    MakeCredentialIn makeIn = { 0 };
    MakeCredentialOut makeOut = { 0 };
    FAPI2_OBJECT *pKey = NULL;
    MOCTPM2_OBJECT_HANDLE *pKeyHandle = NULL;
    ContextFlushObjectIn flushObjectIn = { 0 };

    if (!pCtx || !pIn || !pOut)
    {
        rc = TSS2_SYS_RC_BAD_REFERENCE;
        DB_PRINT("%s.%d Invalid pointer inputs, rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    TPM2B_SIZE_CHECK(&pIn->activateKeyName, TPM2B_MAX_SIZE(&pIn->activateKeyName));
    TPM2B_SIZE_CHECK(&pIn->encryptKey, TPM2B_MAX_SIZE(&pIn->encryptKey));
    TPM2B_SIZE_CHECK(&pIn->secret, TPM2B_MAX_SIZE(&pIn->secret));

    rc = FAPI2_CONTEXT_lookupObject(pCtx, &pIn->encryptKey, &pKey);
    if (TSS2_RC_SUCCESS != rc)
    {
        DB_PRINT("%s.%d Unable to find key object, rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    /*
     * Create handle for the key. This will load the key into the TPM, if needed.
     */
    rc = FAPI2_UTILS_loadObjectTree(pCtx, pKey, &pKeyHandle);
    if (TSS2_RC_SUCCESS != rc)
    {
        DB_PRINT("%s.%d Failed to create handle for activate key."
                ", rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    makeIn.pCredential = &pIn->secret;
    makeIn.pName = &pIn->activateKeyName;
    makeIn.pObjectHandle = pKeyHandle;

    rc = SAPI2_OBJECT_MakeCredential(pCtx->pSapiCtx, &makeIn, &makeOut);
    if (TSS2_RC_SUCCESS != rc)
    {
        DB_PRINT("%s.%d Failed to make credential, rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    pOut->encryptedSeed = makeOut.secret;
    pOut->secretBlob = makeOut.credentialBlob;

    rc = TSS2_RC_SUCCESS;
exit:
    if (pKeyHandle)
    {
        exit_rc = FAPI2_UTILS_destroyHandle(pCtx, &pKeyHandle);
        if (TSS2_RC_SUCCESS == rc)
            rc = exit_rc;
    }

    if (pKey)
    {
        flushObjectIn.objName = pKey->objectName;
        exit_rc = FAPI2_CONTEXT_flushObject(pCtx, &flushObjectIn);
    }

    if (TSS2_RC_SUCCESS == rc)
        rc = exit_rc;

    return rc;
}

/*
 * This API is used in the privacy CA protocol of generating and activating a credential
 * for a TPM key. This returns a base 64 encoded blob of data that contains the public
 * attributes of an encryption key(EK) and of the key for which the credential is being
 * requested for. The blob is then used by the credential provider(typically privacy CA)
 * to determine if a credential can be provided for the given key. The format of the blob
 * is specific to Mocana and is not a TCG standard. The blob is consumed by a companion
 * library, that may be used on the server, to unwrap and use the blob.
 * This API is restrictive in what keys it allows the blob to be created for, ie: it
 * expects the EK to be a restricted decryption key, which is fixed to a particular TPM
 * and whose sensitive data originated inside the TPM.
 * The key for which the credential is being requested for must be a restricted signing key
 * fixed to a TPM and whose sensitive data originated in the TPM.
 */
TSS2_RC FAPI2_CREDENTIAL_getCSRAttr(
        FAPI2_CONTEXT *pCtx,
        CredentialGetCsrAttrIn *pIn,
        CredentialGetCsrAttrOut *pOut
)
{
    TSS2_RC rc = TSS2_SYS_RC_GENERAL_FAILURE;
    FAPI2_OBJECT *pActivateKey = NULL;
    FAPI2_OBJECT *pDecryptKey = NULL;
    TPMT_PUBLIC *pActivatePublic = NULL;
    TPMT_PUBLIC *pDecryptPublic = NULL;
    TPM2_AK_CSR_INFO *pCsrInfo = NULL;
    ubyte *pCsrInfoSerialized = NULL;
    ubyte4 serializationOffset = 0;
    byteBoolean freeOutputBufferOnError = FALSE;
    ContextFlushObjectIn flushObjectIn = { 0 };

    if (!pCtx || !pIn || !pOut)
    {
        rc = TSS2_SYS_RC_BAD_REFERENCE;
        DB_PRINT("%s.%d Invalid pointer inputs, rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    if (pOut->pBase64Blob != NULL)
    {
        rc = TSS2_SYS_RC_BAD_REFERENCE;
        DB_PRINT("%s.%d Output pointer must be NULL, rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    TPM2B_SIZE_CHECK(&pIn->activateKey, TPM2B_MAX_SIZE(&pIn->activateKey));
    TPM2B_SIZE_CHECK(&pIn->decryptKey, TPM2B_MAX_SIZE(&pIn->decryptKey));

    rc = FAPI2_CONTEXT_lookupObject(pCtx, &pIn->activateKey, &pActivateKey);
    if (TSS2_RC_SUCCESS != rc)
    {
        DB_PRINT("%s.%d Unable to find activate key object, rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    rc = FAPI2_CONTEXT_lookupObject(pCtx, &pIn->decryptKey, &pDecryptKey);
    if (TSS2_RC_SUCCESS != rc)
    {
        DB_PRINT("%s.%d Unable to find decrypt key object, rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    pActivatePublic = &pActivateKey->public.objectPublic.publicArea;
    pDecryptPublic = &pDecryptKey->public.objectPublic.publicArea;

    /*
     * Decrypt key must be a restricted decryption key, fixed to a TPM and whose private
     * portion was created by the TPM.
     */
    if (!(pDecryptPublic->objectAttributes & TPMA_OBJECT_RESTRICTED) ||
            !(pDecryptPublic->objectAttributes & TPMA_OBJECT_DECRYPT) ||
            !(pDecryptPublic->objectAttributes & TPMA_OBJECT_SENSITIVEDATAORIGIN) ||
            !(pDecryptPublic->objectAttributes & TPMA_OBJECT_FIXEDTPM))
    {
        rc = TSS2_FAPI_RC_NOT_PERMITTED;
        DB_PRINT("%s.%d Decrypt Key is not a restricted decryption key or does not meet the"
                " fixed TPM or sensitive data origin criteria, rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    /*
     * activate key must be a restricted signing key, fixed to a TPM and whose private
     * portion was created by the TPM.
     */

    if (!(pActivatePublic->objectAttributes & TPMA_OBJECT_RESTRICTED) ||
            !(pActivatePublic->objectAttributes & TPMA_OBJECT_SIGN_ENCRYPT) ||
            !(pActivatePublic->objectAttributes & TPMA_OBJECT_SENSITIVEDATAORIGIN) ||
            !(pActivatePublic->objectAttributes & TPMA_OBJECT_FIXEDTPM))
    {
        rc = TSS2_FAPI_RC_NOT_PERMITTED;
        DB_PRINT("%s.%d Activate Key is not a restricted signing key or does not meet the"
                " fixed TPM or sensitive data origin criteria, rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    if ((pActivatePublic->type != TPM2_ALG_RSA) && (pActivatePublic->type != TPM2_ALG_ECC))
    {
        rc = TSS2_SYS_RC_BAD_VALUE;
        DB_PRINT("%s.%d Activate Key type not ECC or RSA., rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    if ((pDecryptPublic->type != TPM2_ALG_RSA) && (pDecryptPublic->type != TPM2_ALG_ECC))
    {
        rc = TSS2_SYS_RC_BAD_VALUE;
        DB_PRINT("%s.%d Decrypt Key type not ECC or RSA., rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    /*
     * Decrypt key cannot be external, since it is must be a restricted decryption key
     * which can only be created inside the TPM.
     * Activate key can be external, but MUST NOT be. Ideally, a CA would never issue
     * a key that is not fixedTpm and not restricted. FAPI also creates attestation keys
     * as restricted signing keys and external keys cannot be an attestation key.
     * Therefore, we disallow activating credentials for external keys. This should really
     * never happen.
     */
    if (pActivateKey->isExternal || pDecryptKey->isExternal)
    {
        rc = TSS2_FAPI_RC_NOT_PERMITTED;
        DB_PRINT("%s.%d External keys cannot be used for credential activation, rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    if (OK != DIGI_CALLOC((void **)&pCsrInfo, 1, sizeof(*pCsrInfo)))
    {
        rc = TSS2_FAPI_RC_IO_ERROR;
        DB_PRINT("%s.%d Failed to allocate memory for CSR info, rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    /*
     * At worst, the serialized size is the same as the structure size. allocate memory
     */
    if (OK != DIGI_CALLOC((void **)&pCsrInfoSerialized, 1, sizeof(TPM2_AK_CSR_INFO)))
    {
        rc = TSS2_FAPI_RC_IO_ERROR;
        DB_PRINT("%s.%d Failed to allocate memory for serialized CSR info, rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    pCsrInfo->ekObjectAttributes = pDecryptPublic->objectAttributes;
    pCsrInfo->ekNameAlg = pDecryptPublic->nameAlg;
    pCsrInfo->akPublicArea = *pActivatePublic;

    if (OK != SAPI2_SERIALIZE_serialize(SAPI2_ST_TPM2_AK_CSR_INFO,
            TAP_SD_IN,
            (ubyte *)pCsrInfo, sizeof(*pCsrInfo),
            pCsrInfoSerialized, sizeof(TPM2_AK_CSR_INFO),
            &serializationOffset))
    {
        rc = TSS2_FAPI_RC_IO_ERROR;
        DB_PRINT("%s.%d Failed to serialize csr info, rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    /*
     * Need this flag since the input itself might have provided a non null pointer for
     * pBase64Blob. We only want to free memory we allocated.
     */
    freeOutputBufferOnError = TRUE;

    if (OK != BASE64_encodeMessage((ubyte *)pCsrInfoSerialized, serializationOffset,
            (ubyte **)&(pOut->pBase64Blob), &(pOut->blobLen)))
    {
        rc = TSS2_FAPI_RC_IO_ERROR;
        DB_PRINT("%s.%d Failed to base64 encode serialized csr info, rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    rc = TSS2_RC_SUCCESS;
exit:
    if (TSS2_RC_SUCCESS != rc)
    {
        if (freeOutputBufferOnError && pOut->pBase64Blob && (pOut->blobLen != 0))
            shredMemory((ubyte **)&(pOut->pBase64Blob), pOut->blobLen, TRUE);
    }

    if (pCsrInfo)
        shredMemory((ubyte **)&pCsrInfo, sizeof(*pCsrInfo), TRUE);

    if (pCsrInfoSerialized)
        shredMemory((ubyte **)&pCsrInfoSerialized, sizeof(TPM2_AK_CSR_INFO), TRUE);

    if (pActivateKey)
    {
        flushObjectIn.objName = pActivateKey->objectName;
        rc |= FAPI2_CONTEXT_flushObject(pCtx, &flushObjectIn);
    }

    if (pDecryptKey)
    {
        flushObjectIn.objName = pDecryptKey->objectName;
        rc |= FAPI2_CONTEXT_flushObject(pCtx, &flushObjectIn);
    }

    return rc;
}

/*
 * This API can be used to recover the secret wrapped by a credential provider for
 * a given key and a TPM encryption key. This is merely a wrapper around
 * FAPI2_CREDENTIAL_activate. It decodes the base64 blob and calls the
 * FAPI2_CREDENTIAL_activate API to return the secret.
 */
TSS2_RC FAPI2_CREDENTIAL_unwrapSecret(
        FAPI2_CONTEXT *pCtx,
        CredentialUnwrapSecretIn *pIn,
        CredentialUnwrapSecretOut *pOut
)
{
    TSS2_RC rc = TSS2_SYS_RC_GENERAL_FAILURE;
    typedef struct {
        CredentialActivateIn activateIn;
        TPM2_MAKE_CREDENTIAL_RSP_PARAMS rspParams;
    } local_struct_t;

    local_struct_t *pLocals = NULL;
    ubyte4 offset = 0;
    ubyte *pDecodedBlob = NULL;
    ubyte4 decodedBlobLen = 0;

    if (!pCtx || !pIn || !pOut || !pIn->pBase64Blob || (0 == pIn->blobLen))
    {
        rc = TSS2_SYS_RC_BAD_REFERENCE;
        DB_PRINT("%s.%d Invalid pointer inputs, rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    if (OK != DIGI_CALLOC((void **)&pLocals, 1, sizeof(local_struct_t)))
    {
        rc = TSS2_FAPI_RC_IO_ERROR;
        DB_PRINT("%s.%d Failed to allocate memory for activate credential input, rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    if (OK != BASE64_decodeMessage((const ubyte*)pIn->pBase64Blob,
            pIn->blobLen,
            &pDecodedBlob, &decodedBlobLen))
    {
        rc = TSS2_FAPI_RC_IO_ERROR;
        DB_PRINT("%s.%d Failed to decode base64 blob, rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    if (OK != SAPI2_SERIALIZE_serialize(
            SAPI2_ST_TPM2_SHADOW_TPM2_MAKE_CREDENTIAL_RSP_PARAMS,
            TAP_SD_OUT,
            pDecodedBlob,
            decodedBlobLen,
            (ubyte *)&(pLocals->rspParams),
            sizeof(pLocals->rspParams),
            &offset))
    {
        rc = TSS2_FAPI_RC_IO_ERROR;
        DB_PRINT("%s.%d Failed to deserialize decoded base64 blob, rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    pLocals->activateIn.activateKey = pIn->activateKey;
    pLocals->activateIn.decryptKey = pIn->decryptKey;
    pLocals->activateIn.secretBlob = pLocals->rspParams.credentialBlob;
    pLocals->activateIn.encryptedSeed = pLocals->rspParams.secret;

    rc = FAPI2_CREDENTIAL_activate(pCtx, &(pLocals->activateIn), pOut);
    if (TSS2_RC_SUCCESS != rc)
    {
        DB_PRINT("%s.%d Failed to activate credential, rc 0x%02x = %s\n",
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc));
        goto exit;
    }

    rc = TSS2_RC_SUCCESS;
exit:
    if (pLocals)
        shredMemory((ubyte **)&pLocals, sizeof(local_struct_t), TRUE);

    if (pDecodedBlob && (decodedBlobLen != 0))
        shredMemory((ubyte **)&pDecodedBlob, decodedBlobLen, TRUE);

    return rc;
}
#endif  /* (defined(__ENABLE_DIGICERT_TPM2__)) */
