/**
 * @file fapi2_types.h
 * @brief This file contains all the command and response or in and out strcutres
 * required to talk use the FAPI2 API's.
 *
 * @flags
 *  To enable this file's functions, the following flags must be defined in
 * moptions.h:
 *
 *  + \c \__ENABLE_DIGICERT_TPM2__
 *
 * Copyright 2025 DigiCert Project Authors. All Rights Reserved.
 * 
 * DigiCert® TrustCore and TrustEdge are licensed under a dual-license model:
 * - **Open Source License**: GNU AGPL v3. See: https://github.com/digicert/trustcore-test/blob/main/LICENSE
 * - **Commercial License**: Available under DigiCert’s Master Services Agreement. See: https://github.com/digicert/trustcore-test/blob/main/LICENSE_COMMERCIAL.txt  
 *   or https://www.digicert.com/master-services-agreement/
 * 
 * *For commercial licensing, contact DigiCert at sales@digicert.com.*
 *
 */
#ifndef __FAPI2_TYPES_H__
#define __FAPI2_TYPES_H__

#include "../../../../common/moptions.h"

#if (defined(__ENABLE_DIGICERT_TPM2__))
#include "../tpm2_types.h"

/*
 * FAPI2_ASYM_TYPE describes the requested use for
 * an asymmetric key. The key type determines TPM2 specific
 * attributes for the key, thus affecting how the TPM2 will
 * let it be used.
 *
 * Select FAPI2_ASYM_TYPE_SIGNING if the asymmetric key needs to be used
 * for signing. There are no restrictions on what digests the
 * TPM will sign when this is the requested usage.
 *
 * Select FAPI2_ASYM_TYPE_DECRYPT if the asymmetric key needs to be used
 * for encrypting data. There are no restrictions on what data
 * the TPM will encrypt when this is the requested usage.
 *
 * Select FAPI2_ASYM_TYPE_STORAGE if the asymmetric key needs to be a
 * parent key for other TPM2 keys or objects. This type of
 * key maybe be used to be parents of TPM2 objects or
 * to activate credentials for attestation keys. These are
 * the only possible uses.
 * When this is the requested usage, the key cannot be used
 * to sign or encrypt data.
 *
 * Select FAPI2_ASYM_TYPE_ATTESTATION if the asymmetric key needs to be
 * used for signing TPM2 attestation structures. These
 * keys can be used to do general purpose signing like
 * FAPI2_ASYM_TYPE_SIGNING, but the message that must be
 * signed MUST be digested by the TPM using the TPM2_Hash
 * commands. Hence, arbitrary digests cannot be signed
 * by this type of key. If attestation keys could sign
 * arbitrary data, a verifier would have no assurance
 * that the signed data was generated by the TPM2.
 */
typedef ubyte FAPI2_ASYM_TYPE;

#define FAPI2_ASYM_TYPE_SIGNING ((FAPI2_ASYM_TYPE)0x1)
#define FAPI2_ASYM_TYPE_DECRYPT ((FAPI2_ASYM_TYPE)0x2)
#define FAPI2_ASYM_TYPE_GENERAL ((FAPI2_ASYM_TYPE)0x3)
#define FAPI2_ASYM_TYPE_STORAGE ((FAPI2_ASYM_TYPE)0x4)
#define FAPI2_ASYM_TYPE_ATTESTATION ((FAPI2_ASYM_TYPE)0x8)


/*
 * Defines for reserved handles for persistent objects per the TCG Registry
 * of reserved handles.
 */
#define FAPI2_RH_PERSISTENT_OWNER_START (TPM2_PERSISTENT_FIRST)
#define FAPI2_RH_PERSISTENT_OWNER_END (FAPI2_RH_PERSISTENT_OWNER_START + 0xFFFF)
#define FAPI2_RH_PERSISTENT_ENDORSEMENT_START (TPM2_PERSISTENT_FIRST + 0x10000)
#define FAPI2_RH_PERSISTENT_ENDORSEMENT_END (FAPI2_RH_PERSISTENT_ENDORSEMENT_START + 0xFFFF)

/*
 * EK will be persisted at the first reserved handle in the
 * endorsement hierarchy (0x81010000)
 */
#if defined(__RTOS_WIN32__) && !defined(__USE_TPM_EMULATOR__)
#define FAPI2_RH_EK (FAPI2_RH_PERSISTENT_ENDORSEMENT_START + 0x1)
#else
#define FAPI2_RH_EK FAPI2_RH_PERSISTENT_ENDORSEMENT_START
#endif
/*
 * SRK will be persisted at the first reserved handle in the
 * storage hierarchy (0x81000000)
 */
#if defined(__RTOS_WIN32__) && !defined(__USE_TPM_EMULATOR__)
#define FAPI2_RH_SRK (FAPI2_RH_PERSISTENT_OWNER_START + 0x1)
#else
#define FAPI2_RH_SRK FAPI2_RH_PERSISTENT_OWNER_START
#endif

/*
 * This type is defined to perform write operations on an NV index.
 * Even though the type of write is implicit based on the NV index,
 * this is provided explicitly as an input so that FAPI2 can verify
 * if the operation is permitted before send commands to the TPM.
 * If the caller uses the incorrect operation, FAPI2 will return an
 * early error rather than going to the TPM.
 * FAPI2_NV_WRITE_OP_WRITE - Can be used only on TPM2_NT_ORDINARY
 * type of index. This writes data into the NV index.
 * FAPI2_NV_WRITE_OP_INCREMENT - Can be used only on TPM2_NT_COUNTER
 * type of index. This increments the counter index.
 * FAPI2_NV_WRITE_OP_SET_BITS - Can be used only on TPM2_NT_BITS type
 * of index. This OR's the provided 64 bit value with the value in the
 * index.
 * FAPI2_NV_WRITE_OP_EXTEND - Can be used only on TPM2_NT_EXTEND type
 * of index. This extends the given value into the NV index.
 * FAPI2_NV_WRITE_OP_WRITE_LOCK - Can be used to inhibit further writes
 * to the NV index.
 */
typedef ubyte FAPI2_NV_WRITE_OP;

#define FAPI2_NV_WRITE_OP_WRITE ((FAPI2_NV_WRITE_OP)0x1)
#define FAPI2_NV_WRITE_OP_INCREMENT ((FAPI2_NV_WRITE_OP)0x2)
#define FAPI2_NV_WRITE_OP_SET_BITS ((FAPI2_NV_WRITE_OP)0x4)
#define FAPI2_NV_WRITE_OP_EXTEND ((FAPI2_NV_WRITE_OP)0x8)
#define FAPI2_NV_WRITE_OP_WRITE_LOCK ((FAPI2_NV_WRITE_OP)0x10)

#define FAPI2_OBJECT_MAX_SIZE 2176


/*
 * Note: Add new functions in order.
 * The dispatch table uses this as an index into the table
 * directly!
 */
typedef ubyte FAPI2_CC;
#define FAPI2_CC_INVALID ((FAPI2_CC)0x0)

#define FAPI2_CC_RNG_GET_RANDOM ((FAPI2_CC)0x1)
#define FAPI2_CC_RNG_STIR_RANDOM ((FAPI2_CC)0x2)

#define FAPI2_CC_ASYM_CREATE_KEY ((FAPI2_CC)0x3)
#define FAPI2_CC_ASYM_SIGN ((FAPI2_CC)0x4)
#define FAPI2_CC_ASYM_VERIFY_SIG ((FAPI2_CC)0x5)
#define FAPI2_CC_ASYM_RSA_ENCRYPT ((FAPI2_CC)0x6)
#define FAPI2_CC_ASYM_RSA_DECRYPT ((FAPI2_CC)0x7)

#define FAPI2_CC_ADMIN_TAKE_OWNERSHIP ((FAPI2_CC)0x8)
#define FAPI2_CC_ADMIN_RELEASE_OWNERSHIP ((FAPI2_CC)0x9)
#define FAPI2_CC_ADMIN_CREATE_EK ((FAPI2_CC)0xA)
#define FAPI2_CC_ADMIN_CREATE_SRK ((FAPI2_CC)0xB)
#define FAPI2_CC_ADMIN_CREATE_AK ((FAPI2_CC)0xC)

#define FAPI2_CC_CONTEXT_SET_HIERARCHY_AUTH ((FAPI2_CC)0xD)
#define FAPI2_CC_CONTEXT_SET_PRIMARY_KEY_AUTH ((FAPI2_CC)0xE)
#define FAPI2_CC_CONTEXT_GET_AUTHVALUE_LEN ((FAPI2_CC)0xF)
#define FAPI2_CC_CONTEXT_LOAD_OBJECT ((FAPI2_CC)0x10)
#define FAPI2_CC_CONTEXT_FLUSH_OBJECT ((FAPI2_CC)0x11)

#define FAPI2_CC_DATA_SEAL ((FAPI2_CC)0x12)
#define FAPI2_CC_DATA_UNSEAL ((FAPI2_CC)0x13)

#define FAPI2_CC_MGMT_GETCAP ((FAPI2_CC)0x14)
#define FAPI2_CC_MGMT_GET_PCR_SELECTION ((FAPI2_CC)0x15)

#define FAPI2_CC_NV_DEFINE ((FAPI2_CC)0x16)
#define FAPI2_CC_NV_WRITEOP ((FAPI2_CC)0x17)
#define FAPI2_CC_NV_READOP ((FAPI2_CC)0x18)
#define FAPI2_CC_NV_UNDEFINE ((FAPI2_CC)0x19)

#define FAPI2_CC_CONTEXT_GET_LAST_TPM_ERROR ((FAPI2_CC)0x1A)

#define FAPI2_CC_SYM_CREATE_CIPHER_KEY ((FAPI2_CC)0x1B)
#define FAPI2_CC_SYM_CREATE_SIGNING_KEY ((FAPI2_CC)0x1C)
#define FAPI2_CC_SYM_ENCRYPT_DECRYPT ((FAPI2_CC)0x1D)
#define FAPI2_CC_SYM_SIGN ((FAPI2_CC)0x1E)
#define FAPI2_CC_SYM_VERIFY_SIG ((FAPI2_CC)0x1F)

#define FAPI2_CC_ASYM_GET_PUBLIC_KEY ((FAPI2_CC)0x20)
#define FAPI2_CC_ADMIN_GET_PRIMARY_PUBLIC_KEY ((FAPI2_CC)0x21)

#define FAPI2_CC_DATA_DIGEST ((FAPI2_CC)0x22)

#define FAPI2_CC_CONTEXT_IS_TPM_PROVISIONED ((FAPI2_CC)0x23)
#define FAPI2_CC_CONTEXT_GET_PRIMARY_OBJECT_NAME ((FAPI2_CC)0x24)
#define FAPI2_CC_CONTEXT_SET_OBJECT_AUTH ((FAPI2_CC)0x25)

#define FAPI2_CC_ASYM_RESTRICTED_SIGN ((FAPI2_CC)0x26)

#define FAPI2_CC_ATTESTATION_GET_QUOTE ((FAPI2_CC)0x27)

#define FAPI2_CC_CREDENTIAL_ACTIVATE ((FAPI2_CC)0x28)
#define FAPI2_CC_CREDENTIAL_MAKE ((FAPI2_CC)0x29)

#define FAPI2_CC_NV_READ_PUBLC ((FAPI2_CC)0x2A)
#define FAPI2_CC_TESTING_SELF_TEST ((FAPI2_CC)0x2B)
#define FAPI2_CC_TESTING_GET_TEST_RESULT ((FAPI2_CC)0x2C)

#define FAPI2_CC_CREDENTIAL_GET_CSR_ATTR ((FAPI2_CC)0x2D)
#define FAPI2_CC_CREDENTIAL_UNWRAP_SECRET ((FAPI2_CC)0x2E)

#define FAPI2_CC_INTEGRITY_PCR_RESET ((FAPI2_CC)0x2F)
#define FAPI2_CC_INTEGRITY_PCR_READ ((FAPI2_CC)0x30)
#define FAPI2_CC_INTEGRITY_PCR_EXTEND ((FAPI2_CC)0x31)

#define FAPI2_CC_END ((FAPI2_CC)0x32)

typedef struct FAPI2_CONTEXT FAPI2_CONTEXT;
typedef struct FAPI2_OBJECT FAPI2_OBJECT;

/*
 * Structure representing a serialized FAPI2 object. This structure is
 * suitable for storage into files etc.
 */

typedef struct {
    ubyte2 size;
    ubyte buffer[FAPI2_OBJECT_MAX_SIZE];
} FAPI2B_OBJECT;


/*
 * Information structure for RSA key creation.
 */
typedef struct {
    /*
     * See documentation for FAPI2_ASYM_TYPE.
     */
    FAPI2_ASYM_TYPE keyType;
    /*
     * Size in bits, for the RSA key. Only 2048 and 3072 bit
     * keys are supported. It is recommended to use ECC keys
     * for higher security requirements.
     */
    ubyte2 keySize;

    /*
     * Exponent for the RSA key. Can be any prime greater than 2.
     * if 0, the default exponent of 65535 is chosen.
     */
    ubyte4 exponent;

    /*
     * Scheme to be used for RSA key operation. The acceptable values
     * depend on FAPI2_ASYM_TYPE. RSAES, OAEP RSAPSS and RSASSA are
     * standard encryption and signing schemes defined in various PKCS
     * standards(IETF RFC 3447)
     * 1) FAPI2_ASYM_TYPE_SIGNING - TPM2_ALG_RSAPSS, TPM2_ALG_RSASSA, or
     *      TPM2_ALG_NULL(Scheme must be provided when the key is used for
     *      signing)
     * 2) FAPI2_ASYM_TYPE_DECRYPT - TPM2_ALG_RSAES, TPM2_ALG_OAEP, or
     *      TPM2_ALG_NULL(Scheme must be provided when the key is used for
     *      decryption)
     * 3) FAPI2_ASYM_TYPE_STORAGE - TPM2_ALG_NULL. If any other value is
     *      provided, it is ignored for this type.
     * 4) FAPI2_ASYM_TYPE_ATTESTATION - TPM2_ALG_RSAPSS, TPM2_ALG_RSASSA
     * 5) FAPI2_ASYM_TYPE_GENERAL - TPM2_ALG_NULL. If any other value is
     *      provided, it is ignored for this type. The scheme must be
     *      provided when the key is used for signing/encryption/decryption.
     */
    TPMI_ALG_RSA_SCHEME scheme;

    /*
     * Hash algorithm to be used with the encryption or signing scheme.
     * The acceptable values are TPM2_ALG_SHA256, TPM2_ALG_SHA384 and
     * TPM2_ALG_SHA512. This must be provided even if the scheme is
     * TPM2_ALG_NULL.
     */
    TPMI_ALG_HASH hashAlg;
} FAPI2_RSA_INFO;

typedef struct {
    /*
     * See documentation for FAPI2_ASYM_TYPE.
     */
    FAPI2_ASYM_TYPE keyType;

    /*
     * This is used to select the ECC curve to use for key generation.
     * Acceptable values for curveID's:
     * TPM2_ECC_NIST_P192, TPM2_ECC_NIST_P224, TPM2_ECC_NIST_P256,
     * TPM2_ECC_NIST_P384, TPM2_ECC_NIST_P521. Note that a TPM
     * may not support all the curveID's listed.
     */
    TPMI_ECC_CURVE curveID;

    /*
     * Scheme to be used for ECC key operation. The acceptable values
     * depend on FAPI2_ASYM_TYPE. TPM2_ALG_ECDSA, TPM2_ALG_ECSCHNORR,
     * TPM2_ALG_ECDH are the acceptable values. ECDSA is defined in
     *  ISO/IEC 14888-3. ECSCHNORR signature is detailed in part1 of
     *  the TPM2 Library specification.
     * 1) FAPI2_ASYM_TYPE_SIGNING - TPM2_ALG_ECDSA, TPM2_ALG_ECSCHNORR, or
     *      TPM2_ALG_NULL(Scheme must be provided when the key is used for
     *      signing)
     * 2) FAPI2_ASYM_TYPE_DECRYPT - TPM2_ALG_ECDH or
     *      TPM2_ALG_NULL(Scheme must be provided when the key is used for
     *      decryption)
     * 3) FAPI2_ASYM_TYPE_STORAGE - TPM2_ALG_NULL. If any other value is
     *      provided, it is ignored for this type.
     * 4) FAPI2_ASYM_TYPE_ATTESTATION - TPM2_ALG_ECDSA, TPM2_ALG_ECSCHNORR.
     * 5) FAPI2_ASYM_TYPE_GENERAL - TPM2_ALG_NULL. If any other value is
     *      provided, it is ignored for this type. The scheme must be
     *      provided when the key is used for signing/encryption/decryption.
     *
     * The hash algorithm to be used used with a signing scheme is dictated
     * by the curveID and will be selected automatically. SHA256 is selected
     * for TPM2_ECC_NIST_P192, TPM2_ECC_NIST_P224 and TPM2_ECC_NIST_P256.
     * SHA384 for TPM2_ECC_NIST_P384, and SHA512 for TPM2_ECC_NIST_P521.
     */
    TPMI_ALG_ECC_SCHEME scheme;
} FAPI2_ECC_INFO;

typedef union {
    /*
     * TPM2_ALG_RSA selects this field
     */
    FAPI2_RSA_INFO rsaInfo;

    /*
     * TPM2_ALG_ECC selects this field.
     */
    FAPI2_ECC_INFO eccInfo;
} FAPI2_KEY_INFO_UNION;

typedef struct {
    /*
     * RVal for the ECC signature
     */
    TPM2B_ECC_PARAMETER signatureR;
    /*
     * SVal for the ECC signature
     */
    TPM2B_ECC_PARAMETER signatureS;
} FAPI2_ECC_SIGNATURE;

typedef union {
    /*
     * TPM2_ALG_RSA selects this field
     */
    TPM2B_PUBLIC_KEY_RSA rsaSignature;
    /*
     * TPM2_ALG_ECC selects this field.
     */
    FAPI2_ECC_SIGNATURE eccSignature;
} FAPI2_SIGNATURE_UNION;

typedef union {
    /*
     * TPM2_ALG_RSA selects this field
     */
    TPM2B_PUBLIC_KEY_RSA    rsaPublic;
    /*
     * TPM2_ALG_ECC selects this field
     */
    TPMS_ECC_POINT          eccPublic;
} FAPI2_PUBLIC_KEY_UNION;

typedef union {
    /*
     * TPM2_ALG_RSA selects this field
     */
    TPM2B_PRIVATE_KEY_RSA           rsaPrivate;
    /*
     * TPM2_ALG_ECC selects this field
     */
    TPM2B_ECC_PARAMETER             eccPrivate;
} FAPI2_PRIVATE_KEY_UNION;

/*
 * The different policies that can be used for authorization.
 */
typedef ubyte2 FAPI2_POLICY_AUTH_TYPE;
#define FAPI2_POLICY_INVALID (FAPI2_POLICY_AUTH_TYPE)0
/*
 * This policy specifies that an object will use its own authValue
 * to authorize its usage. This is the default policy, that will
 * be used if no policy is specified. This is equivalent to using
 * an authValue onlyf or authorization.
 */
#define FAPI2_POLICY_AUTH_VALUE (FAPI2_POLICY_AUTH_TYPE)0x1

/*
 * This policy specifies that an object will use ANOTHER objects
 * authValue to authorize its usage. This is essentially using the authValue
 * of an object to symmetrically sign(through hmac session) the
 * authorization of an object. A nonce provided by the TPM will always be
 * signed, in effect, limiting the use of the authorization to one time
 * use-only.
 */
#define FAPI2_POLICY_OBJECT_SECRET (FAPI2_POLICY_AUTH_TYPE)0x2

/*
 * This policy specifies that an object will require an asymmetric
 * signature over certain data(such as the nonce from the TPM and/or
 * user defined data(policyRef) etc), to authorize its usage.
 * The signature may be done in line by loading the external key into the
 * fapi2 context, or via callback, so that the authorizer need not load
 * the private key into the fapi2 context.
 */
#define FAPI2_POLICY_SIGNED_AUTH (FAPI2_POLICY_AUTH_TYPE)0x3

/*
 * This policy specifies that an object will require the selected
 * TPM's PCR's to be in a particular state for an operation using the object
 * to succeed.
 */
#define FAPI2_POLICY_PCR (FAPI2_POLICY_AUTH_TYPE)0x4

/*
 * This policy specifies that an object has a flexible/wildcard/dynamic
 * authorization policy, which may be any combination of other policies.
 * The policy to authorize an objects use, can(if needed)
 * be changed for every use, as long as the final policy digest itself
 * is signed asymetrically by a trusted key(specified during creation
 * of object).
 */
#define FAPI2_POLICY_DYNAMIC_POLICY (FAPI2_POLICY_AUTH_TYPE)0x5

/*
 * This policy specifies that an object has a flexible/wildcard/dynamic
 * authorization policy, which may be any combination of other policies.
 * The policy to authorize an objects use, can(if needed) be changed
 * for every use, as long as the final policy digest is in an NV index
 * whose use can be authorized.
 * The difference between FAPI2_POLICY_DYNAMIC_POLICY_NV and
 * FAPI2_POLICY_DYNAMIC_POLICY is that in one case it is signed by a
 * trusted private key and in the other case it is in an NV index
 * whose use can be authorized. The other MAJOR difference is that
 * the signed authorization can never be revoked, however, with the
 * NV, the policy can simply be replaced and an old policy can be
 * revoked.
 */
#define FAPI2_POLICY_DYNAMIC_POLICY_NV (FAPI2_POLICY_AUTH_TYPE)0x6

#define FAPI2_POLICY_COMMAND_CODE  (FAPI2_POLICY_AUTH_TYPE)0x7

/*
 * This policy specifies that an object should not load in any authorization
 * policies. Since 0 policy results in the default policy being loaded, this
 * policy must be explicitly used to not load in any policies.
 */
#define FAPI2_POLICY_NO_DEFAULT (FAPI2_POLICY_AUTH_TYPE)0xFFFF

typedef union {
    /*
     * This can be either TPM2_RH_OWNER, TPM2_RH_ENDORSEMENT, TPM2_RH_LOCKOUT
     * or 0. Any other value is an error.
     * The use of this field is to enable objects to have policies tied
     * to the authValue of a TPM2 hierarchy.
     */
    TPMI_RH_HIERARCHY authorizingHierarchy;

    /*
     * Handle/name to the object, whose authValue will be used to authorize
     * the object being created/used.
     * During object creation, the name of this object becomes cryptographically
     * linked to the object.
     * During object use, this object must be loaded in the context and its
     * authValue set.
     */
    TPM2B_NAME authorizingObject;
} AuthEntityUnion;

typedef struct {
    /*
     * User defined data that will be associated with the objects policy.
     * During object creation, this data becomes cryptographically part of
     * the object.
     * During object use, the data in this buffer must be
     * signed symmetrically(HMAC, shared secret is authValue of object
     * referred by authorizingObject) for the object to be used successfully.
     */
    TPM2B_NONCE policyRef;

    /*
     * Selects one of the the fields in authEntity.
     * A value of:
     * 1 - selects authorizingHierarchy
     * 2 - selects authorizingObject
     */
    ubyte authEntitySelector;

    AuthEntityUnion authEntity;

} PolicyObjectSecret;

typedef struct {
    /*
     * User defined data that will be associated with the objects policy.
     * During object creation, this data becomes cryptographically part of
     * the object.
     * During object use, the data in this buffer must be
     * signed asymmetrically for the object to be used successfully.
     */
    TPM2B_NONCE policyRef;

    /*
     * Handle/name to the object, which will be used to authorize the policy for
     * the object being created/used.
     * During object creation, the name of this object becomes cryptographically
     * linked to the object.
     * During object use, this object must be loaded in the context and will be
     * used to sign the policRef and a policy.
     */
    TPM2B_NAME authorizingKey;
} PolicySignedAuth;

typedef struct {
    /*
     * optional digest of PCR's that the TPM must have, to use the object.
     * During object creation, the digest of the PCR's are cryptographically
     * linked to the object.
     * During object use, the PCR's must be in the state that was specified
     * during creation.
     */
    TPM2B_DIGEST pcrDigest;

    /*
     * Bit mask of PCR's whose values must be used during object creation.
     */
    ubyte4 pcrBitmask;
} PolicyPcr;

typedef struct {

    /*
     * User defined data that will be associated with the objects policy.
     * During object creation, this data becomes cryptographically part of
     * the object.
     * During object use, the data in this buffer must be
     * signed asymmetrically for the object to be used successfully.
     */
    TPM2B_NONCE policyRef;

    /*
     * Handle/name to the object, which will be used to authorize the policy for
     * the object being created/used.
     * During object creation, the name of this object becomes cryptographically
     * linked to the object.
     * During object use, this object must be loaded in the context and will be
     * used to sign the policRef and a policy.
     */
    TPM2B_NAME authorizingKey;
} PolicyDynamicPolicy;

typedef struct {
    /*
     * NV index that contains the policy. This is in the range
     * TPM2_NV_INDEX_FIRST(0x01000000) - TPM2_NV_INDEX_LAST(0x01FFFFFF)
     * If the nvIndex is authorized properly, the policy digest in the
     * NV index becomes the authorized policy.
     */
    TPMI_RH_NV_INDEX nvIndex;
} PolicyDynamicPolicyNV;

typedef struct {
    TPM2_CC code ;
} PolicyCommandCode ;

typedef union {
    PolicyObjectSecret policyObjectSecret;
    PolicySignedAuth policySignedAuth;
    PolicyPcr policyPcr;
    PolicyDynamicPolicy policyDynamicPolicy;
    PolicyDynamicPolicyNV policyDynamicPolicyNV;
    PolicyCommandCode policyCC ;
} PolicyInfoUnion;

typedef struct {
    FAPI2_POLICY_AUTH_TYPE policyType;
    PolicyInfoUnion policyInfo;
} PolicyAuthNode;

typedef struct
{
    /* No indicates an incremental test */
    TPMI_YES_NO   fullTest;
    /* Yes indicates to read the results of the last performed test, without running a new selftest. */
    TPMI_YES_NO   getResultsOnly;
} TestingSelfTestIn;

typedef struct
{
    /*! The test result data */
    TPM2B_MAX_BUFFER outData;
    /*! The status of the last test run */
    TPM2_RC          testResult;
} TestingSelfTestOut;

typedef struct {
    /*
     * authValue to be used for the new asymmetric Key.
     * The size of the authValue can be no larger than the name
     * algorithm of the object.
     * SHA256 by used by default, so the authValue can be no longer
     * than 32 bytes.
     */
    TPM2B_AUTH keyAuth;

    /*
     * This value must be TPM2_ALG_RSA or TPM2_ALG_ECC. This decides
     * if the key generated is an RSA key or ECC key.
     */
    TPMI_ALG_PUBLIC keyAlg;

    /*
     * Information regarding the asymmetric key to be created.
     * The keyType and scheme must be as documented in the information for
     * FAPI2_RSA/ECC_INFO.
     */
    FAPI2_KEY_INFO_UNION keyInfo;

    /*
     * Pointer to parents name/handle. This is an optional input.
     * If pParent is NULL or the size is 0, the SRK is selected
     * automatically as a parent.
     * The parent can be any persistent/primary object such as the
     * EK, AK or SRK, in which case, FAPI2_CONTEXT_getPrimaryObjectName()
     * can be used to get the parents name, and passed here.
     * If the parent is a non-persistent object, the caller can
     * get the name returned by using FAPI2_CONTEXT_loadObject().
     * In this case, the entire hierarchy of parent objects must be
     * loaded into the context. Creation will fail, if any object,
     * leading to the hierarchy seeds are missing.
     */
    TPM2B_NAME *pParentName;
    byteBoolean bEnableBackup ; 
    
    /* 
     * If this key is to be persisted, this value must be set
     */
    ubyte4 objectId;
} AsymCreateKeyIn;

typedef struct {
    /*
     * Serialized TPM key, ready for storage. This structure can be
     * written to file and later loaded for use using FAPI2_CONTEXT_
     * loadObject. The key is loaded in the FAPI2_CONTEXT when the API
     * returns and need not be loaded unless a new context is created.
     */
    FAPI2B_OBJECT key;

    /*
     * Name/handle to the key. Key use API's expect the key name to
     * identify the key for operation.
     */
    TPM2B_NAME keyName;

    /*
     * Reflects the keyAlg parameter provided in the input. This also
     * serves as the union selector for the public key.
     */
    TPMI_ALG_PUBLIC keyAlg;

    /*
     * Public Key of the created key.
     */
    FAPI2_PUBLIC_KEY_UNION publicKey;

} AsymCreateKeyOut;

typedef struct {
    /*
     * The key provided must be of type FAPI2_ASYM_TYPE_SIGNING,
     * or FAPI2_ASYM_TYPE_GENERAL. Other types are invalid. The
     * authValue used is the value that is present in the object
     * structure. If the object was serialized and then deserialized,
     * The key is expected to be loaded in the FAPI2_CONTEXT before
     * this private key operation can be performed.
     */
    TPM2B_NAME keyName;

    /*
     * Digest to be signed.
     */
    TPM2B_DIGEST signDigest;

    /*
     * Signature scheme. This MUST be provided if the key is of type
     * FAPI2_ASYM_TYPE_GENERAL. For keys of type FAPI2_ASYM_TYPE_SIGNING
     * the values provided here will be ignored, and the ones provided during
     * key creation will be used. If no scheme was provided during key creation,
     * the scheme must be provided here.
     * For RSA signatures, valid schemes are:
     *      TPM2_ALG_RSAPSS, TPM2_ALG_RSASSA(PKCS1v5)
     * For ECC signatures, valid schemes are:
     *      TPM2_ALG_ECDSA, TPM2_ALG_ECSCHNORR
     */
    TPMI_ALG_SIG_SCHEME sigScheme;

    /*
     * Hash algorithm to be used with the signing scheme.
     * For RSA signatures: valid values are TPM2_ALG_SHA256, TPM2_ALG_SHA384 and
     * TPM2_ALG_SHA512.
     * For EC signatures: must be TPM2_ALG_NULL. hashAlg is automatically
     * selected.
     * SHA256 is selected for TPM2_ECC_NIST_P192, TPM2_ECC_NIST_P224
     * and TPM2_ECC_NIST_P256.
     * SHA384 for TPM2_ECC_NIST_P384, and SHA512 for TPM2_ECC_NIST_P521.
     */
    TPMI_ALG_HASH hashAlg;

} AsymSignIn;

typedef struct {
    /*
     * This value is TPM2_ALG_RSA or TPM2_ALG_ECC. This serves as the selector
     * for the signature union.
     */
    TPMI_ALG_PUBLIC keyAlg;

    /*
     * rsaSignature contains the signature buffer if the chosen scheme
     * was TPM2_ALG_RSASSA or TPM2_ALG_RSAPSS.
     * eccSignature contains the signature buffer for R and S if the
     * chosen signature scheme was TPM2_ALG_ECDSA or TPM2_ALG_ECSCHNORR.
     * The caller of the API must use the appropriate structure in the
     * union since there is no selector returned(Implicit based on
     * input parameters).
     */
    FAPI2_SIGNATURE_UNION signature;
} AsymSignOut;

typedef struct {
    /*
     * The key provided must be of type FAPI2_ASYM_TYPE_ATTESTATION or FAPI2_ASYM_TYPE_SIGNING.
     * Other types are invalid. The authValue used is the value that is
     * present in the object structure.
     * If the object was serialized and then deserialized,
     * the key is expected to be loaded in the FAPI2_CONTEXT before
     * this private key operation can be performed.
     * This API can be used on unrestricted signing keys of type FAPI2_ASYM_TYPE_SIGNING,
     * whose schemes were provided during key creation(since there are no parameters for scheme).
     * This API becomes a convenience API for such keys, and an application can use the TPM to
     * digest the data that needs to be signed.
     */
    TPM2B_NAME keyName;

    /*
     * Buffer and buffer length to be signed. The buffer will be digested using the hash algorithm
     * specified during key creation.
     */
    ubyte4 bufferLen;

    ubyte *pBuffer;

    /*
     * Signature scheme. This MUST be provided if the key is of type
     * FAPI2_ASYM_TYPE_GENERAL. For keys of type FAPI2_ASYM_TYPE_SIGNING
     * the values provided here will be ignored, and the ones provided during
     * key creation will be used. If no scheme was provided during key creation,
     * the scheme must be provided here.
     * For RSA signatures, valid schemes are:
     *      TPM2_ALG_RSAPSS, TPM2_ALG_RSASSA(PKCS1v5)
     * For ECC signatures, valid schemes are:
     *      TPM2_ALG_ECDSA, TPM2_ALG_ECSCHNORR
     */
    TPMI_ALG_SIG_SCHEME sigScheme;

    /*
     * Hash algorithm to be used with the signing scheme.
     * For RSA signatures: valid values are TPM2_ALG_SHA256, TPM2_ALG_SHA384 and
     * TPM2_ALG_SHA512.
     * For EC signatures: must be TPM2_ALG_NULL. hashAlg is automatically
     * selected.
     * SHA256 is selected for TPM2_ECC_NIST_P192, TPM2_ECC_NIST_P224
     * and TPM2_ECC_NIST_P256.
     * SHA384 for TPM2_ECC_NIST_P384, and SHA512 for TPM2_ECC_NIST_P521.
     */
    TPMI_ALG_HASH hashAlg;

} AsymRestrictedSignIn;

typedef AsymSignOut AsymRestrictedSignOut;

typedef struct {

    /*
     * The key used to verify the signature.
     * The key provided must be of type FAPI2_ASYM_TYPE_SIGNING,
     * or FAPI2_ASYM_TYPE_GENERAL. Other types are invalid. This is
     * a public key operation so an application need not have set
     * the authValue for the object. This is useful in situations
     * where an application de-serializes a key and only wants to
     * perform public key operations.
     * The key must be loaded in the FAPI2_CONTEXT before this API
     * is called.
     */
    TPM2B_NAME keyName;

    /*
     * Digest on which the signature is to be verified.
     */
    TPM2B_DIGEST digest;

    /*
     * Signature scheme. This MUST be provided if the key is of type
     * FAPI2_ASYM_TYPE_GENERAL. For keys of type FAPI2_ASYM_TYPE_SIGNING
     * the values provided here will be ignored, and the ones provided during
     * key creation will be used.
     * For RSA signatures, valid schemes are:
     *      TPM2_ALG_RSAPSS, TPM2_ALG_RSASSA(PKCS1v5)
     * For ECC signatures, valid schemes are:
     *      TPM2_ALG_ECDSA, TPM2_ALG_ECSCHNORR
     */
    TPMI_ALG_SIG_SCHEME sigScheme;

    /*
     * Hash algorithm to be used with the signing scheme.
     * For RSA signatures: valid values are TPM2_ALG_SHA256, TPM2_ALG_SHA384 and
     * TPM2_ALG_SHA512.
     * For EC signatures: must be TPM2_ALG_NULL. hashAlg is automatically
     * selected.
     * SHA256 is selected for TPM2_ECC_NIST_P192, TPM2_ECC_NIST_P224
     * and TPM2_ECC_NIST_P256.
     * SHA384 for TPM2_ECC_NIST_P384, and SHA512 for TPM2_ECC_NIST_P521.
     */
    TPMI_ALG_HASH hashAlg;

    /*
     * rsaSignature will be used to access the signature buffer if the
     * chosen scheme(provided above, or implicit for FAPI2_ASYM_TYPE_SIGNING
     * key types) is TPM2_ALG_RSASSA or TPM2_ALG_RSAPSS.
     * eccSignature will be used to access the signature buffer for R and S
     * if the chosen signature scheme is TPM2_ALG_ECDSA or TPM2_ALG_ECSCHNORR.
     */
    FAPI2_SIGNATURE_UNION signature;

} AsymVerifySigIn;

typedef struct {
    /*
     * Returned value is TRUE if the signature verification succeeded. FALSE
     * otherwise. Success of the signature verification API does not mean
     * the signature validation succeeded. THis field must be used by
     * applications to know if the signature verification succeeded or failed.
     */
    byteBoolean sigValid;
} AsymVerifySigOut;

typedef struct {
    /*
     * Key with which the data must be encrypted. The key must be of type
     * FAPI2_ASYM_TYPE_DECRYPT or FAPI2_ASYM_TYPE_GENERAL. Other types
     * are errors.
     */
    TPM2B_NAME keyName;

    /*
     * The scheme must be provided for key type FAPI2_ASYM_TYPE_GENERAL.
     * Otherwise the scheme is ignored and the one provided during key
     * creation is used. The valid schemes are:
     * TPM2_ALG_OAEP, TPM2_ALG_NULL, and TPM2_ALG_RSAES
     */
    TPMI_ALG_RSA_DECRYPT scheme;

    /*
     * Must be TPM2_ALG_SHA256, TPM2_ALG_SHA384 or TPM2_ALG_SHA512 for
     * TPM2_ALG_OAEP. Ignored otherwise.
     */
    TPMI_ALG_HASH hashAlg;

    /*
     * Any label that must be associated with the message. This parameter
     * may be of size 0. label.buffer[label.size - 1] must be 0. If a 0 occurs
     * in the byte stream before label.size - 1, the TPM will not use
     * any bytes after. Effectively, 0 indicates the termination of the
     * byte stream(similar to a NULL terminated string)
     */
    TPM2B_DATA label;

    /*
     * The message to be encrypted. The limits for length of the message is:
     * For TPM2_ALG_OAEP:
     * (message length <= (public key size in bytes) - 2 * hash Length bytes - 2)
     * For TPM2_ALG_RSAES:
     * (message length <= (public key size in bytes) - 11
     * For TPM2_ALG_NULL
     * (message length <= (public key size in bytes).
     * These limits will be validated by the TPM and not the API itself.
     */
    TPM2B_PUBLIC_KEY_RSA message;
} AsymRsaEncryptIn;

typedef struct {
    /*
     * Encrypted data returned per the scheme inputs.
     */
    TPM2B_PUBLIC_KEY_RSA encryptedData;
} AsymRsaEncryptOut;

typedef struct {

    /*
     * Key with which decryption will be performed. SInce this is a private
     * key operation, the authValue for the key is expected to be set when
     * this API is called. The key must be of type FAPI2_ASYM_TYPE_DECRYPT
     * or FAPI2_ASYM_TYPE_GENERAL. Other types are invalid.
     */
    TPM2B_NAME keyName;

    /*
     * The scheme must be provided for key type FAPI2_ASYM_TYPE_GENERAL.
     * Otherwise the scheme is ignored and the one provided during key
     * creation is used. The valid schemes are:
     * TPM2_ALG_OAEP, TPM2_ALG_NULL, and TPM2_ALG_RSAES.
     * This is the scheme that will be used for decryption.
     */
    TPMI_ALG_RSA_DECRYPT scheme;

    /*
     * Must be TPM2_ALG_SHA256, TPM2_ALG_SHA384 or TPM2_ALG_SHA512 for
     * TPM2_ALG_OAEP. Ignored otherwise.
     */
    TPMI_ALG_HASH hashAlg;

    /*
     * Any label that was associated with the message during encryption.
     * label.buffer[label.size - 1] must be 0. If a 0 occurs
     * in the byte stream before label.size - 1, the TPM will not use
     * any bytes after. Effectively, 0 indicates the termination of the
     * byte stream(similar to a NULL terminated string)
     */
    TPM2B_DATA label;

    /*
     * Cipher text to be decrypted.
     */
    TPM2B_PUBLIC_KEY_RSA cipherText;
} AsymRsaDecryptIn;

typedef struct {
    /*
     * The decrypted plain text.
     */
    TPM2B_PUBLIC_KEY_RSA plainText;
} AsymRsaDecryptOut;


typedef struct {
    /*
     * Name/Handle of an asymmetric key loaded in the context. If the key
     * is not an asymmetric key, an error will be returned.
     */
    TPM2B_NAME keyName;
} AsymGetPublicKeyIn;

typedef struct {
    /*
     * Type of the key. This is either TPM2_ALG_RSA or TPM2_ALG_ECC.
     * This can be used as the selector for the union.
     */
    TPMI_ALG_PUBLIC keyAlg;

    /*
     * Public Key.
     */
    FAPI2_PUBLIC_KEY_UNION publicKey;
} AsymGetPublicKeyOut;

typedef struct {
    /*
     * The max length of hierarchy authValues can be obtained using
     * FAPI2_CONTEXT_getMaxAuthValueLength.
     */

    /*
     * New lockout administrator authValue. This is used for administrative
     * commands such as clearing the TPM, or to disengage dictionary attack
     * protection.
     */
    TPM2B_AUTH newLockOutAuth;

    /*
     * New owner/storage hierarchy administrator authValue. This is used for
     * administrative commands such as creating primary keys under the storage
     * hierarchy and creating NV index's etc.
     */
    TPM2B_AUTH newOwnerAuth;

    /*
     * New privacy admin/endorsement hierarchy authValue. THis is used for
     * privacy sensitive administrative commands such as creating primary keys,
     * endorsement keys under the endorsement hierarchy.
     */
    TPM2B_AUTH newEndorsementAuth;
} AdminTakeOwnershipIn;

typedef struct {
    /*
     * This flag is used to indicate if the EK is considered privacy
     * senstitive or not. If the key is privacy sensitive, the EK
     * will be created as a storage(restricted decryption) key. Doing
     * so prevents the use of the EK to directly sign digets, thus
     * preventing direct identification of a platform. If privacy is
     * not of concern, the EK will be setup as a restricted signing
     * key and it can directly sign attestation structures.
     * Note that if it is not privacy sensitive, we will not use the
     * TCG recommended template for EK creation, and hence will not
     * be able to use the manufacturer provided certificate for the EK.
     */
    byteBoolean isPrivacySensitive;

    /*
     * authValue to be used for the EK. If an authValue of size 0
     * is provided the endorsement hierarchy password will be used.
     * This is expected to be set in the FAPI2_CONTEXT. Key creation will fail
     * if the endorsement hierarchy password is not set.
     * The size of the authValue can be no larger than the name
     * algorithm of the object.
     * SHA256 by used by default, so the authValue can be no longer
     * than 32 bytes.
     * This is only used, if the EK is not privacy sensitive. If it is
     * privacy sensitive, the TCG recommended template for the EK
     * will be used, which creates a restricted decryption key, using
     * the TCG recommended policy of FAPI2_POLICY_OBJECT_SECRET, with
     * the authorizing object as TPM2_RH_ENDORSEMENT.
     */
    TPM2B_AUTH EKAuth;

    /*
     * THis value must be TPM2_ALG_RSA or TPM2_ALG_ECC. THis decides
     * if the EK generated is an RSA key or ECC key.
     */
    TPMI_ALG_PUBLIC keyAlg;
} AdminCreateEKIn;

typedef struct {
    /*
     * authValue to be used for the SRK. If an authValue of size 0,
     * It is the well known password and will be used as is.
     * Key creation will fail if the storage hierarchy password
     * is not set correctly.
     * The size of the authValue can be no larger than the name
     * algorithm of the object.
     * SHA256 by used by default, so the authValue can be no longer
     * than 32 bytes.
     */
    TPM2B_AUTH SRKAuth;

    /*
     * THis value must be TPM2_ALG_RSA or TPM2_ALG_ECC. THis decides
     * if the SRK generated is an RSA key or ECC key.
     */
    TPMI_ALG_PUBLIC keyAlg;
} AdminCreateSRKIn;

typedef struct {
    /*
     * authValue to be used for the Attestation Key. If an authValue
     * of size 0 is provided, it will be used as is.
     * The size of the authValue can be no larger than the name
     * algorithm of the object.
     * SHA256 by used by default, so the authValue can be no longer
     * than 32 bytes.
     */
    TPM2B_AUTH AKAuth;

    /*
     * This value must be TPM2_ALG_RSA or TPM2_ALG_ECC. This decides
     * if the AK generated is an RSA key or ECC key.
     */
    TPMI_ALG_PUBLIC keyAlg;

    /*
     * Information regarding the attestation key to be created.
     * The keyType in rsaInfo or eccInfo MUST be FAPI2_ASYM_TYPE_ATTESTATION.
     * The scheme must be as documented in the information for
     * FAPI2_RSA/ECC_INFO.
     */
    FAPI2_KEY_INFO_UNION keyInfo;

    /*
     * Any value between FAPI2_RH_PERSISTENT_ENDORSEMENT_START and
     * FAPI2_RH_PERSISTENT_ENDORSEMENT_END. This cannot be FAPI2_RH_EK
     * since it is reserved for the TPM's endorsement key.
     */
    TPMI_DH_PERSISTENT persistentHandle;
} AdminCreateAKIn;

typedef struct {
    /*
     * Any value between FAPI2_RH_PERSISTENT_ENDORSEMENT_START and
     * FAPI2_RH_PERSISTENT_ENDORSEMENT_END. This cannot be FAPI2_RH_EK
     * since it is reserved for the TPM's endorsement key.
     */
    TPMI_DH_PERSISTENT persistentHandle;

    /*
     * buffer length and pointer to buffer, that needs to be digested and signed
     * by the TPM, using the AK. The buffer will be digested using the hash algorithm
     * specified during key creation.
     */
    ubyte4 bufferLen;
    ubyte *pBuffer;

} AdminSignWithAkIn;

typedef AsymSignOut AdminSignWithAkOut;

typedef struct {
    /*
     * FAPI2_RH_EK - Get Public Key for the EK(Endorsement Key)
     * FAPI2_RH_SRK - Get Public Key for the SRK(Storage Root Key)
     * Any other value between FAPI2_RH_PERSISTENT_ENDORSEMENT_START and
     * FAPI2_RH_PERSISTENT_ENDORSEMENT_END. These are usually AK's
     * (Attestation Keys). If the key is not an asymmetric key,
     * the API will return an error.
     */
    TPMI_DH_PERSISTENT persistentHandle;
} AdminGetPrimaryPublicKeyIn;

typedef struct {
    /*
     * Type of the key. This is either TPM2_ALG_RSA or TPM2_ALG_ECC.
     * This can be used as the selector for the union.
     */
    TPMI_ALG_PUBLIC keyAlg;

    /*
     * Public Key.
     */
    FAPI2_PUBLIC_KEY_UNION publicKey;
} AdminGetPrimaryPublicKeyOut;

typedef struct {
    /*
     * authValues for the owner, endorsement and lockout administrators/
     * hierarchy's.
     * The max length of hierarchy authValues can be obtained using
     * FAPI2_CONTEXT_getMaxAuthValueLength.
     * The flags to force use authValue is to indicate the intent of the
     * caller to forcefully use an authValue of size 0.
     */
    byteBoolean forceUseOwnerAuth;
    TPM2B_AUTH ownerAuth;
    byteBoolean forceUseEndorsementAuth;
    TPM2B_AUTH endorsementAuth;
    byteBoolean forceUseLockoutAuth;
    TPM2B_AUTH lockoutAuth;
} ContextSetHierarchyAuthIn;

typedef struct {
    /*
     * authValues for the created endorsement keys and storage root keys.
     * The size of the authValue can be no larger than the name
     * algorithm of the object.
     * SHA256 by used by default, so the authValue can be no longer
     * than 32 bytes.
     */
    TPM2B_AUTH EKAuth;
    /*
     * Force use EKAuth even if the authValue is 0. THis can be used in
     * situations where we explicitly want to set a password of size 0.
     */
    byteBoolean forceUseEKAuth;

    TPM2B_AUTH SRKAuth;
    /*
     * Force use EKAuth even if the authValue is 0. THis can be used in
     * situations where we explicitly want to set a password of size 0.
     */
    byteBoolean forceUseSRKAuth;
} ContextSetPrimaryKeyAuthIn;

typedef struct {
    /*
     * objectAuthValuelen indicates the maximum length allowable for an authValue
     * when creating objects. The TPM will return an error if the
     * authValue is longer than this value.
     */
    ubyte2 objectAuthValueLen;

    /*
     * hierarchyAuthValueLen indicates the maximum length allowable for a
     * hierarchy authValue. The TPM will return an error if the authValue
     * used for the owner/endorsement/lockout hierarchy is longer than
     * this value.
     */
    ubyte2 hierarchyAuthValueLen;
} ContextGetAuthValueLengthOut;

typedef struct {
    /*
     * Name of the object that must be flushed from the context.
     */
    TPM2B_NAME objName;

    /*
     * Persistent Handle of the object if it needs to be removed from
     * TPM memory
     */
    ubyte4 objectId;
} ContextFlushObjectIn;

typedef struct {
    /*
     * Name of the key that must be evicted
     */
    TPM2B_NAME objName;

    /*
     * Persistent Handle of the object to be removed from
     * TPM memory
     */
    ubyte4 objectId;

    /*
     * Auth handle to use for the persisted key object.
     */
    TPMI_RH_PROVISION authHandle;

    TPM2B_AUTH authHandleAuth;
} EvictKeyIn;

typedef struct {
    /*
     * Serialized object that must be loaded into the FAPI2_CONTEXT.
     * These objects are returned by FAPI's that create keys, sealed
     * objects etc.
     */
    FAPI2B_OBJECT obj;

    /*
     * authValue associated with the object. This parameter may be of size 0
     * if the caller does not wish to have the authValue loaded in
     * the context.
     */
    TPM2B_AUTH objAuth;
} ContextLoadObjectIn;

typedef struct {
    /*
     * Name/handle to the object loaded into the context. FAPI's that use
     * objects will expect the Name/Handle to uniquely identify objects
     * and use them.
     */
    TPM2B_NAME objName;

    /*! algorithm associated with this object */
    TPMI_ALG_PUBLIC objectType;

    /*! object details, including key sizes, scheme etc.*/
    TPMU_PUBLIC_PARMS   parameters;
} ContextLoadObjectOut;

typedef struct {
    /*
     * if set to true, the TPM is provisioend and contains atleast an EK
     * and SRK. If not, the TPM cannot be used for key creation, protecting
     * keys etc. A caller must check this value and must not rely on the
     * return value of the API.
     */
    byteBoolean provisioned;
} ContextIsTpmProvisionedOut;

typedef struct {
    /*
     * Acceptable values:
     * FAPI2_RH_EK - Get name/Handle for the EK(Endorsement Key)
     * FAPI2_RH_SRK - Get name/Handle for the SRK(Storage Root Key)
     * Any other value between FAPI2_RH_PERSISTENT_ENDORSEMENT_START and
     * FAPI2_RH_PERSISTENT_ENDORSEMENT_END. These are usually AK's
     * (Attestation Keys).
     */
    TPMI_DH_PERSISTENT persistentHandle;
} ContextGetPrimaryObjectNameIn;

typedef struct {
    /*
     * Name handle of the object at persistentHandle. Everytime a handle
     * is returned by this API, a slot in the object cache is used.
     */
    TPM2B_NAME objName;
} ContextGetPrimaryObjectNameOut;

typedef struct {
    /*
     * Name of a loaded object, whose authValue must be changed.
     */
    TPM2B_NAME objName;

    /*
     * authValue of the loaded Object. This API can be called with
     * an empty auth, ie size = 0, to clear out the authValue in memory.
     */
    TPM2B_AUTH objAuth;

    /*
     * an Empty authValue typically clears authValue memory and invalidates
     * the authValie. There may be situations where we may explicitly want
     * to use an authValue of size 0. In such cases, this flag must be set.
     */
    /*
     *
     */
    byteBoolean forceUseAuthValue;
} ContextSetObjectAuthIn;

typedef struct {
    /*
     * authValue to be used to protect the data blob in the TPM.
     * The blob can be unsealed using the same authValue.
     * At this point, sealing of the provided data blob is
     * equivalent to password protecting the datablob in the TPM.
     * The size of the authValue can be no larger than the name
     * algorithm of the object.
     * SHA256 by used by default, so the authValue can be no longer
     * than 32 bytes.
     */
    TPM2B_AUTH authValue;

    /*
     * Data blob to seal. It is protected inside the TPM and the
     * authValue provided can be used to unseal this data.
     */
    TPM2B_SENSITIVE_DATA dataToSeal;

    /*
     * Pointer to parents name/handle. This is an optional input.
     * If pParent is NULL or the size is 0, the SRK is selected
     * automatically as a parent.
     * The parent can be any persistent/primary object such as the
     * EK, AK or SRK, in which case, FAPI2_CONTEXT_getPrimaryObjectName()
     * can be used to get the parents name, and passed here.
     * If the parent is a non-persistent object, the caller can
     * get the name returned by using FAPI2_CONTEXT_loadObject().
     * In this case, the entire hierarchy of parent objects must be
     * loaded into the context. Creation will fail, if any object,
     * leading to the hierarchy seeds are missing.
     */
    TPM2B_NAME *pParentName;

    /*
     * Policy nodes. NUmber of policy terms can be 0 and policy nodes
     * can be NULL. If NULL, the default policy of FAPI2_POLICY_AUTH_VALUE
     * will be used
     */
    ubyte2 numPolicyTerms;
    PolicyAuthNode *pPolicy;
} DataSealIn;

typedef struct {
    /*
     * FAPI2B_OBJECT representing and identifying the sealed data.
     * This must be supplied to the unseal API to unseal the
     * protected data blob. This object is suitable for direct
     * storage.
     */
    FAPI2B_OBJECT sealedObject;

} DataSealOut;

typedef struct {
    /*
     * Object representing and identifying the sealed data. This
     * must be the same as the one returned by the seal API.
     */
    FAPI2B_OBJECT sealedObject;

    /*
     * authValue that was used to protect the data blob in the TPM.
     * The size of the authValue can be no larger than the name
     * algorithm of the object.
     * SHA256 by used by default, so the authValue can be no longer
     * than 32 bytes.
     */

    TPM2B_AUTH authValue;
    /*
     * Policy nodes. NUmber of policy terms can be 0 and policy nodes
     * can be NULL. If NULL, the default policy of FAPI2_POLICY_AUTH_VALUE
     * will be used
     */
    ubyte2 numPolicyTerms;
    PolicyAuthNode *pPolicy;
} DataUnsealIn;

typedef struct {
    /*
     * Unsealed data.
     */
    TPM2B_SENSITIVE_DATA unsealedData;
} DataUnsealOut;

typedef struct {
    /*
     * Hash algorithm to use to digest the data. This must be TPM2_ALG_SHA256,
     * TPM2_ALG_SHA384 or TPM2_ALG_SHA512. Note that one or all of these
     * algorithms may not be supported by the TPM hardware and an error will
     * be returned in such cases.
     */
    TPMI_ALG_HASH hashAlg;

    /*
     * Buffer length and pointer to buffer of the data to be digested.
     */
    ubyte4 bufferLen;
    ubyte *pBuffer;
} DataDigestIn;

typedef struct {
    /*
     * Digest of input data.
     */
    TPM2B_DIGEST digest;
} DataDigestOut;

typedef struct {
    /*
     * This must be TPM2_ALG_SHA256, TPM2_ALG_SHA384 or TPM2_ALG_SHA512.
     * Each hash algorithm has a PCR bank associated with it in the TPM
     * and this API will return the bitmask for the corresponding hash
     * algorithm. If the algorithm is not implemented by the TPM, the
     * API will return an error.
     */
    TPMI_ALG_HASH hashAlg;
} MgmtGetPcrSelectionIn;

typedef struct {
    /*
     * This is the bitmask returned by the API. Each bit indicates the PCR
     * number that is implemented and valid for a given hash algorithm.
     * This can be used in advanced API's to obtain creation data for
     * created objects with a particular set of PCR's etc, or simply to know
     * what PCR's are valid, when requesting quotes etc.
     */
    ubyte4 pcrSelection;

    /*
     * pcrSelection is a 32 bit value. However not all TPM's implement 32
     * PCR's. For example, PC Client TPM's only implement 24 PCR's which is
     * the most common case. This field effectively tells the number of
     * valid bytes in the pcrSelection field. For ex, If this is 2 bytes,
     * only 16 PCR's are implemented.
     */
    ubyte numBytesPcrSelection;
} MgmtGetPcrSelectionOut;

typedef struct {
    /*
     * Since this API is a direct map of the TPM2_GetCapability command,
     * refer to the TPM library specification for the acceptable values.
     */
    TPM2_CAP capability;
    ubyte4 property;
    ubyte4 propertyCount;
} MgmtCapabilityIn;

typedef struct {
    /*
     * Since this API is a direct map of the TPM2_GetCapability command,
     * refer to the TPM library specification for the acceptable values.
     */
    TPMI_YES_NO moreData;
    TPMS_CAPABILITY_DATA capabilityData;
} MgmtCapabilityOut;

typedef struct {

    /*
     * NV index that is being defined. This is in the range
     * TPM2_NV_INDEX_FIRST(0x01000000) - TPM2_NV_INDEX_LAST(0x01FFFFFF)
     */
    TPMI_RH_NV_INDEX nvIndex;

    /*
     * The type of NV index. This must be TPM2_NT_ORDINARY, TPM2_NT_COUNTER,
     * TPM2_NT_BITS, TPM2_NT_EXTEND. No other values are allowed.
     *
     * TPM2_NT_ORDINARY creates an ordinary index of arbitrary size.
     *
     * TPM2_NT_EXTEND creates an index with size equal to the Name algorithm
     * digest size. By default, the name algorithm is SHA256, so the size of
     * the TPM2_NT_EXTEND index is 32 bytes.
     *
     * TPM2_NT_BITS - Creates a 64 bit index. No other size is allowed.
     *
     * TPM2_NT_COUNTER - Creates a 8 byte counter index. No other size is allowed.
     */
    ubyte nvIndexType;

    /*
     * Size(bytes) of the data that resides in the NV index. This is only required
     * for nvIndexType of TPM2_NT_ORDINARY. THe size is implied for other types.
     * TPM2_NT_BITS, TPM2_NT_COUNTER have a implicit size of 8 bytes.
     * TPM2_NT_EXTEND - Size depends on the Name algorithm in the FAPI2_CONTEXT.
     */
    ubyte2 dataSize;

    /*
     * authValue for the NV index.
     * This authValue can be used to read and write the index in the absences
     * of the owner hierarchy authValue.
     * If this parameter is of size 0, the owner hierarchy authValue must be used
     * to read/write access the index.
     */
    TPM2B_AUTH nvAuth;

    /*
     * Set this to TRUE to disable the TPM's dictionary attack protection on the
     * NV index. This must be used carefully since the NV index can be vulnerable
     * if a weak authValue is used for the owner authValue or the nv index authValue.
     */
    byteBoolean disableDA;

    /*
     * Policy nodes. NUmber of policy terms can be 0 and policy nodes
     * can be NULL. If NULL, the default policy of FAPI2_POLICY_AUTH_VALUE
     * will be used
     */
    ubyte2 numPolicyTerms;
    PolicyAuthNode *pPolicy;

    /*
     * Auth Handle to use for NV-Index object.
     * Default is TPM_RH_OWNER. Objects with auth-handle set to owner will be lost on clear ownership.
     * Objects created with auth-handle TPM_RH_PLATFORM will persist even on TPM clear ownership
     */
    TPMI_RH_PROVISION authHandle;

    /*
     * Optional Authentication value for authHandle
     */
    TPM2B_AUTH  authHandleAuth;

} NVDefineIn;

typedef struct {
    /*
     * NV index that is being Undefined. This is in the range
     * TPM2_NV_INDEX_FIRST(0x01000000) - TPM2_NV_INDEX_LAST(0x01FFFFFF)
     */
    TPMI_RH_NV_INDEX nvIndex;

    /*
     * Auth Handle to use for NV-Index object.
     * Default is owner/storage
     */
    TPMI_RH_PROVISION authHandle;

    /*
     * Optional Authentication value for authHandle
     */
    TPM2B_AUTH  authHandleAuth;
} NVUndefineIn;

typedef union {
    /*
     * TPM2_NT_ORDINARY and TPM2_NT_EXTEND selects this field
     */
    TPM2B_MAX_NV_BUFFER writeData;
    /*
     * TPM2_NT_BITS selects this.
     */
    ubyte8 writeValBits;

    /*
     * byte required for serialization. This need not be set to any value.
     */
    ubyte dummy;
} FAPI2_NV_WRITE_UNION;

typedef struct {
    /*
     * NV index that is being written. This is in the range
     * TPM2_NV_INDEX_FIRST(0x01000000) - TPM2_NV_INDEX_LAST(0x01FFFFFF)
     */
    TPMI_RH_NV_INDEX nvIndex;

    /*
     * authValue to be used for the write operation. If this is of size 0,
     * the owner hierarchy authValue from the FAPI2_CONTEXT will be
     * used.
     */
    TPM2B_AUTH nvAuth;

    /*
     * See description of FAPI2_NV_WRITE_OP. This API will
     * check to ensure that the write op can be performed on the
     * given index before sending commands to the TPM.
     */
    FAPI2_NV_WRITE_OP writeOp;

    /*
     * Based on the writeOp, writeData or writeValBits is used. For
     * NV index type of TPM2_NT_ORDINARY and TPM2_NT_EXTEND,
     * writeData is used. For NV index type of TPM2_NT_BITS, writeValbits
     * is used. For other types, this field is ignored.
     * The writeData must match the size of the NV index created exactly.
     * No partial writes are allowed.
     */
    FAPI2_NV_WRITE_UNION write;

    /*
     * Auth Handle to use for NV-Index object.
     * Default is owner/storage
     */
    TPMI_RH_PROVISION authHandle;

    /*
     * Optional Authentication value for authHandle
     */
    TPM2B_AUTH  authHandleAuth;
} NVWriteOpIn;

typedef struct {
    /*
     * NV index that is being read. This is in the range
     * TPM2_NV_INDEX_FIRST(0x01000000) - TPM2_NV_INDEX_LAST(0x01FFFFFF)
     */
    TPMI_RH_NV_INDEX nvIndex;

    /*
     * authValue to be used for the read operation. If this is of size 0,
     * the owner hierarchy authValue from the FAPI2_CONTEXT will be
     * used.
     */
    TPM2B_AUTH nvAuth;

    /*
     * Auth Handle to use for NV-Index object.
     * Default is owner/storage
     */
    TPMI_RH_PROVISION authHandle;

    /*
     * Optional Authentication value for authHandle
     */
    TPM2B_AUTH  authHandleAuth;
} NVReadOpIn;

typedef struct {
    /*
     * Data from the NV index.
     */
    TPM2B_MAX_NV_BUFFER readData;
} NVReadOpOut;


typedef struct
{
    /*! The NV Index for which to read the public information */
    TPMI_RH_NV_INDEX nvIndex;
} NVReadPubIn;

typedef struct
{
    /*! The public information for the NV index */
    TPM2B_NV_PUBLIC nvPublic;
    /*! */
    TPM2B_NAME nvName;
} NVReadPubOut;

typedef struct {
    /*
     * Number of random bytes requested. any number of bytes can be
     * requested, but the TPM will only return the number bytes equal
     * to the largest digest supported by the TPM. If a TPM only
     * supports SHA256, 32 bytes of data is the maximum that will be
     * returned. No error is returned. Instead, the size field of the
     * returned random bytes must be checked.
     */
    ubyte2 bytesRequested;
} RngGetRandomDataIn;

typedef struct {
    /*
     * TPM generated random bytes.
     */
    TPM2B_DIGEST randomBytes;
} RngGetRandomDataOut;

typedef struct {
    /*
     * "additional information" is as defined in SP800-90A.
     * This is optional and may be of size 0. If provided
     * the data may be no longer than 128 bytes.
     */
    TPM2B_SENSITIVE_DATA additionalData;
} RngStirRNGIn;

typedef struct {
    TPM2_RC tpmError;
} ContextGetLastTpmErrorOut;

typedef struct {
    /*
     * authValue to be used for the new symmetric Key.
     * The size of the authValue can be no larger than the name
     * algorithm of the object.
     * SHA256 is the name algorithm used by default, so the authValue can be no longer
     * than 32 bytes.
     */
    TPM2B_AUTH keyAuth;

    /*
     * Symmetric Cipher that will be used with the Symmetric Key. This can be:
     * TPM2_ALG_AES - For AES encryption/decryption Keys
     * Only AES is supported by FAPI currently. This field is present to expand support
     * to other symmetric ciphers in the future.
     */
    TPMI_ALG_SYM_OBJECT symAlg;

    /*
     * Length of the symmetric key in bits. This can be 128, 192 or 256 bits. Other
     * values will return errors. A given TPM may or may not implement any
     * or all of these key sizes. These are the key sizes that FAPI supports.
     */
    ubyte2 keyBits;

    /*
     * Mode of operation for the symmetric cipher. The following values are acceptable:
     * TPM2_ALG_CTR, TPM2_ALG_OFB, TPM2_ALG_CBC, TPM2_ALG_CFB, TPM2_ALG_ECB.
     * TPM2_ALG_NULL if the mode will be supplied during the invocation of the encrypt/decrypt
     * API. This option can be used in case the key is expected to be used with multiple
     * modes.
     * Note that a given TPM may or may not implement any or all of these modes. These
     * are the modes that FAPI is aware of and supports.
     */
    TPMI_ALG_SYM_MODE symMode;

    /*
     * Pointer to parents name/handle. This is an optional input.
     * If pParent is NULL or the size is 0, the SRK is selected
     * automatically as a parent.
     * The parent can be any persistent/primary object such as the
     * EK, AK or SRK, in which case, FAPI2_CONTEXT_getPrimaryObjectName()
     * can be used to get the parents name, and passed here.
     * If the parent is a non-persistent object, the caller can
     * get the name returned by using FAPI2_CONTEXT_loadObject().
     * In this case, the entire hierarchy of parent objects must be
     * loaded into the context. Creation will fail, if any object,
     * leading to the hierarchy seeds are missing.
     */
    TPM2B_NAME *pParentName;

    /*
     * Policy nodes. NUmber of policy terms can be 0 and policy nodes
     * can be NULL. If NULL, the default policy of FAPI2_POLICY_AUTH_VALUE
     * will be used
     */
    ubyte2 numPolicyTerms;
    PolicyAuthNode *pPolicy;
    byteBoolean bEnableBackup; 

} SymCreateCipherKeyIn;

typedef AsymCreateKeyOut SymCreateCipherKeyOut;

/*
 * The reason we have separate create parameters for cipher vs signing symmetric key is
 * because they are different object types in the TPM2 and also it is generally good
 * practice to use different keys for encryption and signing. This is true even of
 * asymmetric keys, which is why using a legacy asymmetric key(ie same key for signing
 * and encrypt/decrypt) is discouraged. In the symmetric case, the TPM does not allow
 * the use of the same key for symmetric encrypt/decrypt and signing, but for asymmetric
 * key it does. The decision to have separate parameters for encryption and signing
 * symmetric keys reflects the TPM2 specifications.
 */
typedef struct {
    /*
     * authValue to be used for the new symmetric Key.
     * The size of the authValue can be no larger than the name
     * algorithm of the object.
     * SHA256 is the name algorithm used by default, so the authValue can be no longer
     * than 32 bytes.
     */
    TPM2B_AUTH keyAuth;

    /*
     * The size of the hmac key created depends on the nameAlg for a given object.
     * The default nameAlg in a FAPI2 context is SHA256, so the size of the HMAC
     * key created is 256 bits. The key size can be changed by changing the nameAlg
     * in a FAPI2 context. Changing of nameAlg is not supported currently so a
     * symmetric signing key has a size of 256 bits.
     */

    /*
     * Symmetric signing scheme. The valid values are:
     * TPM2_ALG_HMAC - performs HMAC signature.
     * As of now only HMAC signature is supported. Other signature schemes may be added
     * in the future.
     */
    TPMI_ALG_KEYEDHASH_SCHEME sigScheme;

    /*
     * Hash algorithm to be used when signing. The valid values are:
     * TPM2_ALG_SHA256, TPM2_ALG_SHA384 and TPM2_ALG_SHA512. Note that a given TPM
     * may not support any or all of the above algorithms. These are the algorithms
     * that FAPI is aware of and supports.
     * This is only used if sigScheme is a valid scheme such as TPM2_ALG_HMAC, and is ignored
     * otherwise.
     */
    TPMI_ALG_HASH hashAlg;

    /*
     * Pointer to parents name/handle. This is an optional input.
     * If pParent is NULL or the size is 0, the SRK is selected
     * automatically as a parent.
     * The parent can be any persistent/primary object such as the
     * EK, AK or SRK, in which case, FAPI2_CONTEXT_getPrimaryObjectName()
     * can be used to get the parents name, and passed here.
     * If the parent is a non-persistent object, the caller can
     * get the name returned by using FAPI2_CONTEXT_loadObject().
     * In this case, the entire hierarchy of parent objects must be
     * loaded into the context. Creation will fail, if any object,
     * leading to the hierarchy seeds are missing.
     */
    TPM2B_NAME *pParentName;

    /*
     * Policy nodes. NUmber of policy terms can be 0 and policy nodes
     * can be NULL. If NULL, the default policy of FAPI2_POLICY_AUTH_VALUE
     * will be used
     */
    ubyte2 numPolicyTerms;
    PolicyAuthNode *pPolicy;
    byteBoolean bEnableBackup; 

} SymCreateSigningKeyIn;

typedef AsymCreateKeyOut SymCreateSigningKeyOut;
typedef AsymCreateKeyOut SymCreateKeyOut;

typedef struct {
    /*
     * Key with which the data must be encrypted/decyrpted. The key must be
     * a encryption/decryption key created with FAPI2_SYM_createCipherKey.
     */
    TPM2B_NAME keyName;

    /*
     * Flag to indicate if this is a request for encryption or decryption.
     * If the flag is true, decryption is being requested, else encryption.
     */
    byteBoolean isDecryption;

    /*
     * Mode of operation for the symmetric cipher. The following values are acceptable:
     * TPM2_ALG_CTR, TPM2_ALG_OFB, TPM2_ALG_CBC, TPM2_ALG_CFB, TPM2_ALG_ECB.
     * TPM2_ALG_NULL if the mode was set during creation. If the mode was set during
     * creation, this field will be ignored and the mode provided during key creation
     * is used.
     * Note that a given TPM may or may not implement any or all of these modes. These
     * are the modes that FAPI is aware of and supports.
     */
    TPMI_ALG_SYM_MODE symMode;

    /*
     * Initialization vector as required by the mode of operation. Security of the encryption
     * depends on choosing of the correct IV and the caller is responsible for providing the
     * correct IV
     */
    TPM2B_IV iv;

    /*
     * length of data that must be encrypted or decrypted and pointer to data buffer.
     * For CBC and ECB mode of encryption, the buffer size must be a multiple of the
     * block size, for example, for AES, the buffer length must always be a multiple
     * of 16 bytes.
     */
    ubyte4 bufferLen;
    ubyte *pBuffer;
} SymEncryptDecryptIn;

typedef struct {
    /*
     * Length and pointer to buffer of plainText of CipherText.
     * The buffer is allocated by the API and must be free'd by the caller
     * using shredMemory or DIGI_FREE.
     */
    ubyte4 outLen;
    ubyte *pOutBuffer;
} SymEncryptDecryptOut;

typedef struct {
    /*
     * The key with which symmetric signing must be performed. This must be a
     * symmetric signing key created with FAPI2_SYM_createSigningKey. The
     * scheme and hash algorithm provided during key creation will be used to
     * sign the digest.
     */
    TPM2B_NAME keyName;

    /*
     * Digest to be signed.
     */
    TPM2B_DIGEST signDigest;
} SymSignIn;

typedef struct {
    /*
     * Output signature buffer.
     */
    TPM2B_DIGEST signature;
} SymSignOut;

typedef struct {

    /*
     * The key used to verify the signature.
     * The key provided must be created using FAPI2_SYM_createSigningKey.
     * The key must be loaded in the FAPI2_CONTEXT before this API
     * is called with its authValue set. This is a symmetric key so we
     * require the authValue for both signing and verifying, since both
     * operations use the same key.
     * The scheme and hash algorithm specified during key creation will
     * be used for verification.
     */
    TPM2B_NAME keyName;

    /*
     * Digest on which the signature is to be verified.
     */
    TPM2B_DIGEST digest;

    /*
     * Input signature buffer
     */
    TPM2B_DIGEST signature;

} SymVerifySigIn;

typedef struct {
    /*
     * Returned value is TRUE if the signature verification succeeded. FALSE
     * otherwise. Success of the signature verification API does not mean
     * the signature validation succeeded. THis field must be used by
     * applications to know if the signature verification succeeded or failed.
     */
    byteBoolean sigValid;
} SymVerifySigOut;

typedef struct {
    /*
     * Encrypted and integrity protected secret. This secret is typically
     * a symmetric key used to wrap/encrypt a certificate but may be anything
     * that the credetnail creator sees fit.
     */
    TPM2B_ID_OBJECT secretBlob;

    /*
     * Asymmetrically encrypted seed used to derive the encryption and integrity
     * keys.
     */
    TPM2B_ENCRYPTED_SECRET encryptedSeed;

    /*
     * Key for which the credential is be activated. The key must be loaded in the
     * context and have its authValue set.
     */
    TPM2B_NAME activateKey;

    /*
     * Encryption Key against which the seed was encrypted. The key must be loaded in the
     * context and have its authValue set. This must be a restricted decryption key ie,
     * of type FAPI2_ASYM_TYPE_STORAGE.
     */
    TPM2B_NAME decryptKey;
} CredentialActivateIn;

typedef struct {
    /*
     * Unwrapped/Activated secret, usually a symmetric key that can be used to
     * unwrap/decrypt a certificate. This can however be any data that the
     * credential maker(typically a CA) sees fit.
     */
    TPM2B_DIGEST secret;
} CredentialActivateOut;

typedef struct {
    /*
     * Asymmetric key using which the seed is encrypted. This is typically an external key
     * loaded into the FAPI2 context. The key need not have its authValue set but must be
     * loaded in the context.
     */
    TPM2B_NAME encryptKey;

    /*
     * Name of the object to which the secret applies to. They key need not be loaded and
     * does not require the authValue to be set.
     */
    TPM2B_NAME activateKeyName;

    /*
     * Secret to wrap, usually a symmetric key that can be used to encrypt a certificate or
     * credential. This can however be any data.
     */
    TPM2B_DIGEST secret;
} CredentialMakeIn;

typedef struct {
    /*
     * Encrypted and integrity protected secret. This secret is typically
     * a symmetric key used to wrap/encrypt a certificate but may be anything
     * that the credetnail creator sees fit.
     */
    TPM2B_ID_OBJECT secretBlob;

    /*
     * Asymmetrically encrypted seed used to derive the encryption and integrity
     * keys.
     */
    TPM2B_ENCRYPTED_SECRET encryptedSeed;
} CredentialMakeOut;

typedef struct {
    /*
     * Key to be used for signing the quote. This key must be of type
     * FAPI2_ASYM_TYPE_ATTESTATION, ie a restricted signing key. The
     * signature scheme that was provided during creation will be used
     * to sign the quote. The key must be loaded in the context and its
     * authValue must be set.
     */
    TPM2B_NAME quoteKey;

    /*
     * Data that needs to be signed along with PCR's. This is typically a nonce.
     */
    TPM2B_DATA qualifyingData;

    /*
     * Each bit represents 1 PCR. Setting bit 0, indicates PCR0, bit 1 PCR1 and so on.
     */
    ubyte4 pcrSelection;

} AttestationGetQuoteIn;

typedef struct {

    /*
     * TPM2 Quote Structure. The structure is in serialized format for ease of
     * transmission. The structure must be de-serialized by the caller before seeing
     * the quoted information.
     */
    TPM2B_ATTEST quoted;

    /*
     * This value is TPM2_ALG_RSA or TPM2_ALG_ECC. This serves as the selector
     * for the signature union.
     */
    TPMI_ALG_PUBLIC keyAlg;

    /*
     * rsaSignature contains the signature buffer if the chosen scheme
     * was TPM2_ALG_RSASSA or TPM2_ALG_RSAPSS.
     * eccSignature contains the signature buffer for R and S if the
     * chosen signature scheme was TPM2_ALG_ECDSA or TPM2_ALG_ECSCHNORR.
     */
    FAPI2_SIGNATURE_UNION signature;
} AttestationGetQuoteOut;

typedef struct {

    /*
     * PCR index being reset. This is in the range
     * 0 - 23 
     */
    ubyte pcrIndex;

    /*
     * authValue for the PCR index.
     */
    TPM2B_AUTH pcrAuth;
} IntegrityPcrResetIn;

typedef struct {

    /*
     * PCR index being reset. This is in the range
     * 0 - 23
     */
    ubyte pcrIndex;

    /*
     * authValue for the PCR index.
     */
    TPM2B_AUTH pcrAuth;

    /*
     * TPM2_ALG_SHA1, TPM2_ALG_SHA256/384/512. This is used to select the PCR bank
     * from which the PCR values are read.
     * A TPM may or may not implement PCR banks for all hash algorithms. The most
     * likely PCR bank to be implemented would be SHA256.
     * This is the bank into which the digest will be extended.
     */
    TPMI_ALG_HASH hashAlg;

    /*
     * Digest to be extended.
     */
    TPM2B_DIGEST digest;
} IntegrityPcrExtendIn;

typedef struct {
    /*
     * Each bit represents 1 PCR. Setting bit 0, indicates PCR0, bit 1 PCR1 and so on.
     * Only 8 PCR's can be read at a given time. The API will return an error if more
     * than 8 bits are set.
     */
    ubyte4 pcrSelection;

    /*
     * TPM2_ALG_SHA1, TPM2_ALG_SHA256/384/512. This is used to select the PCR bank
     * from which the PCR values are read.
     * A TPM may or may not implement PCR banks for all hash algorithms. The most
     * likely PCR bank to be implemented would be SHA256.
     */
    TPMI_ALG_HASH hashAlg;
} IntegrityPcrReadIn;

typedef struct {
    /*
     * Number of times any/all PCRs have been updated.
     */
    ubyte4 pcrUpdateCount;

    /*
     * List of PCR values. Lowest index in the list corresponds to the lower
     * PCR index number.
     */
    TPML_DIGEST pcrDigests;
} IntegrityPcrReadOut;

typedef struct {
    /*
     * Key for which the credential is be activated. The key must be loaded in the
     * context. The authValue need not be set.
     * This must be a restricted signing key, ie of type FAPI2_ASYM_TYPE_ATTESTATION.
     */
    TPM2B_NAME activateKey;

    /*
     * Encryption Key against which the seed will be encrypted. The key must be loaded in the
     * context and need not have its authValue set. This must be a restricted decryption key ie,
     * of type FAPI2_ASYM_TYPE_STORAGE.
     */
    TPM2B_NAME decryptKey;

} CredentialGetCsrAttrIn;

typedef struct {
    /*
     * Base64 Blob containing information required by a server issuing certificates
     * for attestation keys. This includes the base 64 encoded blob of data whose
     * formate is as follows:
     * 4 bytes - TPMA_OBJECT, Object attributes of the encryption key(EK)
     * 2 bytes - TPM2_ALG_ID, Name algorithm of the encryption key(EK)
     * x bytes - TPMT_PUBLIC, Public area of the attestation key. The size of this depends
     *           on the type and parameters of the Attestation key.
     *
     * The blob must be free;d using DIGI_FREE once it is no longer required.
     */
    ubyte4 blobLen;
    ubyte *pBase64Blob;
} CredentialGetCsrAttrOut;

typedef struct {

    /*
     * Key for which the credential is be activated. The key must be loaded in the
     * context and have its authValue set.
     */
    TPM2B_NAME activateKey;

    /*
     * Encryption Key against which the seed was encrypted. The key must be loaded in the
     * context and have its authValue set. This must be a restricted decryption key ie,
     * of type FAPI2_ASYM_TYPE_STORAGE.
     */
    TPM2B_NAME decryptKey;

    /*
     * base64blob returned by the credential issuer. This is a base64 encoded blob,
     * that contains the serialized structure containing a TPM2B_ID_OBJECT and
     * TPM2B_ENCRYPTED_SECRET. The blob returned by the credential issuer can be
     * directly passed to this API and the base64 decoding and conversion to TPM
     * specific structures is handled internally.
     */
    ubyte4 blobLen;
    ubyte *pBase64Blob;
} CredentialUnwrapSecretIn;

typedef CredentialActivateOut CredentialUnwrapSecretOut;

typedef struct {
    /*
     * Name/handle to a loaded object, for which private information is
     * required.
     */
    TPM2B_NAME object;
} ContextGetObjectPrivateInfoIn;

typedef struct {
    TPM2B_PRIVATE privateInfo;
} ContextGetObjectPrivateInfoOut;

typedef struct {
    ubyte pBuffer[sizeof(TPM2B_PRIVATE)];
    ubyte4 size;
} ContextGetObjectPrivateInfoBlobOut;

typedef struct {
    /*
     * Name/handle to a loaded object, for which public information is
     * required.
     */
    TPM2B_NAME object;
} ContextGetObjectPublicInfoIn;

typedef struct {
    TPMT_PUBLIC publicInfo;
} ContextGetObjectPublicInfoOut;

typedef struct {
    TPM2B_PUBLIC_BLOB publicInfo;
} ContextGetObjectPublicInfoBlobOut;

typedef struct {
    TPM2B_NAME keyName;
    TPM2B_PUBLIC_BLOB *pNewParent;
    TPMI_RH_HIERARCHY newParentHierarchy;
} FAPI2_DuplicateIn;       



typedef struct {
    TPM2B_DATA			encryptionKeyOut;
    TPM2B_PRIVATE		duplicate;
    TPM2B_ENCRYPTED_SECRET	outSymSeed;
    TPMT_SYM_DEF_OBJECT symmetricAlg;
    TPM2B_PUBLIC		objectPublic;
}FAPI2_DuplicateOut;

/*
 * Structure representing a serialized FAPI2 object. This structure is
 * suitable for storage into files etc.
 */

typedef struct {
    ubyte2 size;
    ubyte buffer[sizeof (FAPI2_DuplicateOut)];
} FAPI2B_DUPLICATE;

typedef struct {
    TPM2B_NAME          parentName;
    FAPI2B_DUPLICATE    *pFapiDup ;
}FAPI2_ImportIn;

typedef struct {
    FAPI2B_OBJECT object;
    TPM2B_NAME keyName;
    TPMI_ALG_PUBLIC keyAlg;

    /*
     * Public Key of the imported key.
     */
    FAPI2_PUBLIC_KEY_UNION publicKey;
}FAPI2_ImportOut;

typedef struct {
    /*
     * Key used for the HMAC operation. The key must be
     * a HMAC key created with HMAC flag (Signing key).
     */
    TPM2B_NAME keyName;

    /*
       Hash algorithm to use
     */
    TPM2_ALG_ID hashAlg;

    /*
     * length of data used to generate HMAC of data buffer.
     * for example, for AES, the buffer length must always be a multiple
     * of 16 bytes.
     */
    ubyte4 bufferLen;
    ubyte *pBuffer;
} SymHmacIn;

typedef struct {
    /*
     * Length and pointer to buffer containing HMAC digest.
     * The buffer is allocated by the API and must be free'd by the caller
     * using shredMemory or DIGI_FREE.
     */
    ubyte4 outLen;
    ubyte *pOutBuffer;
} SymHmacOut;

#endif  /* (defined(__ENABLE_DIGICERT_TPM2__)) */
#endif /* __FAPI2_TYPES_H__ */
