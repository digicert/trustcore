/**
 * @file fapi2_utils_internal.h
 * @brief This file contains utility functions to be used with FAPI.
 *
 * @flags
 *  To enable this file's functions, the following flags must be defined in
 * moptions.h:
 *
 *  + \c \__ENABLE_DIGICERT_TPM2__
 *
 * Copyright 2025 DigiCert Project Authors. All Rights Reserved.
 * 
 * DigiCert® TrustCore and TrustEdge are licensed under a dual-license model:
 * - **Open Source License**: GNU AGPL v3. See: https://github.com/digicert/trustcore-test/blob/main/LICENSE
 * - **Commercial License**: Available under DigiCert’s Master Services Agreement. See: https://github.com/digicert/trustcore-test/blob/main/LICENSE_COMMERCIAL.txt  
 *   or https://www.digicert.com/master-services-agreement/
 * 
 * *For commercial licensing, contact DigiCert at sales@digicert.com.*
 *
 */
#ifndef __FAPI2_UTILS_INTERNAL_H__
#define __FAPI2_UTILS_INTERNAL_H__

#include "../../../../common/moptions.h"

#if (defined(__ENABLE_DIGICERT_TPM2__))
#include "../tpm2_types.h"
#include "fapi2_context.h"
#include "../sapi2/sapi2.h"

/*
 * The maximum policy terms that can exist in a chain. This can be increased
 * or decreased as necessary.
 * This has an impact on the size of FAPI2_OBJECT and mus tbe adjusted
 * carefully.
 */
#define FAPI2_MAX_POLICY_CHAIN_LENGTH 3

#define TPM2B_MAX_SIZE(pTpm2b)\
    (sizeof(*(pTpm2b)) - sizeof((pTpm2b)->size))

#define TPM2B_SIZE_CHECK(pTpm2b, check_size) \
    if (((pTpm2b)->size) > check_size) \
    {\
        rc = TSS2_SYS_RC_BAD_VALUE;\
        DB_PRINT("%s.%d TPM2B size greater than expected, \
                rc 0x%02x = %s\n", \
                __FUNCTION__,__LINE__, rc, tss2_err_string(rc)); \
        goto exit; \
    }

extern PolicyAuthNode tcgEKPolicy;

typedef struct FAPI2_OBJECT
{
    /*
     * Used to identify and operate on persistent/primary objects.
     */
    TPM2_HANDLE objectHandle;

    byteBoolean authValueValid;
    TPM2B_AUTH authValue;

    /*
     * Handle for the objects parent.
     *
     * This is only required if the parent of this object is a persistent/primary
     * object(for ex: EK, SRK or other primary/persistent keys keys).
     * It is ignored otherwise. This field must be a valid persistent handle in the range
     * TPM2_PERSISTENT_FIRST - TPM2_PERSISTENT_LAST for parents that are primary keys
     * and ZERO, if the objects parent is a non-persistent object.
     *
     * If this object is an NV index, persistent/primary object or an external
     * object, parentHandle AND parentName are ignored, since they are implicit.
     * NV indexes and persistent/primary objects have primary seeds as parents,
     * and external objects have the NULL hierarchy seed as parents.
     *
     * If both parentHandle and parentName are 0, then the parent is assumed
     * to be the default SRK at FAPI2_RH_SRK.
     */
    TPM2_HANDLE parentHandle;

    /*
     * Name of this objects parent.
     *
     * This is only required if the parent of this object is a non-persistent object.
     * For NV indexes, primary/persistent keys and external objects, the parents are
     * implicit and so are their Names.
     *
     * For NV indexes, persistent/primary objects and external objects,
     * parentName is not stored, since it can be read off the TPM or if needed.
     * This also saves space when the object is serialized to disk.
     *
     * parentHandle takes precedence over this field. This field is only used if
     * the parentHandle is 0.
     *
     * If both parentHandle and parentName are 0, then the parent is assumed
     * to be the default SRK.
     */
    TPM2B_NAME parentName;

    /*
     * Flag to specify if this is the private area was generated by
     * the TPM or was provided externally.
     */
    ubyte2 isExternal;
    union {
        TPM2B_PRIVATE tpmPrivate;
        TPM2B_SENSITIVE sensitive;
    } private;

    union {
        TPM2B_PUBLIC objectPublic;
        TPM2B_NV_PUBLIC nvPublic;
    } public;

    TPM2B_NAME objectName;
    TPM2B_CREATION_DATA creationData;
    TPM2B_DIGEST creationHash;
    TPMT_TK_CREATION creationTicket;

    ubyte2 numPolicyTerms;
    PolicyAuthNode objectPolicy[FAPI2_MAX_POLICY_CHAIN_LENGTH];

    /*
     * Field to indicate if authValue is required to use an object. This
     * is required, if the object has a policy term of TPM2_PolicyAuthValue
     * or has no policy.
     */
    byteBoolean authValueRequired;
} FAPI2_OBJECT;

typedef struct {
    /*
     * This API only supports creating FAPI2 objects for persistent handles
     * in the range, 0x81000000 - 0x817FFFFF and nv indexes in the range
     * 0x01000000 - 0x01FFFFFF.
     * This MUST be 0 for non-persistent object.
     */
    TPM2_HANDLE tpm2Handle;

    /*
     * AuthValue to be associated with the new object.
     * This field will not be serialized during object
     * serialization for storage. If this is NULL, the
     * authValue is set to a buffer of size 0.
     */
    TPM2B_AUTH *pAuthValue;

    /*
     * Public area returned by the TPM for an object. This must be provided
     * for every non persistent object. This is optional for persistent/primary
     * and NV objects. If one is not provided, the public area is read from the
     * TPM using TPM2_ReadPublic(Nv)
     */
    TPM2B_PUBLIC *pPublic;

    TPM2B_NV_PUBLIC *pNvPublic;

    /*
     * Private area returned by the TPM for an object. This shall be NULL
     * for persistent/primary and NV objects, since the private data is never
     * returned. If pPrivate is NULL, the object is marked as an externally
     * created object, ie one that is not protected by the TPM. Such objects
     * are useful when the TPM is used as a crypto engine.
     */
    TPM2B_PRIVATE *pPrivate;

    /*
     * Sensitive area, that can be provided to load external RSA/ECC/Symmetric
     * objects into the TPM using TPM2_LoadExternal. This is useful when we
     * want to laod external objects and use the TPM2 as a crypto engine.
     * This must be NULL for persistent/primary and NV objects. If this
     * field is provided, the object is marked as an externally created object
     * ie one that is not protected by the TPM. Such objects are useful
     * when the TPM is used as a crypto engine. If both pPrivate and
     * pSensitive are provided, pPrivate will be used. The sensitive area
     * is not checked for consistency against pPublic. Errors may occur during
     * use of the object. If both pPrivate and pSensitive are not provided(NULL),
     * the object is marked external. THis is useful for asymmetric objects
     * to perform public operations like encrypt and verifysignature.
     */
    TPM2B_SENSITIVE *pSensitive;

    /*
     * Creation data returned by TPM2_CreatePrimary or
     * TPM2_Create. These can be NULL if the caller is not interested
     * in having them as part of their serialization or does not apply
     * for the object type.
     */
    TPM2B_CREATION_DATA *pCreationData;
    TPM2B_DIGEST *pCreationHash;
    TPMT_TK_CREATION *pCreationTicket;

    /*
     * Handle for the objects parent.
     *
     * This is only required if the parent of this object is a persistent/primary
     * object(for ex: EK, SRK or other primary/persistent keys keys).
     * It is ignored otherwise. This field must be a valid persistent handle in the range
     * TPM2_PERSISTENT_FIRST - TPM2_PERSISTENT_LAST for parents that are primary keys
     * and ZERO, if the objects parent is a non-persistent object.
     *
     * If this object is an NV index, persistent/primary object or an external
     * object, parentHandle AND parentName are ignored, since they are implicit.
     * NV indexes and persistent/primary objects have primary seeds as parents,
     * and external objects have the NULL hierarchy seed as parents.
     *
     * If both parentHandle and parentName are 0, then the parent is assumed
     * to be the default SRK at FAPI2_RH_SRK.
     *
     * 0 is chosen instead of TPM2_RH_NULL as parentHandle value for non-persistent
     * objects, since all existing code will need to be updated to use TPM2_RH_NULL.
     * If it is 0, in all likelihood, this structure would be initialized to 0 and hence
     * removing the need for code to be updated in many places.
     */
    TPM2_HANDLE parentHandle;

    /*
     * Name of this objects parent.
     *
     * This is only required if the parent of this object is a non-persistent object.
     * For NV indexes, primary/persistent keys and external objects, the parents are
     * implicit and so are their Names.
     *
     * For NV indexes, persistent/primary objects and external objects,
     * parentName is not stored, since it can be read off the TPM or if needed.
     * This also saves space when the object is serialized to disk.
     *
     * parentHandle takes precedence over this field. This field is only used if
     * the parentHandle is 0.
     *
     * if parentHandle is 0 and pParentName is NULL or size of the name is 0,
     * then the parent is assumed to be the default SRK.
     */
    TPM2B_NAME *pParentName;

    /*
     * The number of policy terms and the nodes describing the authorization policy
     * for the object.
     * If numPolicyTerms is 0 or pObjectPolicy is NULL, the default policy of
     * policyAuthValue will be used.
     */
    ubyte4 numPolicyTerms;
    PolicyAuthNode *pObjectPolicy;
} UtilsCreateObjectIn;

typedef struct {
    FAPI2_OBJECT *pObject;
} UtilsCreateObjectOut;

typedef struct {
    /*
     * Object for which a handle must be created.
     */
    FAPI2_OBJECT *pObject;

    /*
     * Handle to the parent object. THis is required only for
     * non persistent objects. Can be NULL otherwise.
     */
    MOCTPM2_OBJECT_HANDLE *pParentHandle;

    /*
     * AuthValue of the parent object. THis is required only for
     * non persistent objects. Can be NULL otherwise.
     */
    TPM2B_AUTH *pAuthParentHandle;

    /*
     * List of policy nodes associated with the parent object.
     */
    ubyte2 numPolicyTerms;
    PolicyAuthNode *pParentPolicy;
} UtilsCreateHandleIn;

typedef struct {
    MOCTPM2_OBJECT_HANDLE *pHandle;
} UtilsCreateHandleOut;

typedef struct {
    /*
     * Pointer to object whose authValue must be changed. This cannot
     * be an NV or persistent object and the authValue must be valid
     * and set. If the object was serialized and deserialized, the
     * setObjectAuth API must have been called.
     */
    FAPI2_OBJECT *pObject;

    /*
     * new authValue for the object. THis cannot be NULL.
     */
    TPM2B_AUTH *pNewAuth;
} UtilsChangeObjectAuthIn;

typedef struct {
    /*
     * Object that needs to be loaded. The objects parents are automatically
     * picked up from the context. The objects parents must be loaded in the
     * context and their authValues must be set and valid.
     */
    FAPI2_OBJECT *pObject;
    /*
     * During normal loading, the objects parents are loaded and flushed and only
     * the object is finally left loaded. If this flag is set, the parent handle of
     * the object being loaded will be returned and the parent will be left
     * loaded on the TPM.
     */
    byteBoolean getParentHandle;
} UtilsLoadObjectTreeExIn;

typedef struct {
    /*
     * Handle to the object loaded.
     */
    MOCTPM2_OBJECT_HANDLE *pObjectHandle;
    /*
     * Handle to the objects parent, if getParentHandle was set. If not, NULL is returned.
     */
    MOCTPM2_OBJECT_HANDLE *pParentHandle;
    /*
     * Pointer to the parent object. Always returned if there was no error in the API.
     */
    FAPI2_OBJECT *pParentObject;
} UtilsLoadObjectTreeExOut;

/*
 * Use this function to create a handle from a FAPI2_OBJECT.
 * This uses FAPI2_UTILS_loadObjectTreeEx() underneath to load
 * arbitrary(as allowed by the TPM spec) hierarchies of objects.
 * FAPI2_UTILS_loadObjectTreeEx() has a few more options and this is
 * a simpler wrapper that should suffices for most uses.
 *
 * Note that calling this function on the EK and SRK should be used carefully
 * since handles are already created and cached in the context.
 *
 */
TSS2_RC FAPI2_UTILS_loadObjectTree(
        FAPI2_CONTEXT *pCtx,
        FAPI2_OBJECT *pObject,
        MOCTPM2_OBJECT_HANDLE **ppHandle
);

/*
 * Use this function to create a handle from a FAPI2_OBJECT.
 * This uses FAPI2_UTILS_createHandle() underneath to load
 * arbitrary(as allowed by the TPM spec) hierarchies of objects.
 * The main different between loadObjectTreeEx() and createHandle()
 * is that this function automatically figures out the object
 * hierarchy and loads the object into the TPM, whereas createHandle()
 * explicitly requires selection of parent. A flag can be set to leave
 * the parent loaded in the TPM.
 *
 * Note that calling this function on the EK and SRK should be used carefully
 * since handles are already created and cached in the context.
 */
TSS2_RC FAPI2_UTILS_loadObjectTreeEx(
        FAPI2_CONTEXT *pCtx,
        UtilsLoadObjectTreeExIn *pIn,
        UtilsLoadObjectTreeExOut *pOut
);

MOC_EXTERN TSS2_RC FAPI2_UTILS_createHandle(
        FAPI2_CONTEXT *pCtx,
        UtilsCreateHandleIn *pIn,
        UtilsCreateHandleOut *pOut
);

MOC_EXTERN TSS2_RC FAPI2_UTILS_destroyHandle(
        FAPI2_CONTEXT *pCtx,
        MOCTPM2_OBJECT_HANDLE **ppHandle
);

TSS2_RC FAPI2_UTILS_startPolicySession(
        FAPI2_CONTEXT *pCtx,
        MOCTPM2_OBJECT_HANDLE **ppSessionHandle,
        byteBoolean isTrial
);

TSS2_RC FAPI2_UTILS_startSession(
        FAPI2_CONTEXT *pCtx,
        MOCTPM2_OBJECT_HANDLE **ppSessionHandle
);

TSS2_RC FAPI2_UTILS_closeSession(
        FAPI2_CONTEXT *pCtx,
        MOCTPM2_OBJECT_HANDLE **ppSessionHandle
);

MOC_EXTERN TSS2_RC FAPI2_UTILS_createObject(
        FAPI2_CONTEXT *pCtx,
        UtilsCreateObjectIn *pIn,
        UtilsCreateObjectOut *pOut
);

MOC_EXTERN TSS2_RC FAPI2_UTILS_destroyObject(
        FAPI2_OBJECT **ppObject
);

MOC_EXTERN TSS2_RC FAPI2_UTILS_setObjectAuth(
        FAPI2_OBJECT *pObject,
        TPM2B_AUTH* pAuth
);

MOC_EXTERN TSS2_RC FAPI2_UTILS_serialize(
        FAPI2_OBJECT **ppObject,
        byteBoolean destroyObject,
        FAPI2B_OBJECT *pSerializedObject
);

MOC_EXTERN TSS2_RC FAPI2_UTILS_deserialize(
        FAPI2B_OBJECT *pSerializedObject,
        FAPI2_OBJECT **ppObject
);

TSS2_RC FAPI2_UTILS_serialize_Duplicate(
        FAPI2_DuplicateOut *pDuplicate,
        FAPI2B_DUPLICATE *pSerializedDup
);

TSS2_RC FAPI2_UTILS_deserialize_Duplicate(
        FAPI2B_DUPLICATE *pSerializedDup,
        FAPI2_DuplicateOut *pDuplicate
);

/*
 * This function can be used to change the authValue of a FAPI2_OBJECT.
 * This must be TPM created object and not external. This API cannot be
 * used to change the authValue of a persistent/primary object or NV index.
 * The authValue must be set and valid, so an application must call
 * FAPI2_UTILS_setObjectAuth if the object was serialized and deserialized.
 */
MOC_EXTERN TSS2_RC FAPI2_UTILS_changeObjectAuth(
        FAPI2_CONTEXT *pCtx,
        UtilsChangeObjectAuthIn *pIn
);

TSS2_RC FAPI2_UTILS_createPolicySessionAndExecutePolicy(
        FAPI2_CONTEXT *pCtx,
        ubyte2 numPolicyTerms,
        PolicyAuthNode *pPolicyToExecute,
        TPM2B_DIGEST *pPolicyDigestOut,
        MOCTPM2_OBJECT_HANDLE **ppSessionHandle
);

TSS2_RC FAPI2_UTILS_fillPolicyDigest(
        FAPI2_CONTEXT *pCtx,
        ubyte2 numPolicyTerms,
        PolicyAuthNode *pPolicy,
        TPM2B_DIGEST *pPolicyDigest
);

TSS2_RC FAPI2_UTILS_getObjectAuthSession(
        FAPI2_CONTEXT *pCtx,
        FAPI2_OBJECT *pObject,
        MOCTPM2_OBJECT_HANDLE **ppSessionHandle
);

#endif  /* (defined(__ENABLE_DIGICERT_TPM2__)) */
#endif /* __FAPI2_UTILS_INTERNAL_H__ */
