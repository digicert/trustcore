/*
 *  crypto_interface_pkcs5_test.c
 *
 *   unit test for pkcs5.c
 *
 * Copyright 2025 DigiCert Project Authors. All Rights Reserved.
 * 
 * DigiCert® TrustCore and TrustEdge are licensed under a dual-license model:
 * - **Open Source License**: GNU AGPL v3. See: https://github.com/digicert/trustcore-test/blob/main/LICENSE
 * - **Commercial License**: Available under DigiCert’s Master Services Agreement. See: https://github.com/digicert/trustcore-test/blob/main/LICENSE_COMMERCIAL.txt  
 *   or https://www.digicert.com/master-services-agreement/
 * 
 * *For commercial licensing, contact DigiCert at sales@digicert.com.*
 *
 */
#include "../../../unit_tests/unittest.h"

#include "../../common/initmocana.h"
#include "../../crypto/pubcrypto.h"
#include "../../crypto/pkcs5.h"
#include "../../crypto_interface/crypto_interface_pkcs5.h"
#include "../../crypto/pkcs_key.h"

static MocCtx gpMocCtx = NULL;

#ifdef __ENABLE_DIGICERT_HW_SIMULATOR_TEST__
static void *gpHwAccelCtx = NULL;
#endif

/* Test vectors from RFC 3962 */
typedef struct PKCS5_TestVector
{
    ubyte4 iterationCount;
    sbyte* pPassword;
    sbyte* pSalt;
    ubyte* pOutput;
} PKCS5_TestVector;

/* --------------------------------------------------------------- */

PKCS5_TestVector gTestVectors[] =
{
/* FIPS vectors requre iterations >= 1000 and saltLen >= 16 */
#ifndef __ENABLE_DIGICERT_FIPS_MODULE__
    {
        1,
        (sbyte*) "password",
        (sbyte*) "ATHENA.MIT.EDUraeburn",
        (ubyte*) "\xcd\xed\xb5\x28\x1b\xb2\xf8\x01\x56\x5a\x11\x22\xb2\x56\x35\x15"
                 "\x0a\xd1\xf7\xa0\x4b\xb9\xf3\xa3\x33\xec\xc0\xe2\xe1\xf7\x08\x37"
    },
    {
        2,
        (sbyte*) "password",
        (sbyte*) "ATHENA.MIT.EDUraeburn",
        (ubyte*) "\x01\xdb\xee\x7f\x4a\x9e\x24\x3e\x98\x8b\x62\xc7\x3c\xda\x93\x5d"
                 "\xa0\x53\x78\xb9\x32\x44\xec\x8f\x48\xa9\x9e\x61\xad\x79\x9d\x86"
    },
#endif
    {
        1200,
        (sbyte*) "password",
        (sbyte*) "ATHENA.MIT.EDUraeburn",
        (ubyte*) "\x5c\x08\xeb\x61\xfd\xf7\x1e\x4e\x4e\xc3\xcf\x6b\xa1\xf5\x51\x2b"
                 "\xa7\xe5\x2d\xdb\xc5\xe5\x14\x2f\x70\x8a\x31\xe2\xe6\x2b\x1e\x13"
    },
#ifndef __ENABLE_DIGICERT_FIPS_MODULE__  
    {
        5,
        (sbyte*) "password",
        (sbyte*) "\x12\x34\x56\x78\x78\x56\x34\x12",
        (ubyte*) "\xd1\xda\xa7\x86\x15\xf2\x87\xe6\xa1\xc8\xb1\x20\xd7\x06\x2a\x49"
                 "\x3f\x98\xd2\x03\xe6\xbe\x49\xa6\xad\xf4\xfa\x57\x4b\x6e\x64\xee"
    },
#endif
    {
        1200,
        (sbyte*) "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
        (sbyte*) "pass phrase equals block size",
        (ubyte*) "\x13\x9c\x30\xc0\x96\x6b\xc3\x2b\xa5\x5f\xdb\xf2\x12\x53\x0a\xc9"
                 "\xc5\xec\x59\xf1\xa4\x52\xf5\xcc\x9a\xd9\x40\xfe\xa0\x59\x8e\xd1"
     },
     {
        1200,
        (sbyte*) "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
        (sbyte*) "pass phrase exceeds block size",
        (ubyte*) "\x9c\xca\xd6\xd4\x68\x77\x0c\xd5\x1b\x10\xe6\xa6\x87\x21\xbe\x61"
                 "\x1a\x8b\x4d\x28\x26\x01\xdb\x3b\x36\xbe\x92\x46\x91\x5e\xc8\x2a"
     },
#ifndef __ENABLE_DIGICERT_FIPS_MODULE__ 
     {
        50,
        (sbyte*) "\xf0\x9d\x84\x9e",
        (sbyte*) "EXAMPLE.COMpianist",
        (ubyte*) "\x6b\x9c\xf2\x6d\x45\x45\x5a\x43\xa5\xb8\xbb\x27\x6a\x40\x3b\x39"
                 "\xe7\xfe\x37\xa0\xc4\x1e\x02\xc2\x81\xff\x30\x69\xe1\xe9\x4f\x52"
     }
#endif
};

/* --------------------------------------------------------------- */

static int pkcs5_test_pbkdf2(void)
{
  MSTATUS status;
  sbyte4 cmpRes;
  int i, errorCount = 0;
  ubyte output[32];

  for (i = 0; i < COUNTOF(gTestVectors); ++i)
  {
    ubyte4 pwLen, saltLen;

    pwLen = DIGI_STRLEN (gTestVectors[i].pPassword);
    saltLen = DIGI_STRLEN (gTestVectors[i].pSalt);

    status = PKCS5_CreateKey_PBKDF2 (
      MOC_HASH(gpHwAccelCtx) gTestVectors[i].pSalt, saltLen,
      gTestVectors[i].iterationCount, ht_sha1, gTestVectors[i].pPassword, pwLen,
      32, output);
    errorCount += UNITTEST_STATUS (__MOC_LINE__, status);

    DIGI_MEMCMP (gTestVectors[i].pOutput, output, 32, &cmpRes);
    errorCount += UNITTEST_INT(i, cmpRes, 0);
  }

  return errorCount;
}

/* --------------------------------------------------------------- */

static const ubyte pAsn1_tdes_sha1[66] = 
{
  0x30, 0x40, 0x30, 0x28, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x05, 0x0c, 0x30,
  0x1b, 0x04, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x02, 0x01, 0x78, 0x30, 0x0c,
  0x06, 0x08, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x02, 0x07, 0x05, 0x00, 0x30, 0x14, 0x06, 0x08,
  0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x03, 0x07, 0x04, 0x08, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03,
  0x02, 0x01
};

static const ubyte pAsn1_tdes_sha224[67] = 
{
  0x30, 0x41,
  0x30, 0x29, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x05, 0x0c, 0x30, 0x1c, 0x04,
  0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x02, 0x02, 0x04, 0x00, 0x30, 0x0c, 0x06, 0x08,
  0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x02, 0x08, 0x05, 0x00, 0x30, 0x14, 0x06, 0x08, 0x2a, 0x86,
  0x48, 0x86, 0xf7, 0x0d, 0x03, 0x07, 0x04, 0x08, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01
};

static const ubyte pAsn1_tdes_sha256[67] = 
{
  0x30, 0x41,
  0x30, 0x29, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x05, 0x0c, 0x30, 0x1c, 0x04,
  0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x02, 0x02, 0x08, 0x00, 0x30, 0x0c, 0x06, 0x08, 
  0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x02, 0x09, 0x05, 0x00, 0x30, 0x14, 0x06, 0x08, 0x2a, 0x86,
  0x48, 0x86, 0xf7, 0x0d, 0x03, 0x07, 0x04, 0x08, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01
};

static const ubyte pAsn1_tdes_sha384[67] = 
{
  0x30, 0x41,
  0x30, 0x29, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x05, 0x0c, 0x30, 0x1c, 0x04,
  0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x02, 0x02, 0x10, 0x00, 0x30, 0x0c, 0x06, 0x08,
  0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x02, 0x0a, 0x05, 0x00, 0x30, 0x14, 0x06, 0x08, 0x2a, 0x86,
  0x48, 0x86, 0xf7, 0x0d, 0x03, 0x07, 0x04, 0x08, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01
};

static const ubyte pAsn1_tdes_sha512[67] = 
{
  0x30, 0x41,
  0x30, 0x29, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x05, 0x0c, 0x30, 0x1c, 0x04,
  0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x02, 0x02, 0x01, 0x00, 0x30, 0x0c, 0x06, 0x08,
  0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x02, 0x0b, 0x05, 0x00, 0x30, 0x14, 0x06, 0x08, 0x2a, 0x86, 
  0x48, 0x86, 0xf7, 0x0d, 0x03, 0x07, 0x04, 0x08, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01
}; 

static const ubyte pAsn1_des_sha1[64] = 
{
  0x30, 0x3e,
  0x30, 0x29, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x05, 0x0c, 0x30, 0x1c, 0x04, 
  0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x02, 0x02, 0x7f, 0xff, 0x30, 0x0c, 0x06, 0x08, 
  0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x02, 0x07, 0x05, 0x00, 0x30, 0x11, 0x06, 0x05, 0x2b, 0x0e, 
  0x03, 0x02, 0x07, 0x04, 0x08, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01
};

static const ubyte pAsn1_des_sha224[63] = 
{
  0x30, 0x3d,
  0x30, 0x28, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x05, 0x0c, 0x30, 0x1b, 0x04, 
  0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x02, 0x01, 0x78, 0x30, 0x0c, 0x06, 0x08,
  0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x02, 0x08, 0x05, 0x00, 0x30, 0x11, 0x06, 0x05, 0x2b, 0x0e, 
  0x03, 0x02, 0x07, 0x04, 0x08, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01
};

static const ubyte pAsn1_des_sha256[63] = 
{
  0x30, 0x3d,
  0x30, 0x28, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x05, 0x0c, 0x30, 0x1b, 0x04, 
  0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x02, 0x01, 0x78, 0x30, 0x0c, 0x06, 0x08, 
  0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x02, 0x09, 0x05, 0x00, 0x30, 0x11, 0x06, 0x05, 0x2b, 0x0e, 
  0x03, 0x02, 0x07, 0x04, 0x08, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01
};

static const ubyte pAsn1_des_sha384[64] = 
{
  0x30, 0x3e,
  0x30, 0x29, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x05, 0x0c, 0x30, 0x1c, 0x04,
  0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x02, 0x02, 0x00, 0x80, 0x30, 0x0c, 0x06, 0x08, 
  0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x02, 0x0a, 0x05, 0x00, 0x30, 0x11, 0x06, 0x05, 0x2b, 0x0e, 
  0x03, 0x02, 0x07, 0x04, 0x08, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01
};

static const ubyte pAsn1_des_sha512[64] = 
{
  0x30, 0x3e,
  0x30, 0x29, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x05, 0x0c, 0x30, 0x1c, 0x04, 
  0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x02, 0x02, 0x00, 0xff, 0x30, 0x0c, 0x06, 0x08, 
  0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x02, 0x0b, 0x05, 0x00, 0x30, 0x11, 0x06, 0x05, 0x2b, 0x0e, 
  0x03, 0x02, 0x07, 0x04, 0x08, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01
};

static const ubyte pAsn1_aes128_sha256[76] = 
{
  0x30, 0x4a,
  0x30, 0x29, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x05, 0x0c, 0x30, 0x1c, 0x04,
  0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x02, 0x02, 0x08, 0x00, 0x30, 0x0c, 0x06, 0x08, 
  0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x02, 0x09, 0x05, 0x00, 0x30, 0x1d, 0x06, 0x09, 0x60, 0x86, 0x48,
  0x01, 0x65, 0x03, 0x04, 0x01, 0x02, 0x04, 0x10, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01,
  0xf1, 0xe1, 0xc1, 0xd1, 0xc1, 0xb1, 0xa1, 0x01
};

static const ubyte pAsn1_aes192_sha256[76] = 
{
  0x30, 0x4a,
  0x30, 0x29, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x05, 0x0c, 0x30, 0x1c, 0x04,
  0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x02, 0x02, 0x08, 0x00, 0x30, 0x0c, 0x06, 0x08, 
  0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x02, 0x09, 0x05, 0x00, 0x30, 0x1d, 0x06, 0x09, 0x60, 0x86, 0x48,
  0x01, 0x65, 0x03, 0x04, 0x01, 0x16, 0x04, 0x10, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01,
  0xf1, 0xe1, 0xc1, 0xd1, 0xc1, 0xb1, 0xa1, 0x01
};

static const ubyte pAsn1_aes256_sha256[76] = 
{
  0x30, 0x4a,
  0x30, 0x29, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x05, 0x0c, 0x30, 0x1c, 0x04,
  0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x02, 0x02, 0x08, 0x00, 0x30, 0x0c, 0x06, 0x08, 
  0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x02, 0x09, 0x05, 0x00, 0x30, 0x1d, 0x06, 0x09, 0x60, 0x86, 0x48,
  0x01, 0x65, 0x03, 0x04, 0x01, 0x2a, 0x04, 0x10, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01,
  0xf1, 0xe1, 0xc1, 0xd1, 0xc1, 0xb1, 0xa1, 0x01
};

static int pkcs5_test_encdec(ubyte hint, ubyte encAlg, ubyte digestAlg, ubyte4 iterCount, ubyte4 keyLen, ubyte4 plainLen, const ubyte *pAsn1, ubyte4 asn1Len)
{
  MSTATUS status = OK;
  int retVal = 0;
  sbyte4 compare = -1;

  ubyte pSalt[8] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
  ubyte4 saltLen = 8;

  ubyte pPassword[16] = {0xfe, 0xed, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xca, 0xf0, 0xc0, 0xff, 0xee, 0x11, 0x22, 0x33, 0x44};
  ubyte4 passwordLen = 16;

  ubyte pIV[16] = {0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0xf1, 0xe1, 0xc1, 0xd1, 0xc1, 0xb1, 0xa1, 0x01}; /* big enough for all tests */
  
  ubyte pPlainText[32] =  /* big enough for all tests */
  {
    0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x00, 0x99,
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 
    0xa0, 0x02, 0x97, 0x80, 0x30, 0xa7, 0x88, 0xdb,
    0xfa, 0xba, 0x55, 0x34, 0x25, 0x16, 0x97, 0x88 
  };

  ubyte pCipher[48] = {0};
  ubyte4 cipherLen = 0;

  ubyte4 expCipherLen = plainLen + (aesEncryption == encAlg ? 16 : 8);

  ubyte pRecPlain[32] = {0};
  ubyte4 recPlainLen = 0;

  /* call with NULL buffer to get the length */
  status = CRYPTO_INTERFACE_PKCS5_encryptV2_Alt(MOC_SYM(gpHwAccelCtx) encAlg, digestAlg, keyLen, 1, pPassword, passwordLen,
                                                pSalt, saltLen, iterCount, pIV, pPlainText, plainLen, NULL, 0, &cipherLen);
  retVal += UNITTEST_INT (hint, status, ERR_BUFFER_TOO_SMALL);
  if (OK != status)
    goto exit;

  retVal += UNITTEST_INT(hint, cipherLen, expCipherLen);

  status = CRYPTO_INTERFACE_PKCS5_encryptV2_Alt(MOC_SYM(gpHwAccelCtx) encAlg, digestAlg, keyLen, 1, pPassword, passwordLen,
                                                pSalt, saltLen, iterCount, pIV, pPlainText, plainLen, pCipher, 48, &cipherLen);
  retVal += UNITTEST_STATUS (hint, status);
  if (OK != status)
    goto exit;

  retVal += UNITTEST_INT(hint, cipherLen, expCipherLen);

  /* call with NULL buffer to get the length */
  status = CRYPTO_INTERFACE_PKCS5_decryptV2(MOC_SYM(gpHwAccelCtx) pAsn1, asn1Len, pCipher, cipherLen, pPassword, passwordLen, NULL, 0, &recPlainLen);
  retVal += UNITTEST_INT (hint, status, ERR_BUFFER_TOO_SMALL);
  if (OK != status)
    goto exit;

  retVal += UNITTEST_INT(hint, recPlainLen, plainLen);

  status = CRYPTO_INTERFACE_PKCS5_decryptV2(MOC_SYM(gpHwAccelCtx) pAsn1, asn1Len, pCipher, cipherLen, pPassword, passwordLen, pRecPlain, 32, &recPlainLen);
  retVal += UNITTEST_STATUS (hint, status);
  if (OK != status)
    goto exit;

  retVal += UNITTEST_INT(hint, recPlainLen, plainLen);

  status = DIGI_MEMCMP(pRecPlain, pPlainText, plainLen, &compare);
  retVal += UNITTEST_STATUS (hint, status);
  if (OK != status)
    goto exit;

  retVal += UNITTEST_INT (hint, compare, 0);

exit:

  return retVal;
}

/* --------------------------------------------------------------- */

int crypto_interface_pkcs5_test_init()
{
  MSTATUS status = ERR_NULL_POINTER;
  int errorCount = 0;

  InitMocanaSetupInfo setupInfo = { 0 };
  /**********************************************************
   *************** DO NOT USE MOC_NO_AUTOSEED ***************
   ***************** in any production code. ****************
   **********************************************************/
  setupInfo.flags = MOC_NO_AUTOSEED;

  status = DIGICERT_initialize(&setupInfo, &gpMocCtx);
  if (OK != status)
  {
    errorCount = 1;
    goto exit;
  }

#ifdef __ENABLE_DIGICERT_HW_SIMULATOR_TEST__
  status = (MSTATUS) HARDWARE_ACCEL_INIT();
  if (OK != status)
  {
      errorCount = 1;
      goto exit;
  }

  status = (MSTATUS) HARDWARE_ACCEL_OPEN_CHANNEL(MOCANA_MSS, &gpHwAccelCtx);
  if (OK != status)
  {
      errorCount = 1;
      goto exit;
  }
#endif

  errorCount += pkcs5_test_pbkdf2();

#ifndef __DISABLE_3DES_CIPHERS__
  errorCount += pkcs5_test_encdec(0, tdesEncryption, sha1Encryption, 0x78, 24, 8, pAsn1_tdes_sha1, sizeof(pAsn1_tdes_sha1));
  errorCount += pkcs5_test_encdec(1, tdesEncryption, sha224Encryption, 1024, 24, 16, pAsn1_tdes_sha224, sizeof(pAsn1_tdes_sha224));
  errorCount += pkcs5_test_encdec(2, tdesEncryption, sha256Encryption, 2048, 24, 24, pAsn1_tdes_sha256, sizeof(pAsn1_tdes_sha256));
  errorCount += pkcs5_test_encdec(3, tdesEncryption, sha384Encryption, 4096, 24, 8, pAsn1_tdes_sha384, sizeof(pAsn1_tdes_sha384));
  errorCount += pkcs5_test_encdec(4, tdesEncryption, sha512Encryption, 256, 24, 16, pAsn1_tdes_sha512, sizeof(pAsn1_tdes_sha512));
#endif

#ifdef __ENABLE_DES_CIPHER__
  errorCount += pkcs5_test_encdec(5, desEncryption, sha1Encryption, 0x7fff, 8, 24, pAsn1_des_sha1, sizeof(pAsn1_des_sha1));
  errorCount += pkcs5_test_encdec(6, desEncryption, sha224Encryption, 0x78, 8, 8, pAsn1_des_sha224, sizeof(pAsn1_des_sha224));
  errorCount += pkcs5_test_encdec(7, desEncryption, sha256Encryption, 0x78, 8, 16, pAsn1_des_sha256, sizeof(pAsn1_des_sha256));
  errorCount += pkcs5_test_encdec(8, desEncryption, sha384Encryption, 128, 8, 24, pAsn1_des_sha384, sizeof(pAsn1_des_sha384));
  errorCount += pkcs5_test_encdec(9, desEncryption, sha512Encryption, 255, 8, 8, pAsn1_des_sha512, sizeof(pAsn1_des_sha512));
#endif

#if !defined(__ENABLE_DIGICERT_MBED_SYM_OPERATORS__) && !defined(__DISABLE_AES_CIPHERS__)
  errorCount += pkcs5_test_encdec(10, aesEncryption, sha256Encryption, 2048, 16, 16, pAsn1_aes128_sha256, sizeof(pAsn1_aes128_sha256));
  errorCount += pkcs5_test_encdec(11, aesEncryption, sha256Encryption, 2048, 24, 32, pAsn1_aes192_sha256, sizeof(pAsn1_aes192_sha256));
  errorCount += pkcs5_test_encdec(12, aesEncryption, sha256Encryption, 2048, 32, 16, pAsn1_aes256_sha256, sizeof(pAsn1_aes256_sha256));
#endif

exit:

#ifdef __ENABLE_DIGICERT_HW_SIMULATOR_TEST__
  HARDWARE_ACCEL_CLOSE_CHANNEL(MOCANA_MSS, &gpHwAccelCtx);
  HARDWARE_ACCEL_UNINIT();
#endif

  DIGICERT_free(&gpMocCtx);
  return errorCount;
}
