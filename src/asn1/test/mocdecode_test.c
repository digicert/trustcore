/*
 *  mocdecode_test.c
 *
 *  unit test for mocdecode.c
 *
 * Copyright 2025 DigiCert Project Authors. All Rights Reserved.
 * 
 * DigiCert® TrustCore and TrustEdge are licensed under a dual-license model:
 * - **Open Source License**: GNU AGPL v3. See: https://github.com/digicert/trustcore-test/blob/main/LICENSE
 * - **Commercial License**: Available under DigiCert’s Master Services Agreement. See: https://github.com/digicert/trustcore-test/blob/main/LICENSE_COMMERCIAL.txt  
 *   or https://www.digicert.com/master-services-agreement/
 * 
 * *For commercial licensing, contact DigiCert at sales@digicert.com.*
 *
 */

#include "../../common/moptions.h"
#include "../../common/mtypes.h"
#include "../../common/mocana.h"
#include "../../crypto/hw_accel.h"
#include "../../common/mdefs.h"
#include "../../common/merrors.h"
#include "../../common/mstdlib.h"
#include "../../common/mrtos.h"
#include "../../../unit_tests/unittest.h"

#include <stdio.h>

/* Source code under test */
#include "../../asn1/mocdecode.c"

#include "../../asn1/mocasn1.h"

/********************************************/

typedef struct
{
    void*         pNext;
    MAsn1Element* pElement;
    ubyte*        pData;
    ubyte4        size;
    ubyte4        len;
} TestDataReturnInfo;

static MSTATUS
FreeTestDataReturn (
        TestDataReturnInfo *pDataInfo);

static MSTATUS
TestSeqDataReturn (
        void *pCallbackInfo,
        ubyte *pData,
        ubyte4 dataLen,
        MAsn1Element *pElement);

static int
read_indefExplicit_chunked(ubyte4 chunkSize);

static int
read_indefSetOfExplicit_chunked(ubyte4 chunkSize);

static int
read_ca_chunked(ubyte4 chunkSize,
                ubyte** ppKeepData,
                ubyte4* pKeepDataLen);

/********************************************/

/* OID: 0.9.2342.19200300.100.1.25 */
static ubyte OID_PLUTO[] =
{ 0x06, 0x0A, 0x09, 0x92, 0x26, 0x89, 0x93, 0xF2, 0x2C, 0x64, 0x01, 0x19 };
static ubyte4 OID_PLUTO_LEN = 12;

static ubyte DESCBC_OID_TEST[] =
{ 0x06, 0x05, 0x2B, 0x0E, 0x03, 0x02, 0x07 };
static ubyte4 DESCBC_OID_TEST_LEN = 7;

/* OID: 1.3.6.1.5.5.7.48.2 */
static ubyte CA_ISSUER[] =
{ 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x02 };
static ubyte4 CA_ISSUER_LEN = 10;

/* OID: 1.2.840.113549.1.1.5 */
static ubyte SHA1_WITH_RSA_ENCR[] =
{ 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05 };
static ubyte4 SHA1_WITH_RSA_ENCR_LEN = 11;

/* OID 1.2.840.113549.1.7.3 */
static ubyte CMS_ENVELOPE_DATA[] =
{ 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x03 };
static ubyte4 CMS_ENVELOPE_DATA_LEN = 11;

/********************************************/

int mocdecode_test_MAsn1Element_simpleInteger()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    ubyte4 bytesRead;
    unsigned int val;

    /* input data, with 2 'extra' bytes*/
    ubyte encoded[] =
    { 0x30, 0x04,
            0x02, 0x02, 18, 103,
            42, 42
    };

    /* Test sequence with a single integer entry */
    MAsn1TypeAndCount def[2] =
    {
            { MASN1_TYPE_SEQUENCE, 1 },
            { MASN1_TYPE_INTEGER, 0 }
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 2, MASN1_FNCT_DECODE, NULL, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array */
    status = MAsn1Decode (encoded, sizeof(encoded), pRoot, &bytesRead);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Check number of bytes read */
    retval += UNITTEST_INT(99, bytesRead, 6);
    if (retval > 0)
        goto exit;

    /* Check obtained value */
    retval += UNITTEST_INT(100, pRoot[1].valueLen, 2);
    if (retval > 0)
        goto exit;

    /* Make number */
    val = pRoot[1].value.pValue[0];
    val <<= 8;
    val += pRoot[1].value.pValue[1];

    /* Compare expected */
    retval += UNITTEST_INT(101, val, 4711);

exit:
    /* Cleanup memory */
    MAsn1FreeElementArray (&pRoot);
    return retval;
}


/*----------------------------------------------------------------------*/

static MSTATUS
TestSeqDataReturn(void *pCallbackInfo,
                  ubyte *pData,
                  ubyte4 dataLen,
                  MAsn1Element *pElement)
{
    MSTATUS status;
    ubyte4 totalSize;
    ubyte *pBuf = NULL;
    TestDataReturnInfo *pInfo = (TestDataReturnInfo *)pCallbackInfo;
    TestDataReturnInfo *pPrevious;
    TestDataReturnInfo *pNew = NULL;

    status = ERR_NULL_POINTER;
    if (NULL == pCallbackInfo)
        goto exit;

    /* Is there any data?
     */
    status = OK;
    if ( (NULL == pData) || (0 == dataLen) )
        goto exit;

    /* Search the link list until finding the entry with the same pElement or NULL.
     */
    pPrevious = NULL;
    do
    {
        if (NULL == pInfo->pElement)
            break;

        if (pElement == pInfo->pElement)
            break;

        pPrevious = pInfo;
        pInfo = (TestDataReturnInfo *)(pInfo->pNext);
        if (NULL == pInfo)
            break;
    } while (1);

    if (NULL == pInfo)
    {
      status = DIGI_CALLOC ((void **)&pNew, sizeof (TestDataReturnInfo), 1);
      if (OK != status)
        goto exit;

      pInfo = pNew;
      if (NULL != pPrevious)
        pPrevious->pNext = (void *)pNew;
    }

    pInfo->pElement = pElement;

    /* How much space do we need? If we don't have enough, realloc.
     */
    totalSize = pInfo->len + dataLen;
    if (pInfo->size < totalSize)
    {
        status = DIGI_MALLOC ((void **)&pBuf, totalSize);
        if (OK != status)
            goto exit;

        /* If there's any old data, copy it into the new buffer.
         */
        if (0 != pInfo->len)
        {
            status = DIGI_MEMCPY (
                    (void *)pBuf, (void *)(pInfo->pData), pInfo->len);
            if (OK != status)
                goto exit;
        }
    }

    status = DIGI_MEMCPY (
            (void *)(pBuf + pInfo->len), (void *)pData, dataLen);
    if (OK != status)
        goto exit;

    /* Get rid of the old, replace it with the new.
     */
    if (NULL != pInfo->pData)
    {
        status = DIGI_FREE ((void **)&(pInfo->pData));
        if (OK != status)
            goto exit;
    }

    pInfo->pData = pBuf;
    pInfo->size = totalSize;
    pInfo->len = totalSize;

#if 0
    if (MASN1_STATE_DECODE_INDEF_ENCODED_SUB_DATA == pElement[0].state)
    {
        pElement[0].value.pValue = pBuf;
        pElement[0].valueLen = totalSize; /* Do not count EOC? */
        printf("DATA: %d\n", pElement[0].valueLen);
    }
#endif

    pBuf = NULL;

exit:
    if (NULL != pBuf)
    {
        DIGI_FREE ((void **)&pBuf);
    }
    if (NULL != pNew)
    {
        DIGI_FREE ((void **)&pNew);
    }
    return status;
}


/*----------------------------------------------------------------------*/

static MSTATUS
FreeTestDataReturn(TestDataReturnInfo *pDataInfo)
{
    TestDataReturnInfo *pCurrent, *pNext;

    pNext = (TestDataReturnInfo *)(pDataInfo->pNext);
    if (NULL != pDataInfo->pData)
    {
        DIGI_FREE ((void **)&(pDataInfo->pData));
    }

    while (NULL != pNext)
    {
        pCurrent = pNext;
        pNext = (TestDataReturnInfo *)(pNext->pNext);
        if (NULL != pCurrent->pData)
        {
            DIGI_FREE ((void **)&(pCurrent->pData));
        }
        DIGI_FREE ((void **)&pCurrent);
    }

    return OK;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_MAsn1Element_indefiniteInteger()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    ubyte4 bytesRead;
    intBoolean done;
    unsigned int val;

    ubyte encoded[] =
    { 0x30, 0x80, 0x02, 0x02, 18, 103, 0x00, 0x00 };

    /* Test sequence with a single integer entry */
    MAsn1TypeAndCount def[2] =
    {
            { MASN1_TYPE_SEQUENCE, 1 },
            { MASN1_TYPE_INTEGER, 0 }
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 2, MASN1_FNCT_DECODE,
                                      MAsn1OfIndefFunction, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array */
    status = MAsn1DecodeIndefiniteUpdateFlag (encoded, sizeof(encoded), MASN1_DECODE_UPDATE, pRoot,
                                              TestSeqDataReturn,
                                              NULL, /* This fct is not called in this test case */
                                              &bytesRead, &done);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Check number of bytes read */
    retval += UNITTEST_INT(99, bytesRead, 8);
    if (retval > 0)
        goto exit;

    /* Check obtained value */
    retval += UNITTEST_INT(100, pRoot[1].valueLen, 2);
    if (retval > 0)
        goto exit;

    /* Make number */
    val = pRoot[1].value.pValue[0];
    val <<= 8;
    val += pRoot[1].value.pValue[1];

    /* Compare expected */
    retval += UNITTEST_INT(101, val, 4711);

exit:
    /* Cleanup memory */
    MAsn1FreeElementArray (&pRoot);
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_MAsn1Element_indefiniteDefiniteInput()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    ubyte4 bytesRead;
    intBoolean done;
    unsigned int val;

    ubyte encoded[] =
    { 0x30, 0x04, 0x02, 0x02, 18, 103 };

    /* Test sequence with a single integer entry */
    MAsn1TypeAndCount def[2] =
    {
            { MASN1_TYPE_SEQUENCE, 1 },
            { MASN1_TYPE_INTEGER, 0 }
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 2, MASN1_FNCT_DECODE,
                                      MAsn1OfIndefFunction, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array */
    status = MAsn1DecodeIndefiniteUpdateFlag (encoded, sizeof(encoded), MASN1_DECODE_UPDATE, pRoot,
                                              TestSeqDataReturn,
                                              NULL, /* This fct is not called in this test case */
                                              &bytesRead, &done);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Check number of bytes read */
    retval += UNITTEST_INT(99, bytesRead, 6);
    if (retval > 0)
        goto exit;

    /* Check obtained value */
    retval += UNITTEST_INT(100, pRoot[1].valueLen, 2);
    if (retval > 0)
        goto exit;

    /* Make number */
    val = pRoot[1].value.pValue[0];
    val <<= 8;
    val += pRoot[1].value.pValue[1];

    /* Compare expected */
    retval += UNITTEST_INT(101, val, 4711);

exit:
    /* Cleanup memory */
    MAsn1FreeElementArray (&pRoot);
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_MAsn1Element_simpleOID()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    ubyte4 bytesRead;
    sbyte4 cmpResult;

    /* input data */
    ubyte encoded[] =
    { 0x30, 0x0C,
            0x06, 0x0A, 0x09, 0x92, 0x26, 0x89, 0x93, 0xF2, 0x2C, 0x64, 0x01,
            0x19 };

    /* Test sequence with a single OID */
    MAsn1TypeAndCount def[2] =
    {
            { MASN1_TYPE_SEQUENCE, 1 },
            { MASN1_TYPE_OID, 0 }
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 2, MASN1_FNCT_DECODE, NULL, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array */
    status = MAsn1Decode (encoded, sizeof(encoded), pRoot, &bytesRead);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Check number of bytes read */
    retval += UNITTEST_INT(99, bytesRead, 14);
    if (retval > 0)
        goto exit;

    /* Found the correct OID? */
    status = ASN1_compareOID (OID_PLUTO, OID_PLUTO_LEN,
                              pRoot[1].encoding.pEncoding,
                              pRoot[1].encodingLen, NULL, &cmpResult);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(15, cmpResult, 0);

exit:
    /* Cleanup memory */
    MAsn1FreeElementArray (&pRoot);
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_MAsn1Element_indefiniteOIDString()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    ubyte4 bytesRead;
    intBoolean done;
    sbyte4 cmpResult;
    TestDataReturnInfo returnInfo =
    { NULL, NULL, NULL, 0, 0 };

    ubyte encoded[] =
    {       /* SEQUENCE INDEF */
            0x30, 0x80,
            /* OBJECT IDENTIFIER 1.2.840.113549.1.7.1 */
            0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x01,
            /* SEQUENCE 17 */
            0x30, 0x11,
            /* OBJECT IDENTIFIER 1.3.14.3.2.7 */
            0x06, 0x05, 0x2B, 0x0E, 0x03, 0x02, 0x07,
            /* OCTET STRING(8 byte) 0A1A64BA6257C635 */
            0x04, 0x08, 0x0A, 0x1A, 0x64, 0xBA, 0x62, 0x57, 0xC6, 0x35,
            /* [0] INDEF */
            0xA0, 0x80,
            /* OCTET STRING(8 byte) 0102030405060708 */
            0x04, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            /* EOC */
            0x00, 0x00,
            /* EOC */
            0x00, 0x00
    };

    /* Test sequence with a single integer entry */
    MAsn1TypeAndCount def[7] =
    {
            { MASN1_TYPE_SEQUENCE, 3 },
            { MASN1_TYPE_OID, 0 },
            { MASN1_TYPE_SEQUENCE, 2 },
            { MASN1_TYPE_OID, 0 },
            { MASN1_TYPE_OCTET_STRING, 0 },
            { MASN1_TYPE_SEQUENCE | MASN1_IMPLICIT, 1 },
            { MASN1_TYPE_OCTET_STRING, 0 },
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 7, MASN1_FNCT_DECODE,
                                      MAsn1OfIndefFunction, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array */
    status = MAsn1DecodeIndefiniteUpdateFlag (encoded, sizeof(encoded), MASN1_DECODE_UPDATE, pRoot,
                                              TestSeqDataReturn,
                                              (void *) &returnInfo,
                                              &bytesRead, &done);
    retval += UNITTEST_STATUS(1, status);
    if (retval > 0)
        goto exit;

    /* Check number of bytes read */
    retval += UNITTEST_INT(99, bytesRead, 48);
    if (retval > 0)
        goto exit;

    /* Found the correct OID? */
    status = ASN1_compareOID (DESCBC_OID_TEST, DESCBC_OID_TEST_LEN,
                              pRoot[3].encoding.pEncoding,
                              pRoot[3].encodingLen, NULL, &cmpResult);
    retval += UNITTEST_STATUS(2, status);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(15, cmpResult, 0);
    if (retval > 0)
        goto exit;

    /* Found the correct OCTET string? */
    retval += UNITTEST_INT(110, pRoot[6].valueLen, 8);
    if (retval > 0)
        goto exit;

    int idx;
    for (idx = 0; idx < pRoot[6].valueLen; ++idx)
    {
        retval += UNITTEST_INT(120 + idx, pRoot[6].value.pValue[idx],
                               (idx + 1));
    }

exit:
    /* Cleanup memory */
    MAsn1FreeElementArray (&pRoot);
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_MAsn1Element_simpleIA5()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    ubyte4 bytesRead;
    sbyte4 cmpResult;

    /* input data */
    ubyte encoded[] =
    { 0x30, 0x14,
            0x16, 0x06, 0x71, 0x61, 0x67, 0x6F, 0x6F, 0x64 };

    /* Test sequence with a single IA5 string */
    MAsn1TypeAndCount def[3] =
    {
            { MASN1_TYPE_SEQUENCE, 1 },
            { MASN1_TYPE_IA5_STRING, 0 }
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 2, MASN1_FNCT_DECODE, NULL, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array */
    status = MAsn1Decode (encoded, sizeof(encoded), pRoot, &bytesRead);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Check number of bytes read */
    retval += UNITTEST_INT(99, bytesRead, 10);
    if (retval > 0)
        goto exit;

    /* Check obtained value */
    retval += UNITTEST_INT(100, pRoot[1].valueLen, 6);
    if (retval > 0)
        goto exit;
    retval += UNITTEST_VALIDPTR(101, pRoot[1].value.pValue);
    if (retval > 0)
        goto exit;

    status = DIGI_MEMCMP (pRoot[1].value.pValue, (const ubyte *) "qagood", 6,
                         &cmpResult);
    retval += UNITTEST_STATUS(110, status);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(111, cmpResult, 0);

exit:
    /* Cleanup memory */
    MAsn1FreeElementArray (&pRoot);
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_MAsn1Element_Sequence()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    ubyte4 bytesRead;

    /* input data */
    ubyte encoded[] =
    { 0x30, 0x0D,
            0x02, 0x01, 0x00,
            0x30, 0x03,
            0x02, 0x01, 0x01,
            0x30, 0x03,
            0x02, 0x01, 0x02
    };

    /* Test sequence with multiple sub-sequences */
    MAsn1TypeAndCount def[6] =
    {
            { MASN1_TYPE_SEQUENCE, 3 },
            { MASN1_TYPE_INTEGER, 0 },
            { MASN1_TYPE_SEQUENCE, 1 },
            { MASN1_TYPE_INTEGER, 0 },
            { MASN1_TYPE_SEQUENCE, 1 },
            { MASN1_TYPE_INTEGER, 0 }
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 6, MASN1_FNCT_DECODE, NULL, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array */
    status = MAsn1Decode (encoded, sizeof(encoded), pRoot, &bytesRead);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Check number of bytes read */
    retval += UNITTEST_INT(99, bytesRead, 15);
    if (retval > 0)
        goto exit;

    /* Check obtained values */
    retval += UNITTEST_INT(100, pRoot[1].valueLen, 1);
    if (retval > 0)
        goto exit;
    retval += UNITTEST_INT(101, pRoot[1].value.pValue[0], 0);

    retval += UNITTEST_INT(110, pRoot[3].valueLen, 1);
    if (retval > 0)
        goto exit;
    retval += UNITTEST_INT(111, pRoot[3].value.pValue[0], 1);

    retval += UNITTEST_INT(120, pRoot[5].valueLen, 1);
    if (retval > 0)
        goto exit;
    retval += UNITTEST_INT(121, pRoot[5].value.pValue[0], 2);

exit:
    /* Cleanup memory */
    MAsn1FreeElementArray (&pRoot);
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_MAsn1Element_Set()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    ubyte4 bytesRead;

    /* input data with two extra bytes */
    ubyte encoded[] =
    { 0x31, 0x06, 0x02, 0x01, 0x01, 0x01, 0x01, 0xFF, 0x00, 0x22 };

    /* Test set with two entries */
    MAsn1TypeAndCount def[3] =
    {
            { MASN1_TYPE_SET, 2 },
            { MASN1_TYPE_INTEGER, 0 },
            { MASN1_TYPE_BOOLEAN, 0 }
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 3, MASN1_FNCT_DECODE, NULL, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array */
    status = MAsn1Decode (encoded, sizeof(encoded), pRoot, &bytesRead);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Check number of bytes read */
    retval += UNITTEST_INT(99, bytesRead, 8);
    if (retval > 0)
        goto exit;

    /* Check obtained values */
    retval += UNITTEST_INT(100, pRoot[1].valueLen, 1);
    if (retval > 0)
        goto exit;
    retval += UNITTEST_INT(101, pRoot[1].value.pValue[0], 1);

    retval += UNITTEST_INT(110, pRoot[2].valueLen, 1);
    if (retval > 0)
        goto exit;
    retval += UNITTEST_TRUE(111, pRoot[2].value.pValue[0]);

exit:
    /* Cleanup memory */
    MAsn1FreeElementArray (&pRoot);
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_MAsn1Element_SetOf()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    ubyte4 bytesRead;
    ubyte4 counter = 0;
    MAsn1Element* pElement = NULL;
    ubyte4 idx;
    MAsn1Element* setN[3];

    /* input data with three elements */
    ubyte encoded[] =
    { 0x31, 0x19,
            0x30, 0x06, 0x02, 0x01, 0x01, 0x01, 0x01, 0xFF,
            0x30, 0x07, 0x02, 0x02, 18, 103, 0x01, 0x01, 0x00,
            0x30, 0x06, 0x02, 0x01, 0x00, 0x01, 0x01, 0xFF
    };

    /* Test set_of with many entries */
    MAsn1TypeAndCount def[4] =
    {
            { MASN1_TYPE_SET_OF, 1 },
            { MASN1_TYPE_SEQUENCE, 2 },
            { MASN1_TYPE_INTEGER, 0 },
            { MASN1_TYPE_BOOLEAN, 0 }
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 4, MASN1_FNCT_DECODE,
                                      &MAsn1OfFunction, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array */
    status = MAsn1Decode (encoded, sizeof(encoded), pRoot, &bytesRead);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Start loop over elements */
    status = MAsn1GetOfElementAtIndex (pRoot, counter, &pElement);
    retval += UNITTEST_STATUS(100, status);
    if (retval > 0)
        goto exit;

    /* Found another? */
    while (NULL != pElement)
    {
        ++counter;
        status = MAsn1GetOfElementAtIndex (pRoot, counter, &pElement);
        retval += UNITTEST_STATUS(100 + counter, status);
        if (retval > 0)
            goto exit;
    }
    retval += UNITTEST_INT(110, counter, 3);
    if (retval > 0)
        goto exit;

    /* Check that each element is different */
    for (idx = 0; idx < counter; ++idx)
    {
        MAsn1GetOfElementAtIndex (pRoot, idx, &(setN[idx]));
    }

    for (idx = 0; idx < counter; ++idx)
    {
        switch (idx)
        {
        case 0:
            retval += UNITTEST_INT(200, setN[idx][1].value.pValue[0], 0x1);
            retval += UNITTEST_INT(210, setN[idx][2].value.pValue[0], 0xFF);
            break;

        case 1:
            {
            unsigned int val;
            val = setN[idx][1].value.pValue[0];
            val <<= 8;
            val += setN[idx][1].value.pValue[1];
            retval += UNITTEST_INT(201, val, 4711);
            retval += UNITTEST_INT(211, setN[idx][2].value.pValue[0], 0x00);
        }
            break;

        case 2:
            retval += UNITTEST_INT(202, setN[idx][1].value.pValue[0], 0x0);
            retval += UNITTEST_INT(212, setN[idx][2].value.pValue[0], 0xFF);
            break;
        }
    }
exit:
    /* Cleanup memory */
    MAsn1FreeElementArray (&pRoot);
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_MAsn1Element_IndefiniteSetOf()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    ubyte4 bytesRead;
    intBoolean done;
    ubyte4 counter = 0;
    MAsn1Element* pElement = NULL;
    ubyte4 idx;
    MAsn1Element* setN[3];

    /* input data with three elements */
    ubyte encoded[] =
    { 0x31, 0x80,
            0x30, 0x06, 0x02, 0x01, 0x01, 0x01, 0x01, 0xFF,
            0x30, 0x07, 0x02, 0x02, 18, 103, 0x01, 0x01, 0x00,
            0x30, 0x06, 0x02, 0x01, 0x00, 0x01, 0x01, 0xFF,
            0x00, 0x00
    };

    /* Test set_of with many entries */
    MAsn1TypeAndCount def[4] =
    {
            { MASN1_TYPE_SET_OF, 1 },
            { MASN1_TYPE_SEQUENCE, 2 },
            { MASN1_TYPE_INTEGER, 0 },
            { MASN1_TYPE_BOOLEAN, 0 }
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 4, MASN1_FNCT_DECODE,
                                      &MAsn1OfIndefFunction, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array */
    status = MAsn1DecodeIndefiniteUpdateFlag (encoded, sizeof(encoded), MASN1_DECODE_UPDATE, pRoot,
                                              TestSeqDataReturn,
                                              NULL, /* This fct is not called in this test case */
                                              &bytesRead, &done);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Start loop over elements */
    status = MAsn1GetOfElementAtIndex (pRoot, counter, &pElement);
    retval += UNITTEST_STATUS(100, status);
    if (retval > 0)
        goto exit;

    /* Found another? */
    while (NULL != pElement)
    {
        ++counter;
        status = MAsn1GetOfElementAtIndex (pRoot, counter, &pElement);
        retval += UNITTEST_STATUS(100 + counter, status);
        if (retval > 0)
            goto exit;
    }
    retval += UNITTEST_INT(110, counter, 3);
    if (retval > 0)
        goto exit;

    /* Check that each element is different */
    for (idx = 0; idx < counter; ++idx)
    {
        MAsn1GetOfElementAtIndex (pRoot, idx, &(setN[idx]));
    }

    for (idx = 0; idx < counter; ++idx)
    {
        switch (idx)
        {
        case 0:
            retval += UNITTEST_INT(200, setN[idx][1].value.pValue[0], 0x1);
            retval += UNITTEST_INT(210, setN[idx][2].value.pValue[0], 0xFF);
            break;

        case 1:
            {
            unsigned int val;
            val = setN[idx][1].value.pValue[0];
            val <<= 8;
            val += setN[idx][1].value.pValue[1];
            retval += UNITTEST_INT(201, val, 4711);
            retval += UNITTEST_INT(211, setN[idx][2].value.pValue[0], 0x00);
        }
            break;

        case 2:
            retval += UNITTEST_INT(202, setN[idx][1].value.pValue[0], 0x0);
            retval += UNITTEST_INT(212, setN[idx][2].value.pValue[0], 0xFF);
            break;
        }
    }
exit:
    /* Cleanup memory */
    MAsn1FreeElementArray (&pRoot);
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_MAsn1Element_IndefiniteOctetOf()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    ubyte4 bytesRead;
    intBoolean done;
    ubyte4 counter = 0;
    MAsn1Element* pElement = NULL;

    /* input data with two octet string elements */
    ubyte encoded[] =
    { 0xA0, 0x80,
            0x04, 0x08, 0xD7, 0xC7, 0x6F, 0xF5, 0x9B, 0x89, 0x37, 0xB4,
            0x04, 0x08, 0xD8, 0xC8, 0x70, 0xF6, 0x9C, 0x8A, 0x38, 0xB5,
            0x00, 0x00
    };

    /* Test set_of with many entries */
    MAsn1TypeAndCount def[2] =
    {
            { MASN1_TYPE_SEQUENCE_OF | MASN1_IMPLICIT, 1 },
            { MASN1_TYPE_OCTET_STRING, 0 },
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 2, MASN1_FNCT_DECODE,
                                      &MAsn1OfIndefFunction, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array */
    status = MAsn1DecodeIndefiniteUpdateFlag (encoded, sizeof(encoded), MASN1_DECODE_UPDATE, pRoot,
                                              TestSeqDataReturn,
                                              NULL, /* This fct is not called in this test case */
                                              &bytesRead, &done);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Start loop over elements */
    status = MAsn1GetOfElementAtIndex (pRoot, counter, &pElement);
    retval += UNITTEST_STATUS(100, status);
    if (retval > 0)
        goto exit;

    /* Found another? */
    while (NULL != pElement)
    {
        ++counter;
        status = MAsn1GetOfElementAtIndex (pRoot, counter, &pElement);
        retval += UNITTEST_STATUS(100 + counter, status);
        if (retval > 0)
            goto exit;
    }

    retval += UNITTEST_INT(110, counter, 2);

exit:
    /* Cleanup memory */
    MAsn1FreeElementArray (&pRoot);
    return retval;
}

static int read_indefiniteOctet_chunked(ubyte4 chunkSize)
{
    MSTATUS status;
    int retval = 0;
    ubyte4 hint = 100 * chunkSize;

    MAsn1Element* pRoot = NULL;
    ubyte4 bytesRead;
    intBoolean done = FALSE;

    ubyte4 PKRawIdx;
    ubyte4 counter = 0;
    MAsn1Element* pElement = NULL;

    ubyte* buf = NULL;
    ubyte4 copied = 0;

    /* input data with two octet string elements */
    ubyte encoded[] =
    {
            /* SEQUENCE */
            0x30, 0x80,
            /* OID */
            0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x01,
            /* SEQUENCE */
            0x30, 0x14,
            /* OID */
            0x06, 0x08, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x03, 0x07,
            /* OCTET STRING */
            0x04, 0x08, 0xD7, 0xC7, 0x6F, 0xF5, 0x9B, 0x89, 0x37, 0xB4,
            /* [0] IMPLICIT */
            0xA0, 0x80,
            /* OCTET STRING */
            0x04, 0x08, 0xD7, 0xC7, 0x6F, 0xF5, 0x9B, 0x89, 0x37, 0xB4,
            0x04, 0x08, 0xD8, 0xC8, 0x70, 0xF6, 0x9C, 0x8A, 0x38, 0xB5,
            /* EOC */
            0x00, 0x00,
            /* EOC */
            0x00, 0x00,
    };

    /* Test set_of with many entries */
    MAsn1TypeAndCount def[7] =
    {
            {  MASN1_TYPE_SEQUENCE, 3},
                /* contentType:                ContentType */
                {  MASN1_TYPE_OID, 0},
                /* contentEncryptionAlgorithm: ContentEncryptionAlgorithmIdentifier */
                /* ContentEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier */
                {  MASN1_TYPE_SEQUENCE, 2},
                    {  MASN1_TYPE_OID, 0},
                    {  MASN1_TYPE_OCTET_STRING, 0},
                /* encryptedContent: [0] IMPLICIT EncryptedContent OPTIONAL */
                {  MASN1_TYPE_SEQUENCE_OF | MASN1_IMPLICIT | MASN1_OPTIONAL, 1},
                    {  MASN1_TYPE_OCTET_STRING, 0},
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 7, MASN1_FNCT_DECODE,
                                      &MAsn1OfIndefFunction, &pRoot);
    retval += UNITTEST_STATUS(hint+0, status);
    if (retval > 0)
        goto exit;

    /* Decode data using chunks of size 'chunkSize' */
    status = DIGI_MALLOC ((void**) &buf, chunkSize);
    retval += UNITTEST_STATUS(hint+9, status);
    if (retval > 0)
        goto exit;

    while (!done && (sizeof(encoded) > copied))
    {
        ubyte4 newData;
        ubyte4 bytesRead;

        /* Copy next chunk or the final byte(s) */
        if (chunkSize < (sizeof(encoded) - copied))
        {
            newData = chunkSize;
        }
        else
        {
            newData = sizeof(encoded) - copied;
        }
        DIGI_MEMCPY (buf, encoded + copied, newData);
        copied += newData;

        /* Decode from memory array */
        status = MAsn1DecodeIndefiniteUpdateFlag (buf, chunkSize, MASN1_DECODE_UPDATE,
                                                  pRoot,
                                                  TestSeqDataReturn,
                                                  NULL, /* This fct is not called in this test case */
                                                  &bytesRead, &done);
        retval += UNITTEST_STATUS(hint+10, status);
        if (retval > 0)
            goto exit;
    }

    /* Start loop over elements */
    PKRawIdx = 5;

    status = MAsn1GetOfElementAtIndex (pRoot + PKRawIdx,
                                       counter, &pElement);
    retval += UNITTEST_STATUS(hint+20, status);
    if (retval > 0)
        goto exit;

    /* Found another? */
    while (NULL != pElement)
    {
        ++counter;
        status = MAsn1GetOfElementAtIndex (pRoot + PKRawIdx,
                                           counter, &pElement);
        retval += UNITTEST_STATUS(hint+20+counter, status);
        if (retval > 0)
            goto exit;
    }

    retval += UNITTEST_INT(hint+29, counter, 2);

exit:
    /* Cleanup memory */
    DIGI_FREE((void**)&buf);
    MAsn1FreeElementArray (&pRoot);
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_MAsn1Element_IndefiniteOctetOfChunked()
{
    int retval = 0;
    ubyte4 cLen = 1;

    while (cLen < 50)
    {
        retval += read_indefiniteOctet_chunked (cLen);
        if (retval > 0)
            goto exit;

        cLen += 1;
    }

exit:
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_MAsn1Element_Explicit()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    ubyte4 bytesRead;

    /* input data with integer 'payload' */
    ubyte encoded[] =
    {       /* SEQUENCE */
            0x30, 0x12,
            /* OID */
            0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x03,
            /* EXPLICIT */
            0xA0, 0x05,
            /* SEQUENCE */
            0x30, 0x03,
            /* INTEGER */
            0x02, 0x01, 0x00
    };

    /* Sequence with OID and encoded data under explicit tag */
    MAsn1TypeAndCount def[3] =
    {
            { MASN1_TYPE_SEQUENCE, 2 },
            { MASN1_TYPE_OID, 0 },
            { MASN1_TYPE_ENCODED | MASN1_EXPLICIT, 0 },
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 3, MASN1_FNCT_DECODE, NULL, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array */
    status = MAsn1Decode (encoded, sizeof(encoded), pRoot, &bytesRead);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Check payload length */
    retval += UNITTEST_INT(11, pRoot[2].valueLen, 5);

exit:
    /* Cleanup memory */
    MAsn1FreeElementArray (&pRoot);
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_MAsn1Element_ExplicitUpdate()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    ubyte4 bytesRead;
    intBoolean done;

    /* input data with integer 'payload' */
    ubyte encoded[] =
    {       /* SEQUENCE */
            0x30, 0x12,
            /* OID */
            0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x03,
            /* EXPLICIT */
            0xA0, 0x05,
            /* SEQUENCE */
            0x30, 0x03,
            /* INTEGER */
            0x02, 0x01, 0x00
    };

    /* Sequence with OID and encoded data under explicit tag */
    MAsn1TypeAndCount def[3] =
    {
            { MASN1_TYPE_SEQUENCE, 2 },
            { MASN1_TYPE_OID, 0 },
            { MASN1_TYPE_ENCODED | MASN1_EXPLICIT, 0 },
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 3, MASN1_FNCT_DECODE, NULL, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array */
    status = MAsn1DecodeUpdateFlag (encoded, sizeof(encoded), MASN1_DECODE_UPDATE, pRoot,
                                    &bytesRead,
                                    &done);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Check payload length */
    retval += UNITTEST_INT(11, pRoot[2].valueLen, 5);

    /* Check state */
    retval += UNITTEST_TRUE(12, done);

exit:
    /* Cleanup memory */
    MAsn1FreeElementArray (&pRoot);
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_MAsn1Element_ExplicitIndefUpdate()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    ubyte4 bytesRead;
    intBoolean done = 0;
    TestDataReturnInfo returnInfo =
    { NULL, NULL, NULL, 0, 0 };

    /* input data with integer 'payload' */
    ubyte encoded[] =
    {       /* SEQUENCE */
            0x30, 0x12,
            /* OID */
            0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x03,
            /* EXPLICIT */
            0xA0, 0x05,
            /* SEQUENCE */
            0x30, 0x03,
            /* INTEGER */
            0x02, 0x01, 0x00
    };

    /* Sequence with OID and encoded data under explicit tag */
    MAsn1TypeAndCount def[3] =
    {
            { MASN1_TYPE_SEQUENCE, 2 },
            { MASN1_TYPE_OID, 0 },
            { MASN1_TYPE_ENCODED | MASN1_EXPLICIT, 0 },
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 3, MASN1_FNCT_DECODE,
                                      &MAsn1OfIndefFunction, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array */
    status = MAsn1DecodeIndefiniteUpdateFlag (encoded, sizeof(encoded), MASN1_DECODE_UPDATE, pRoot,
                                              TestSeqDataReturn, /* This fct is not called in this test case */
                                              (void *) &returnInfo,
                                              &bytesRead, &done);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Check data return */
    retval += UNITTEST_INT(10, returnInfo.len, 0);
    if (retval > 0)
        goto exit;

    /* Check payload length */
    retval += UNITTEST_INT(11, pRoot[2].valueLen, 5);
    if (retval > 0)
        goto exit;

    /* Check state */
    retval += UNITTEST_TRUE(12, done);

exit:
    /* Cleanup memory */
    FreeTestDataReturn (&returnInfo);
    MAsn1FreeElementArray (&pRoot);
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_MAsn1Element_indefiniteExplicit()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    ubyte4 bytesRead;
    intBoolean done = 0;
    TestDataReturnInfo returnInfo =
    { NULL, NULL, NULL, 0, 0 };

    /* input data with integer 'payload' */
    ubyte encoded[] =
    {       /* SEQUENCE */
            0x30, 0x80,
            /* OID */
            0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x03,
            /* EXPLICIT */
            0xA0, 0x80,
            /* SEQUENCE */
            0x30, 0x80,
            /* INTEGER */
            0x02, 0x01, 0x00,
            /* EOC */
            0x00, 0x00,
            /* EOC */
            0x00, 0x00,
            /* EOC */
            0x00, 0x00
    };

    /* Sequence with OID and encoded data under explicit tag */
    MAsn1TypeAndCount def[3] =
    {
            { MASN1_TYPE_SEQUENCE, 2 },
            { MASN1_TYPE_OID, 0 },
            { MASN1_TYPE_ENCODED | MASN1_EXPLICIT, 0 },
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 3, MASN1_FNCT_DECODE,
                                      &MAsn1OfIndefFunction, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array */
    status = MAsn1DecodeIndefiniteUpdateFlag (encoded, sizeof(encoded), MASN1_DECODE_UPDATE, pRoot,
                                              TestSeqDataReturn,
                                              (void *) &returnInfo,
                                              &bytesRead,
                                              &done);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Check data return */
    retval += UNITTEST_INT(10, returnInfo.len, 7);
    if (retval > 0)
        goto exit;

    /* Check state */
    retval += UNITTEST_TRUE(12, done);

exit:
    /* Cleanup memory */
    FreeTestDataReturn (&returnInfo);
    MAsn1FreeElementArray (&pRoot);
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_MAsn1Element_IndefExplicitIndefUpdateSample()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    ubyte4 bytesRead;
    intBoolean done = 0;
    TestDataReturnInfo returnInfo =
    { NULL, NULL, NULL, 0, 0 };

    ubyte encoded[] =
    {       /* SEQUENCE - @0 */
            0x30, 0x80,
            /* OID - @2 */
            0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x02,
            /* EXPLICIT - @13 */
            0xA0, 0x80,
            /* SEQUENCE - @15 */
            0x30, 0x80,
            /* INTEGER - @17  */
            0x02, 0x01, 0x01,
            /* SET_OF - @20 */
            0x31, 0x0F,
            /* SEQUENCE - @22 */
            0x30, 0x0D,
            /* OID - @24 */
            0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01,
            /* NULL - @35 */
            0x05, 0x00,
            /* SEQUENCE - @37 */
            0x30, 0x83, 0x0E, 0x0A, 0x0F,
            /* OID - @42 */
            0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x01,
    };

    /* Sequence with OID and encoded data under explicit tag */
    MAsn1TypeAndCount def[3] =
    {
            { MASN1_TYPE_SEQUENCE, 2 },
            { MASN1_TYPE_OID, 0 },
            { MASN1_TYPE_ENCODED | MASN1_EXPLICIT, 0 },
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 3, MASN1_FNCT_DECODE,
                                      &MAsn1OfIndefFunction, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array -> 16 bytes */
    status = MAsn1DecodeIndefiniteUpdateFlag (encoded, 16, MASN1_DECODE_UPDATE, pRoot,
                                              TestSeqDataReturn,
                                              (void *) &returnInfo,
                                              &bytesRead,
                                              &done);
    retval += UNITTEST_STATUS(1, status);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(11, returnInfo.len, 1);
    if (retval > 0)
        goto exit;

    /* Decode from memory array -> Next 16 bytes*/
    status = MAsn1DecodeIndefiniteUpdateFlag (encoded+16, 16, MASN1_DECODE_UPDATE, pRoot,
                                              TestSeqDataReturn,
                                              (void *) &returnInfo,
                                              &bytesRead,
                                              &done);
    retval += UNITTEST_STATUS(2, status);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(12, returnInfo.len, 17);
    if (retval > 0)
        goto exit;

    /* Decode from memory array -> Next 16 bytes*/
    status = MAsn1DecodeIndefiniteUpdateFlag (encoded+32, 16, MASN1_DECODE_UPDATE, pRoot,
                                              TestSeqDataReturn,
                                              (void *) &returnInfo,
                                              &bytesRead,
                                              &done);
    retval += UNITTEST_STATUS(3, status);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(13, returnInfo.len, 33);
    if (retval > 0)
        goto exit;

exit:
    /* Cleanup memory */
    FreeTestDataReturn (&returnInfo);
    MAsn1FreeElementArray (&pRoot);
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_MAsn1Element_ExplicitIndefUpdateSample()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    ubyte4 bytesRead;
    intBoolean done = 0;
    TestDataReturnInfo returnInfo =
    { NULL, NULL, NULL, 0, 0 };

    ubyte encoded[] =
    {       /* SEQUENCE - @0 */
            0x30, 0x83, 0x0E, 0x0D, 0xAC,
            /* OID - @5 */
            0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x02,
            /* EXPLICIT - @16 */
            0xA0, 0x83, 0x0E, 0x0D, 0x9C,
            /* SEQUENCE - @21 */
            0x30, 0x83, 0x0E, 0x0D, 0x97,
            /* INTEGER - @26  */
            0x02, 0x01, 0x01,
            /* SET_OF - @29 */
            0x31, 0x0F,
            /* SEQUENCE - @31 */
            0x30, 0x0D,
            /* OID - @33 */
            0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01,
            /* NULL - @44 */
            0x05, 0x00,
            /* SEQUENCE - @46 */
            0x30, 0x83, 0x0E, 0x0A, 0x0F,
            /* OID - @51 */
            0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x01,
    };

    /* Sequence with OID and encoded data under explicit tag */
    MAsn1TypeAndCount def[3] =
    {
        { MASN1_TYPE_SEQUENCE, 2 },
            { MASN1_TYPE_OID, 0 },
            { MASN1_TYPE_ENCODED | MASN1_EXPLICIT, 0 },
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 3, MASN1_FNCT_DECODE,
                                      &MAsn1OfIndefFunction, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array -> 16 bytes */
    status = MAsn1DecodeIndefiniteUpdateFlag (encoded, 16, MASN1_DECODE_UPDATE, pRoot,
                                              TestSeqDataReturn,
                                              (void *) &returnInfo,
                                              &bytesRead,
                                              &done);
    retval += UNITTEST_STATUS(1, status);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(11, pRoot[2].valueLen, 0);
    if (retval > 0)
        goto exit;

    /* Decode from memory array -> Next 16 bytes*/
    status = MAsn1DecodeIndefiniteUpdateFlag (encoded+16, 16, MASN1_DECODE_UPDATE, pRoot,
                                              TestSeqDataReturn,
                                              (void *) &returnInfo,
                                              &bytesRead,
                                              &done);
    retval += UNITTEST_STATUS(2, status);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(12, pRoot[2].valueLen, 11);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(22, pRoot[2].encodingLen, 920993);
    retval += UNITTEST_INT(32, pRoot[2].buffer.remaining, 920977);
    if (retval > 0)
        goto exit;

    /* Decode from memory array -> Next 16 bytes*/
    status = MAsn1DecodeIndefiniteUpdateFlag (encoded+32, 16, MASN1_DECODE_UPDATE, pRoot,
                                              TestSeqDataReturn,
                                              (void *) &returnInfo,
                                              &bytesRead,
                                              &done);
    retval += UNITTEST_STATUS(3, status);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(13, pRoot[2].valueLen, 16);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(23, pRoot[2].encodingLen, 920993);
    retval += UNITTEST_INT(33, pRoot[2].buffer.remaining, 920961);
    if (retval > 0)
        goto exit;

exit:
    /* Cleanup memory */
    FreeTestDataReturn (&returnInfo);
    MAsn1FreeElementArray (&pRoot);
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_MAsn1Element_ExplicitUpdateSample()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    ubyte4 bytesRead;
    intBoolean done = 0;
    TestDataReturnInfo returnInfo =
    { NULL, NULL, NULL, 0, 0 };

    ubyte encoded[] =
    {       /* SEQUENCE - @0 */
            0x30, 0x83, 0x0E, 0x0D, 0xAC,
            /* OID - @5 */
            0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x02,
            /* EXPLICIT - @16 */
            0xA0, 0x83, 0x0E, 0x0D, 0x9C,
            /* SEQUENCE - @21 */
            0x30, 0x83, 0x0E, 0x0D, 0x97,
            /* INTEGER - @26  */
            0x02, 0x01, 0x01,
            /* SET_OF - @29 */
            0x31, 0x0F,
            /* SEQUENCE - @31 */
            0x30, 0x0D,
            /* OID - @33 */
            0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01,
            /* NULL - @44 */
            0x05, 0x00,
            /* SEQUENCE - @46 */
            0x30, 0x83, 0x0E, 0x0A, 0x0F,
            /* OID - @51 */
            0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x01,
    };

    /* Sequence with OID and encoded data under explicit tag */
    MAsn1TypeAndCount def[3] =
    {
            { MASN1_TYPE_SEQUENCE, 2 },
            { MASN1_TYPE_OID, 0 },
            { MASN1_TYPE_ENCODED | MASN1_EXPLICIT, 0 },
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 3, MASN1_FNCT_DECODE,
                                      &MAsn1OfIndefFunction, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array -> 16 bytes */
    status = MAsn1DecodeUpdateFlag (encoded, 16, MASN1_DECODE_UPDATE, pRoot,
                                    &bytesRead,
                                    &done);
    retval += UNITTEST_STATUS(1, status);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(11, pRoot[2].valueLen, 0);
    if (retval > 0)
        goto exit;

    /* Decode from memory array -> Next 16 bytes*/
    status = MAsn1DecodeUpdateFlag (encoded+16, 16, MASN1_DECODE_UPDATE, pRoot,
                                    &bytesRead,
                                    &done);
    retval += UNITTEST_STATUS(2, status);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(12, pRoot[2].valueLen, 11);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(22, pRoot[2].encodingLen, 920993);
    retval += UNITTEST_INT(32, pRoot[2].buffer.remaining, 920977);
    if (retval > 0)
        goto exit;

    /* Decode from memory array -> Next 16 bytes*/
    status = MAsn1DecodeUpdateFlag (encoded+32, 16, MASN1_DECODE_UPDATE, pRoot,
                                    &bytesRead,
                                    &done);
    retval += UNITTEST_STATUS(3, status);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(13, pRoot[2].valueLen, 16);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(23, pRoot[2].encodingLen, 920993);
    retval += UNITTEST_INT(33, pRoot[2].buffer.remaining, 920961);
    if (retval > 0)
        goto exit;

exit:
    /* Cleanup memory */
    FreeTestDataReturn (&returnInfo);
    MAsn1FreeElementArray (&pRoot);
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_MAsn1Element_ExplicitIndefEncodingSample()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    ubyte4 bytesRead;
    intBoolean done = 0;
    sbyte4 cmpResult;
    ubyte buf[16];

    TestDataReturnInfo returnInfo =
    { NULL, NULL, NULL, 0, 0 };

    ubyte encoded[] =
    {       /* SEQUENCE - @0 */
            0x30, 0x83, 0x0E, 0x0D, 0xAC,
            /* OID - @5 */
            0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x02,
            /* EXPLICIT - @16 */
            0xA0, 0x83, 0x0E, 0x0D, 0x9C,
            /* SEQUENCE - @21 */
            0x30, 0x83, 0x0E, 0x0D, 0x97,
            /* INTEGER - @26  */
            0x02, 0x01, 0x01,
            /* SET_OF - @29 */
            0x31, 0x0F,
            /* SEQUENCE - @31 */
            0x30, 0x0D,
            /* OID - @33 */
            0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01,
            /* NULL - @44 */
            0x05, 0x00,
            /* SEQUENCE - @46 */
            0x30, 0x83, 0x0E, 0x0A, 0x0F,
            /* OID - @51 */
            0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x01,
    };

    /* Sequence with OID and encoded data under explicit tag */
    MAsn1TypeAndCount def[3] =
    {
            { MASN1_TYPE_SEQUENCE, 2 },
            { MASN1_TYPE_OID, 0 },
            { MASN1_TYPE_ENCODED | MASN1_EXPLICIT, 0 },
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 3, MASN1_FNCT_DECODE,
                                      &MAsn1OfIndefFunction, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array -> 2 bytes */
    DIGI_MEMCPY(buf, encoded, 2);
    status = MAsn1DecodeIndefiniteUpdateFlag (buf, 2, MASN1_DECODE_UPDATE, pRoot,
                                              TestSeqDataReturn,
                                              (void *) &returnInfo,
                                              &bytesRead,
                                              &done);
    retval += UNITTEST_STATUS(1, status);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(2, pRoot[0].state, MASN1_STATE_DECODE_LEN_LEN);
    retval += UNITTEST_INT(3, pRoot[0].encodingLen, 2);
    DIGI_MEMCMP (pRoot[0].encoding.pEncoding, encoded, 2, &cmpResult);
    retval += UNITTEST_INT(4, cmpResult, 0);
    if (retval > 0)
        goto exit;

    /* Decode from memory array -> 2 bytes */
    DIGI_MEMCPY(buf, encoded+2, 2);
    status = MAsn1DecodeIndefiniteUpdateFlag (buf, 2, MASN1_DECODE_UPDATE, pRoot,
                                              TestSeqDataReturn,
                                              (void *) &returnInfo,
                                              &bytesRead,
                                              &done);
    retval += UNITTEST_STATUS(11, status);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(12, pRoot[0].state, MASN1_STATE_DECODE_PARTIAL_LEN);
    retval += UNITTEST_INT(13, pRoot[0].encodingLen, 4);
    DIGI_MEMCMP (pRoot[0].encoding.pEncoding, encoded+2, 2, &cmpResult);
    retval += UNITTEST_INT(14, cmpResult, 0);
    if (retval > 0)
        goto exit;

    /* Decode from memory array -> 2 bytes */
    DIGI_MEMCPY(buf, encoded+4, 2);
    status = MAsn1DecodeIndefiniteUpdateFlag (buf, 2, MASN1_DECODE_UPDATE, pRoot,
                                              TestSeqDataReturn,
                                              (void *) &returnInfo,
                                              &bytesRead,
                                              &done);
    retval += UNITTEST_STATUS(21, status);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(22, pRoot[0].state, MASN1_STATE_DECODE_PARTIAL);
    retval += UNITTEST_INT(23, pRoot[0].encodingLen, 921009);
    DIGI_MEMCMP (pRoot[0].encoding.pEncoding, encoded+4, 2, &cmpResult);
    retval += UNITTEST_INT(24, cmpResult, 0);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(32, pRoot[1].state, MASN1_STATE_DECODE_TAG);
    retval += UNITTEST_INT(33, pRoot[1].encodingLen, 1);
    retval += UNITTEST_INT(33, pRoot[1].valueLen, 0);
    DIGI_MEMCMP (pRoot[1].encoding.pEncoding, encoded+5, 1, &cmpResult);
    retval += UNITTEST_INT(34, cmpResult, 0);
    if (retval > 0)
        goto exit;

    /* Decode from memory array -> 2 bytes */
    DIGI_MEMCPY(buf, encoded+6, 2);
    status = MAsn1DecodeIndefiniteUpdateFlag (buf, 2, MASN1_DECODE_UPDATE, pRoot,
                                              TestSeqDataReturn,
                                              (void *) &returnInfo,
                                              &bytesRead,
                                              &done);
    retval += UNITTEST_STATUS(41, status);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(42, pRoot[1].state, MASN1_STATE_DECODE_PARTIAL);
    retval += UNITTEST_INT(43, pRoot[1].encodingLen, 11);
    retval += UNITTEST_INT(43, pRoot[1].valueLen, 1);
    retval += UNITTEST_INT(43, pRoot[1].buffer.remaining, 8);
    DIGI_MEMCMP (pRoot[1].value.pValue, encoded+7, 1, &cmpResult);
    retval += UNITTEST_INT(45, cmpResult, 0);
    if (retval > 0)
        goto exit;

    /* Decode from memory array -> 2 bytes */
    DIGI_MEMCPY(buf, encoded+8, 2);
    status = MAsn1DecodeIndefiniteUpdateFlag (buf, 2, MASN1_DECODE_UPDATE, pRoot,
                                              TestSeqDataReturn,
                                              (void *) &returnInfo,
                                              &bytesRead,
                                              &done);
    retval += UNITTEST_STATUS(51, status);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(52, pRoot[1].state, MASN1_STATE_DECODE_PARTIAL);
    retval += UNITTEST_INT(53, pRoot[1].encodingLen, 11);
    retval += UNITTEST_INT(53, pRoot[1].valueLen, 2);
    retval += UNITTEST_INT(53, pRoot[1].buffer.remaining, 6);
    DIGI_MEMCMP (pRoot[1].value.pValue, encoded+8, 2, &cmpResult);
    retval += UNITTEST_INT(55, cmpResult, 0);
    if (retval > 0)
        goto exit;

exit:
    /* Cleanup memory */
    FreeTestDataReturn (&returnInfo);
    MAsn1FreeElementArray (&pRoot);
    return retval;
}

/*----------------------------------------------------------------------*/

static int
read_indefExplicit_chunked(ubyte4 chunkSize)
{
    MSTATUS status;
    int retval = 0;

    ubyte4 hint = 100 * chunkSize;

    MAsn1Element* pRoot = NULL;
    ubyte  *buf = NULL;
    ubyte4 idx;

    ubyte4 copied = 0;

    TestDataReturnInfo returnInfo =
    { NULL, NULL, NULL, 0, 0 };
    intBoolean done = 0;

    /* input data with integer 'payload' */
    ubyte encoded[] =
    {       /* SEQUENCE */
            0x30, 0x80,
            /* OID */
            0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x03,
            /* EXPLICIT */
            0xA0, 0x80,
            /* SEQUENCE */
            0x30, 0x80,
            /* INTEGER */
            0x02, 0x01, 0x00,
            /* EOC */
            0x00, 0x00,
            /* EOC */
            0x00, 0x00,
            /* EOC */
            0x00, 0x00
    };

    /* Sequence with OID and encoded data under explicit tag */
    MAsn1TypeAndCount def[3] =
    {
            { MASN1_TYPE_SEQUENCE, 2 },
            { MASN1_TYPE_OID, 0 },
            { MASN1_TYPE_ENCODED | MASN1_EXPLICIT, 0 },
    };

    /* Do not run test for large chunk sizes */
    if (chunkSize > sizeof(encoded))
    {
        goto exit;
    }

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 3, MASN1_FNCT_DECODE,
                                      &MAsn1OfIndefFunction, &pRoot);
    retval += UNITTEST_STATUS(hint, status);
    if (retval > 0)
        goto exit;

    /* Decode data using chunks of size 'chunkSize' */
    status = DIGI_MALLOC ((void**) &buf, chunkSize);
    retval += UNITTEST_STATUS(hint + 9, status);
    if (retval > 0)
        goto exit;

    while (!done && (sizeof(encoded) > copied))
    {
        ubyte4 newData;
        ubyte4 bytesRead;

        /* Copy next chunk or the final byte(s) */
        if (chunkSize < (sizeof(encoded) - copied))
        {
            newData = chunkSize;
        }
        else
        {
            newData = sizeof(encoded) - copied;
        }
        DIGI_MEMCPY (buf, encoded + copied, newData);
        copied += newData;

        status = MAsn1DecodeIndefiniteUpdateFlag (buf, newData, MASN1_DECODE_UPDATE,
                                                  pRoot,
                                                  TestSeqDataReturn,
                                                  (void *) &returnInfo,
                                                  &bytesRead,
                                                  &done);
        retval += UNITTEST_STATUS(1 + 100 * idx, status);
        if (retval > 0)
            goto exit;
    }

    /* Check data return */
    retval += UNITTEST_INT(hint + 2, returnInfo.len, 7);
    if (retval > 0)
        goto exit;

    /* Check state */
    retval += UNITTEST_TRUE(hint + 12, done);

exit:
    /* Cleanup memory */
    DIGI_FREE ((void **) &buf);
    FreeTestDataReturn(&returnInfo);
    MAsn1FreeElementArray (&pRoot);
    return retval;

}

int mocdecode_test_MAsn1Element_indefiniteChunkedExplicit()
{
    int retval = 0;
    ubyte4 cLen = 1;

    while (cLen < 32)
    {
        retval += read_indefExplicit_chunked (cLen);
        if (retval > 0)
            goto exit;

        cLen += 1;
    }

exit:
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_MAsn1Element_SetOfExplicit()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    MAsn1Element* pSet = NULL;
    ubyte4 bytesRead;
    intBoolean done = 0;
    ubyte4 counter = 0;
    MAsn1Element* pElement = NULL;

    /* input data with octet strings 'payload' */
    ubyte encoded[] =
    {       /* SEQUENCE */
            0x30, 0x56,
            /* OID */
            0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x03,
            /* EXPLICIT */
            0xA0, 0x49,
            /* SEQUENCE */
            0x30, 0x47,
            /* INTEGER */
            0x02, 0x01, 0x00,
            /* SET */
            0x31, 0x42,
            /* SEQUENCE */
            0x30, 0x1F,
            /* OCTET STRING */
            0x04, 0x1D,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04,
            /* SEQUENCE */
            0x30, 0x1F,
            /* OCTET STRING */
            0x04, 0x1D,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04,
    };

    /* Sequence with OID and encoded data under explicit tag */
    MAsn1TypeAndCount def[3] =
    {
            { MASN1_TYPE_SEQUENCE, 2 },
            { MASN1_TYPE_OID, 0 },
            { MASN1_TYPE_ENCODED | MASN1_EXPLICIT, 0 },
    };

    MAsn1TypeAndCount def2[4] =
    {
            { MASN1_TYPE_SEQUENCE, 2 },
            { MASN1_TYPE_INTEGER, 0 },
            { MASN1_TYPE_SET_OF, 1 },
            { MASN1_TYPE_ENCODED, 0 },
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 3, MASN1_FNCT_DECODE,
                                      &MAsn1OfFunction, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Create the 'array' set */
    status = MAsn1CreateElementArray (def2, 4, MASN1_FNCT_DECODE,
                                      &MAsn1OfFunction, &pSet);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array */
    status = MAsn1DecodeUpdateFlag (encoded, sizeof(encoded), MASN1_DECODE_UPDATE, pRoot,
                                    &bytesRead,
                                    &done);
    retval += UNITTEST_STATUS(10, status);
    if (retval > 0)
        goto exit;

    /* Check state */
    retval += UNITTEST_TRUE(12, done);
    if (retval > 0)
        goto exit;

    intBoolean done2 = 0;
    status = MAsn1DecodeUpdateFlag (pRoot[2].value.pValue, pRoot[2].valueLen, MASN1_DECODE_UPDATE, pSet,
                                    &bytesRead,
                                    &done2);
    retval += UNITTEST_STATUS(11, status);
    if (retval > 0)
        goto exit;

    /* Check state */
    retval += UNITTEST_TRUE(13, done2);
    if (retval > 0)
        goto exit;

    /* Start loop over elements */
    status = MAsn1GetOfElementAtIndex (pSet + 2,
                                       counter,
                                       &pElement);
    retval += UNITTEST_STATUS(100, status);
    if (retval > 0)
        goto exit;

    /* Found another? */
    while (NULL != pElement)
    {
        ++counter;
        status = MAsn1GetOfElementAtIndex (pSet + 2,
                                           counter,
                                           &pElement);
        retval += UNITTEST_STATUS(100 + counter, status);
        if (retval > 0)
            goto exit;
    }
    retval += UNITTEST_INT(110, counter, 2);

exit:
    /* Cleanup memory */
    MAsn1FreeElementArray (&pSet);
    MAsn1FreeElementArray (&pRoot);
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_MAsn1Element_indefiniteSetOfExplicit()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    MAsn1Element* pSet = NULL;
    ubyte4 bytesRead;
    intBoolean done = 0;
    TestDataReturnInfo returnInfo =
    { NULL, NULL, NULL, 0, 0 };
    intBoolean done2 = 0;
    TestDataReturnInfo returnInfo2 =
    { NULL, NULL, NULL, 0, 0 };
    ubyte4 counter = 0;
    MAsn1Element* pElement = NULL;

    /* input data with integer 'payload' */
    ubyte encoded[] =
    {       /* SEQUENCE */
            0x30, 0x80,
            /* OID */
            0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x03,
            /* EXPLICIT */
            0xA0, 0x80,
            /* SEQUENCE */
            0x30, 0x80,
            /* INTEGER */
            0x02, 0x01, 0x00,
            /* SET */
            0x31, 0x42,
            /* SEQUENCE */
            0x30, 0x1F,
            /* OCTET STRING */
            0x04, 0x1D,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04,
            /* SEQUENCE */
            0x30, 0x1F,
            /* OCTET STRING */
            0x04, 0x1D,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04,
            /* EOC */
            0x00, 0x00,
            /* EOC */
            0x00, 0x00,
            /* EOC */
            0x00, 0x00
    };

    /* Sequence with OID and encoded data under explicit tag */
    MAsn1TypeAndCount def[3] =
    {
            { MASN1_TYPE_SEQUENCE, 2 },
            { MASN1_TYPE_OID, 0 },
            { MASN1_TYPE_ENCODED | MASN1_EXPLICIT, 0 },
    };

    MAsn1TypeAndCount def2[4] =
    {
            { MASN1_TYPE_SEQUENCE, 2 },
            { MASN1_TYPE_INTEGER, 0 },
            { MASN1_TYPE_SET_OF, 1 },
            { MASN1_TYPE_ENCODED, 0 },
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 3, MASN1_FNCT_DECODE,
                                      &MAsn1OfIndefFunction, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Create the 'array' set */
    status = MAsn1CreateElementArray (def2, 4, MASN1_FNCT_DECODE,
                                      &MAsn1OfIndefFunction, &pSet);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array */
    status = MAsn1DecodeIndefiniteUpdateFlag (encoded, sizeof(encoded), MASN1_DECODE_UPDATE, pRoot,
                                              TestSeqDataReturn,
                                              (void *) &returnInfo,
                                              &bytesRead,
                                              &done);
    retval += UNITTEST_STATUS(10, status);
    if (retval > 0)
        goto exit;

    /* Check state */
    retval += UNITTEST_TRUE(12, done);
    if (retval > 0)
        goto exit;

    status = MAsn1DecodeIndefiniteUpdateFlag (returnInfo.pData, returnInfo.len, MASN1_DECODE_UPDATE,
                                              pSet,
                                              TestSeqDataReturn,
                                              (void *) &returnInfo2,
                                              &bytesRead,
                                              &done2);
    retval += UNITTEST_STATUS(11, status);
    if (retval > 0)
        goto exit;

    /* Start loop over elements */
    status = MAsn1GetOfElementAtIndex (pSet + 2,
                                       counter,
                                       &pElement);
    retval += UNITTEST_STATUS(100, status);
    if (retval > 0)
        goto exit;

    /* Found another? */
    while (NULL != pElement)
    {
        ++counter;
        status = MAsn1GetOfElementAtIndex (pSet + 2,
                                           counter,
                                           &pElement);
        retval += UNITTEST_STATUS(100 + counter, status);
        if (retval > 0)
            goto exit;
    }
    retval += UNITTEST_INT(110, counter, 2);

exit:
    /* Cleanup memory */
    FreeTestDataReturn (&returnInfo);
    FreeTestDataReturn (&returnInfo2);
    MAsn1FreeElementArray (&pSet);
    MAsn1FreeElementArray (&pRoot);
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_MAsn1Element_definiteSetOfExplicit()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    MAsn1Element* pSet = NULL;
    ubyte4 bytesRead;
    intBoolean done = 0;
    TestDataReturnInfo returnInfo =
    { NULL, NULL, NULL, 0, 0 };
    intBoolean done2 = 0;
    TestDataReturnInfo returnInfo2 =
    { NULL, NULL, NULL, 0, 0 };
    ubyte4 counter = 0;
    MAsn1Element* pElement = NULL;

    /* input data with octet strings 'payload' */
    ubyte encoded[] =
    {       /* SEQUENCE */
            0x30, 0x56,
            /* OID */
            0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x03,
            /* EXPLICIT */
            0xA0, 0x49,
            /* SEQUENCE */
            0x30, 0x47,
            /* INTEGER */
            0x02, 0x01, 0x00,
            /* SET */
            0x31, 0x42,
            /* SEQUENCE */
            0x30, 0x1F,
            /* OCTET STRING */
            0x04, 0x1D,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04,
            /* SEQUENCE */
            0x30, 0x1F,
            /* OCTET STRING */
            0x04, 0x1D,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04,
    };

    /* Sequence with OID and encoded data under explicit tag */
    MAsn1TypeAndCount def[3] =
    {
            { MASN1_TYPE_SEQUENCE, 2 },
            { MASN1_TYPE_OID, 0 },
            { MASN1_TYPE_ENCODED | MASN1_EXPLICIT, 0 },
    };

    MAsn1TypeAndCount def2[4] =
    {
            { MASN1_TYPE_SEQUENCE, 2 },
            { MASN1_TYPE_INTEGER, 0 },
            { MASN1_TYPE_SET_OF, 1 },
            { MASN1_TYPE_ENCODED, 0 },
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 3, MASN1_FNCT_DECODE,
                                      &MAsn1OfIndefFunction, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Create the 'array' set */
    status = MAsn1CreateElementArray (def2, 4, MASN1_FNCT_DECODE,
                                      &MAsn1OfIndefFunction, &pSet);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array */
    status = MAsn1DecodeIndefiniteUpdateFlag (encoded, sizeof(encoded), MASN1_DECODE_UPDATE, pRoot,
                                              TestSeqDataReturn,
                                              (void *) &returnInfo,
                                              &bytesRead,
                                              &done);
    retval += UNITTEST_STATUS(10, status);
    if (retval > 0)
        goto exit;

    /* Check state */
    retval += UNITTEST_TRUE(12, done);
    if (retval > 0)
        goto exit;

    if (returnInfo.len > 0)
    {
        status = MAsn1DecodeIndefiniteUpdateFlag (returnInfo.pData, returnInfo.len, MASN1_DECODE_UPDATE,
                                                  pSet,
                                                  TestSeqDataReturn,
                                                  (void *) &returnInfo2,
                                                  &bytesRead,
                                                  &done2);
    }
    else if (pRoot[2].valueLen > 0)
    {
        status = MAsn1DecodeIndefiniteUpdateFlag (pRoot[2].value.pValue,
                                                  pRoot[2].valueLen,
                                                  MASN1_DECODE_UPDATE,
                                                  pSet,
                                                  TestSeqDataReturn,
                                                  (void *) &returnInfo2,
                                                  &bytesRead,
                                                  &done2);
    }
    retval += UNITTEST_STATUS(11, status);
    if (retval > 0)
        goto exit;

    /* Start loop over elements */
    status = MAsn1GetOfElementAtIndex (pSet + 2,
                                       counter,
                                       &pElement);
    retval += UNITTEST_STATUS(100, status);
    if (retval > 0)
        goto exit;

    /* Found another? */
    while (NULL != pElement)
    {
        ++counter;
        status = MAsn1GetOfElementAtIndex (pSet + 2,
                                           counter,
                                           &pElement);
        retval += UNITTEST_STATUS(100 + counter, status);
        if (retval > 0)
            goto exit;
    }
    retval += UNITTEST_INT(110, counter, 2);

exit:
    /* Cleanup memory */
    FreeTestDataReturn (&returnInfo);
    FreeTestDataReturn (&returnInfo2);
    MAsn1FreeElementArray (&pSet);
    MAsn1FreeElementArray (&pRoot);
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_MAsn1Element_CMSEnvelopeSample()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    MAsn1Element* pEnv = NULL;

    ubyte4 bytesRead;
    intBoolean done = 0;
    sbyte4 cmpResult;

    ubyte4 section;
    ubyte4 idx;
    MAsn1Element* pElement = NULL;
    ubyte4 P7Rawidx;

    TestDataReturnInfo returnInfo1 =
    { NULL, NULL, NULL, 0, 0 };
    TestDataReturnInfo returnInfo2 =
    { NULL, NULL, NULL, 0, 0 };

    /* ContentInfo sequence [rfc5652 - Section 3, page 6] */
    MAsn1TypeAndCount defEnv[3] =
    {
     {  MASN1_TYPE_SEQUENCE, 2},
       /* contentType:           ContentType */
       {  MASN1_TYPE_OID, 0},
       /* content [0] EXPLICIT:  ANY DEFINED BY contentType */
       {  MASN1_TYPE_ENCODED | MASN1_EXPLICIT, 0},
    };

    MAsn1TypeAndCount def[15] =
    {
     {  MASN1_TYPE_SEQUENCE, 5},
       /* version:               CMSVersion */
       {  MASN1_TYPE_INTEGER, 0},
       /* originatorInfo [0] IMPLICIT: OriginatorInfo OPTIONAL */
       {  MASN1_TYPE_SEQUENCE | MASN1_IMPLICIT | MASN1_OPTIONAL, 1},
           {  MASN1_TYPE_ENCODED, 0},
       /* recipientInfos:        RecipientInfos */
       {  MASN1_TYPE_SET_OF, 1},
           {  MASN1_TYPE_ENCODED, 0},
       /* encryptedContentInfo:  EncryptedContentInfo */
       {  MASN1_TYPE_SEQUENCE, 3},
           /* contentType:                ContentType */
           {  MASN1_TYPE_OID, 0},
           /* contentEncryptionAlgorithm: ContentEncryptionAlgorithmIdentifier */
           /* ContentEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier */
           {  MASN1_TYPE_SEQUENCE, 2},
               {  MASN1_TYPE_OID, 0},
               {  MASN1_TYPE_OCTET_STRING, 0},
           /* encryptedContent: [0] IMPLICIT EncryptedContent OPTIONAL */
           {  MASN1_TYPE_SEQUENCE_OF | MASN1_IMPLICIT | MASN1_OPTIONAL, 1},
               {  MASN1_TYPE_OCTET_STRING, 0},
       /* unprotectedAttrs [1] IMPLICIT: UnprotectedAttributes OPTIONAL */
       {  MASN1_TYPE_SEQUENCE | MASN1_IMPLICIT | 1 | MASN1_OPTIONAL, 1},
           {  MASN1_TYPE_ENCODED, 0},
    };

    /* input data with integer 'payload' */
    ubyte encoded[] =
    {
            /* SEQUENCE */
            0x30, 0x80,
            /* OID */
            0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x03,
            /* [0] EXPLICIT */
            0xA0, 0x80,
            /* SEQUENCE */
            0x30, 0x80,
            /* INTEGER */
            0x02, 0x01, 0x00,
            /* SET */
            0x31, 0x42,
            /* SEQUENCE */
            0x30, 0x1F,
            /* OCTET STRING */
            0x04, 0x1D,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04,
            /* SEQUENCE */
            0x30, 0x1F,
            /* OCTET STRING */
            0x04, 0x1D,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04,
            /* SEQUENCE */
            0x30, 0x80,
            /* OID */
            0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x01,
            /* SEQUENCE */
            0x30, 0x14,
            /* OID */
            0x06, 0x08, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x03, 0x07,
            /* OCTET STRING */
            0x04, 0x08, 0xD7, 0xC7, 0x6F, 0xF5, 0x9B, 0x89, 0x37, 0xB4,
            /* [0] IMPLICIT */
            0xA0, 0x80,
            /* OCTET STRING */
            0x04, 0x08, 0xF1, 0xF2, 0xF3, 0xF4, 0x00, 0x00, 0x00, 0x00,
            0x04, 0x08, 0xE1, 0xE2, 0xE3, 0xE4, 0x00, 0x00, 0x00, 0x00,
            /* EOC */
            0x00, 0x00,
            /* EOC */
            0x00, 0x00,
            /* EOC */
            0x00, 0x00,
            /* EOC */
            0x00, 0x00,
            /* EOC */
            0x00, 0x00,
    };

    /* Create the 'array' env */
    status = MAsn1CreateElementArray (defEnv, 3, MASN1_FNCT_DECODE,
                                      &MAsn1OfIndefFunction, &pEnv);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 15, MASN1_FNCT_DECODE,
                                      &MAsn1OfIndefFunction, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array */
    status = MAsn1DecodeIndefiniteUpdateFlag (encoded, sizeof(encoded), MASN1_DECODE_UPDATE,
                                              pEnv,
                                              TestSeqDataReturn,
                                              (void *) &returnInfo1,
                                              &bytesRead,
                                              &done);
    retval += UNITTEST_STATUS(10, status);
    if (retval > 0)
        goto exit;

    /* Check state */
    retval += UNITTEST_TRUE(11, done);
    if (retval > 0)
        goto exit;

    /* Found the correct OID? */
    status = ASN1_compareOID (CMS_ENVELOPE_DATA, CMS_ENVELOPE_DATA_LEN,
                              pEnv[1].encoding.pEncoding,
                              pEnv[1].encodingLen,
                              NULL, &cmpResult);
    retval += UNITTEST_STATUS(12, status);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(13, cmpResult, 0);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(15, returnInfo1.len, 136);
    if (retval > 0)
        goto exit;

    /* Decode from collected buffer */
    status = MAsn1DecodeIndefiniteUpdateFlag (returnInfo1.pData,
                                              returnInfo1.len,
                                              MASN1_DECODE_UPDATE,
                                              pRoot,
                                              TestSeqDataReturn,
                                              (void *) &returnInfo2,
                                              &bytesRead,
                                              &done);
    retval += UNITTEST_STATUS(20, status);
    if (retval > 0)
        goto exit;

    /* Check state */
    retval += UNITTEST_TRUE(21, done);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(25, returnInfo2.len, 0);
    if (retval > 0)
        goto exit;

    /* How many sections in the 'raw data'? */
    P7Rawidx = 11;
    section = 0;

    status = MAsn1GetOfElementAtIndex (pRoot + P7Rawidx,
                                       section,
                                       &pElement);
    retval += UNITTEST_STATUS(70, status);
    if (retval > 0)
       goto exit;

    while (NULL != pElement)
    {
        ++section;
        status = MAsn1GetOfElementAtIndex (pRoot + P7Rawidx,
                                           section,
                                           &pElement);
        retval += UNITTEST_STATUS(71, status);
        if (retval > 0)
           goto exit;
    }

    retval += UNITTEST_INT(72, section, 2);
    if (retval > 0)
        goto exit;

exit:
    FreeTestDataReturn (&returnInfo1);
    FreeTestDataReturn (&returnInfo2);
    MAsn1FreeElementArray (&pRoot);
    MAsn1FreeElementArray (&pEnv);
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_MAsn1Element_CMSEnvelopeChunkOctetSample()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    MAsn1Element* pEnv = NULL;

    ubyte4 bytesRead;
    intBoolean done = 0;
    sbyte4 cmpResult;
    ubyte4 section;
    ubyte4 idx;
    MAsn1Element* pElement = NULL;

    TestDataReturnInfo returnInfo1 =
    { NULL, NULL, NULL, 0, 0 };
    TestDataReturnInfo returnInfo2 =
    { NULL, NULL, NULL, 0, 0 };

    /* ContentInfo sequence [rfc5652 - Section 3, page 6] */
    MAsn1TypeAndCount defEnv[3] =
    {
     {  MASN1_TYPE_SEQUENCE, 2},
       /* contentType:           ContentType */
       {  MASN1_TYPE_OID, 0},
       /* content [0] EXPLICIT:  ANY DEFINED BY contentType */
       {  MASN1_TYPE_ENCODED | MASN1_EXPLICIT, 0},
    };

    MAsn1TypeAndCount def[15] =
    {
     {  MASN1_TYPE_SEQUENCE, 5},
       /* version:               CMSVersion */
       {  MASN1_TYPE_INTEGER, 0},
       /* originatorInfo [0] IMPLICIT: OriginatorInfo OPTIONAL */
       {  MASN1_TYPE_SEQUENCE | MASN1_IMPLICIT | MASN1_OPTIONAL, 1},
           {  MASN1_TYPE_ENCODED, 0},
       /* recipientInfos:        RecipientInfos */
       {  MASN1_TYPE_SET_OF, 1},
           {  MASN1_TYPE_ENCODED, 0},
       /* encryptedContentInfo:  EncryptedContentInfo */
       {  MASN1_TYPE_SEQUENCE, 3},
           /* contentType:                ContentType */
           {  MASN1_TYPE_OID, 0},
           /* contentEncryptionAlgorithm: ContentEncryptionAlgorithmIdentifier */
           /* ContentEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier */
           {  MASN1_TYPE_SEQUENCE, 2},
               {  MASN1_TYPE_OID, 0},
               {  MASN1_TYPE_OCTET_STRING, 0},
           /* encryptedContent: [0] IMPLICIT EncryptedContent OPTIONAL */
           {  MASN1_TYPE_SEQUENCE_OF | MASN1_IMPLICIT | MASN1_OPTIONAL, 1},
               {  MASN1_TYPE_OCTET_STRING, 0},
       /* unprotectedAttrs [1] IMPLICIT: UnprotectedAttributes OPTIONAL */
       {  MASN1_TYPE_SEQUENCE | MASN1_IMPLICIT | 1 | MASN1_OPTIONAL, 1},
           {  MASN1_TYPE_ENCODED, 0},
    };

    ubyte2 idxAlgoBytes = 10;
    ubyte2 idxContent = 11;
    ubyte2 idxRaw = 12;
    ubyte2 idxAttr = 13;

    /* input data with integer 'payload' */
    ubyte encoded[] =
    {
            /* SEQUENCE - @0 */
            0x30, 0x80,
            /* OID - @2 */
            0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x03,
            /* [0] EXPLICIT - @13 */
            0xA0, 0x80,
            /* SEQUENCE - @15 */
            0x30, 0x80,
            /* INTEGER - @17 */
            0x02, 0x01, 0x00,
            /* SET - @20 */
            0x31, 0x42,
            /* SEQUENCE - @22 */
            0x30, 0x1F,
            /* OCTET STRING - @24 */
            0x04, 0x1D,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04,
            /* SEQUENCE - @55 */
            0x30, 0x1F,
            /* OCTET STRING - @57 */
            0x04, 0x1D,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04,
            /* SEQUENCE - @88 */
            0x30, 0x80,
            /* OID - @90 */
            0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x01,
            /* SEQUENCE - @101 */
            0x30, 0x14,
            /* OID - @103 */
            0x06, 0x08, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x03, 0x07,
            /* OCTET STRING - @113 */
            0x04, 0x08, 0xD7, 0xC7, 0x6F, 0xF5, 0x9B, 0x89, 0x37, 0xB4,
            /* [0] IMPLICIT - @123 */
            0xA0, 0x80,
            /* OCTET STRING - @125 */
            0x04, 0x08, 0xF1, 0xF2, 0x00, 0xF3, 0xF4, 0x00, 0xF5, 0xF6,
            /* OCTET STRING - @135 */
            0x04, 0x08, 0xE1, 0xE2, 0x00, 0x00, 0x00, 0x00, 0xE3, 0xE4,
            /* EOC - @145 */
            0x00, 0x00,
            /* EOC - @147 */
            0x00, 0x00,
            /* EOC - @149 */
            0x00, 0x00,
            /* EOC - @151 */
            0x00, 0x00,
            /* EOC - @153 */
            0x00, 0x00,
    };

    /* Create the 'array' env */
    status = MAsn1CreateElementArray (defEnv, 3, MASN1_FNCT_DECODE,
                                      &MAsn1OfIndefFunction, &pEnv);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 15, MASN1_FNCT_DECODE,
                                      &MAsn1OfIndefFunction, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array */
    status = MAsn1DecodeIndefiniteUpdateFlag (encoded, sizeof(encoded), MASN1_DECODE_UPDATE,
                                              pEnv,
                                              TestSeqDataReturn,
                                              (void *) &returnInfo1,
                                              &bytesRead,
                                              &done);
    retval += UNITTEST_STATUS(10, status);
    if (retval > 0)
        goto exit;

    /* Check state */
    retval += UNITTEST_TRUE(11, done);
    if (retval > 0)
        goto exit;

    /* Found the correct OID? */
    status = ASN1_compareOID (CMS_ENVELOPE_DATA, CMS_ENVELOPE_DATA_LEN,
                              pEnv[1].encoding.pEncoding,
                              pEnv[1].encodingLen,
                              NULL, &cmpResult);
    retval += UNITTEST_STATUS(12, status);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(13, cmpResult, 0);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(15, returnInfo1.len, 136);
    if (retval > 0)
        goto exit;

    for (idx = 0; idx < returnInfo1.len; ++idx)
    {
        /* Decode from collected buffer */
        status = MAsn1DecodeIndefiniteUpdateFlag (returnInfo1.pData + idx,
                                                  1,
                                                  MASN1_DECODE_UPDATE,
                                                  pRoot,
                                                  TestSeqDataReturn,
                                                  (void *) &returnInfo2,
                                                  &bytesRead,
                                                  &done);

        retval += UNITTEST_STATUS(20 + (idx*100), status);
        if (retval > 0)
            goto exit;
    }

    /* Check state */
    retval += UNITTEST_TRUE(21, done);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(25, returnInfo2.len, 0);
    if (retval > 0)
        goto exit;

    /* How many sections in the 'raw data'? */
    section = 0;

    status = MAsn1GetOfElementAtIndex (pRoot + idxContent,
                                       section,
                                       &pElement);
    retval += UNITTEST_STATUS(70, status);
    if (retval > 0)
       goto exit;

    while (NULL != pElement)
    {
        ++section;
        status = MAsn1GetOfElementAtIndex (pRoot + idxContent,
                                           section,
                                           &pElement);
        retval += UNITTEST_STATUS(71, status);
        if (retval > 0)
           goto exit;
    }

    retval += UNITTEST_INT(72, section, 2);
    if (retval > 0)
        goto exit;

exit:
    FreeTestDataReturn (&returnInfo1);
    FreeTestDataReturn (&returnInfo2);
    MAsn1FreeElementArray (&pRoot);
    MAsn1FreeElementArray (&pEnv);
    return retval;
}


/*----------------------------------------------------------------------*/

static int
read_indefSetOfExplicit_chunked(ubyte4 chunkSize)
{
    MSTATUS status;
    int retval = 0;

    ubyte4 hint = 100 * chunkSize;

    MAsn1Element* pRoot = NULL;
    MAsn1Element* pSet = NULL;
    ubyte4 bytesRead;
    intBoolean done = 0;
    TestDataReturnInfo returnInfo =
    { NULL, NULL, NULL, 0, 0 };
    intBoolean done2 = 0;
    TestDataReturnInfo returnInfo2 =
    { NULL, NULL, NULL, 0, 0 };
    ubyte4 counter = 0;
    MAsn1Element* pElement = NULL;

    ubyte  *buf = NULL;
    ubyte4 copied = 0;

    /* input data with integer 'payload' */
    ubyte encoded[] =
    {       /* SEQUENCE */
            0x30, 0x80,
            /* OID */
            0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x03,
            /* EXPLICIT */
            0xA0, 0x80,
            /* SEQUENCE */
            0x30, 0x80,
            /* INTEGER */
            0x02, 0x01, 0x00,
            /* SET */
            0x31, 0x42,
            /* SEQUENCE */
            0x30, 0x1F,
            /* OCTET STRING */
            0x04, 0x1D,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04,
            /* SEQUENCE */
            0x30, 0x1F,
            /* OCTET STRING */
            0x04, 0x1D,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x00, 0x01, 0x02, 0x03, 0x04,
            /* EOC */
            0x00, 0x00,
            /* EOC */
            0x00, 0x00,
            /* EOC */
            0x00, 0x00
    };

    /* Sequence with OID and encoded data under explicit tag */
    MAsn1TypeAndCount def[3] =
    {
            { MASN1_TYPE_SEQUENCE, 2 },
            { MASN1_TYPE_OID, 0 },
            { MASN1_TYPE_ENCODED | MASN1_EXPLICIT, 0 },
    };

    MAsn1TypeAndCount def2[4] =
    {
            { MASN1_TYPE_SEQUENCE, 2 },
            { MASN1_TYPE_INTEGER, 0 },
            { MASN1_TYPE_SET_OF, 1 },
            { MASN1_TYPE_ENCODED, 0 },
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 3, MASN1_FNCT_DECODE,
                                      &MAsn1OfIndefFunction, &pRoot);
    retval += UNITTEST_STATUS(hint, status);
    if (retval > 0)
        goto exit;

    /* Create the 'array' set */
    status = MAsn1CreateElementArray (def2, 4, MASN1_FNCT_DECODE,
                                      &MAsn1OfIndefFunction, &pSet);
    retval += UNITTEST_STATUS(hint + 1, status);
    if (retval > 0)
        goto exit;

    /* Decode data using chunks of size 'chunkSize' */
    status = DIGI_MALLOC ((void**) &buf, chunkSize);
    retval += UNITTEST_STATUS(hint + 9, status);
    if (retval > 0)
        goto exit;

    while ((FALSE == done) && (sizeof(encoded) > copied))
    {
        ubyte4 newData;
        ubyte4 bytesRead;

        /* Copy next chunk or the final byte(s) */
        if (chunkSize < (sizeof(encoded) - copied))
        {
            newData = chunkSize;
        }
        else
        {
            newData = sizeof(encoded) - copied;
        }
        DIGI_MEMCPY (buf, encoded + copied, newData);
        copied += newData;

        /* Decode from memory array */
        status = MAsn1DecodeIndefiniteUpdateFlag (buf, newData, MASN1_DECODE_UPDATE,
                                                  pRoot,
                                                  TestSeqDataReturn,
                                                  (void *) &returnInfo,
                                                  &bytesRead,
                                                  &done);
        retval += UNITTEST_STATUS(hint + 10, status);
        if (retval > 0)
            goto exit;
    }

    /* Check state */
    retval += UNITTEST_TRUE(hint + 12, done);
    if (retval > 0)
        goto exit;

    status = MAsn1DecodeIndefiniteUpdateFlag (returnInfo.pData, returnInfo.len, MASN1_DECODE_UPDATE,
                                              pSet,
                                              TestSeqDataReturn,
                                              (void *) &returnInfo2,
                                              &bytesRead,
                                              &done2);
    retval += UNITTEST_STATUS(hint + 11, status);
    if (retval > 0)
        goto exit;

    /* Start loop over elements */
    status = MAsn1GetOfElementAtIndex (pSet + 2,
                                       counter,
                                       &pElement);
    retval += UNITTEST_STATUS(hint + 20, status);
    if (retval > 0)
        goto exit;

    /* Found another? */
    while (NULL != pElement)
    {
        ++counter;
        status = MAsn1GetOfElementAtIndex (pSet + 2,
                                           counter,
                                           &pElement);
        retval += UNITTEST_STATUS(hint + 20 + counter, status);
        if (retval > 0)
            goto exit;
    }
    retval += UNITTEST_INT(hint + 30, counter, 2);

exit:
    /* Cleanup memory */
    DIGI_FREE ((void **) &buf);
    FreeTestDataReturn (&returnInfo);
    FreeTestDataReturn (&returnInfo2);
    MAsn1FreeElementArray (&pSet);
    MAsn1FreeElementArray (&pRoot);
    return retval;
}

int mocdecode_test_MAsn1Element_indefiniteChunkedSetOfExplicit()
{
    int retval = 0;
    ubyte4 cLen = 1;

    while (cLen < 32)
    {
        retval = read_indefSetOfExplicit_chunked(cLen);
        if (retval > 0)
            goto exit;

        cLen += 1;
    }

exit:
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_MAsn1Element_ConstructedTag()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    ubyte4 bytesRead;

    /* input data */
    ubyte encoded[] =
    { 0x30, 0x0A, 0xA0, 0x03, 0x02, 0x01, 0x05, 0xA1, 0x03, 0x01, 0x01, 0xFF };

    /* Test sequence with two tagged '[0]', '[1]' children */
    MAsn1TypeAndCount def[5] =
    {
            { MASN1_TYPE_SEQUENCE, 2 },
            { MASN1_TYPE_SEQUENCE | MASN1_IMPLICIT, 1 },
            { MASN1_TYPE_INTEGER, 0 },
            { MASN1_TYPE_SEQUENCE | MASN1_IMPLICIT | 1, 1 },
            { MASN1_TYPE_BOOLEAN, 0 },
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 5, MASN1_FNCT_DECODE, NULL, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array */
    status = MAsn1Decode (encoded, sizeof(encoded), pRoot, &bytesRead);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Check number of bytes read */
    retval += UNITTEST_INT(99, bytesRead, 12);
    if (retval > 0)
        goto exit;

    /* Check obtained values */
    retval += UNITTEST_INT(100, pRoot[2].valueLen, 1);
    if (retval > 0)
        goto exit;
    retval += UNITTEST_INT(101, pRoot[2].value.pValue[0], 5);

    retval += UNITTEST_INT(110, pRoot[4].valueLen, 1);
    if (retval > 0)
        goto exit;
    retval += UNITTEST_TRUE(111, pRoot[4].value.pValue[0]);

exit:
    /* Cleanup memory */
    MAsn1FreeElementArray (&pRoot);
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_MAsn1Element_DataTag()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    ubyte4 bytesRead;
    sbyte4 cmpResult;

    /* input data */
    ubyte encoded[] =
    { 0x30, 0x16,
            0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x02,
            0x86, 0x0A,
                  0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x65, 0x74, 0x61 };

    /* Test sequence with OID and tagged '[6]' byte array (string) */
    MAsn1TypeAndCount def[3] =
    {
        { MASN1_TYPE_SEQUENCE, 2 },
            { MASN1_TYPE_OID, 0 },
            { MASN1_TYPE_OCTET_STRING | MASN1_IMPLICIT | 6, 0 },
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 3, MASN1_FNCT_DECODE, NULL, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array */
    status = MAsn1Decode (encoded, sizeof(encoded), pRoot, &bytesRead);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Check number of bytes read */
    retval += UNITTEST_INT(99, bytesRead, 24);
    if (retval > 0)
        goto exit;

    /* Found the correct OID? */
    status = ASN1_compareOID (CA_ISSUER, CA_ISSUER_LEN,
                              pRoot[1].encoding.pEncoding,
                              pRoot[1].encodingLen, NULL, &cmpResult);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(15, cmpResult, 0);
    if (retval > 0)
        goto exit;

    /* Check obtained values */
    retval += UNITTEST_INT(100, pRoot[2].valueLen, 10);
    if (retval > 0)
        goto exit;
    retval += UNITTEST_VALIDPTR(101, pRoot[2].value.pValue);
    if (retval > 0)
        goto exit;

    status = DIGI_MEMCMP (pRoot[2].value.pValue, (const ubyte *) "http://eta",
                         10, &cmpResult);
    retval += UNITTEST_STATUS(110, status);
    if (retval > 0)
        goto exit;
    retval += UNITTEST_INT(111, cmpResult, 0);

exit:
    /* Cleanup memory */
    MAsn1FreeElementArray (&pRoot);
    return retval;
}

int mocdecode_test_MAsn1Element_indefOctet()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    ubyte4 bytesRead;
    sbyte4 cmpResult;
    intBoolean done = 0;
    TestDataReturnInfo returnInfo =
    { NULL, NULL, NULL, 0, 0 };

    /* input data with two octet string elements */
    ubyte encoded[] =
    {
      0xA0, 0x80, /* [0] */
        0x24, 0x80, /* OCTET/INDEF */
           0x04, 0x10, /* OCTET_STRING (1) = 16 */
                 0x4C, 0x6F, 0x72, 0x65, 0x6D, 0x20, 0x69, 0x70,
                 0x73, 0x75, 0x6D, 0x20, 0x64, 0x6F, 0x6C, 0x6F,
           0x04, 0x08, /* OCTET_STRING (2) = 8 */
                0x72, 0x20, 0x73, 0x69, 0x74, 0x20, 0x61, 0x6D,
        0x00, 0x00, /* EOC */
      0x00, 0x00 /* EOC */
    };

    /* input data taken from bad CMS case */
    ubyte encoded2[] =
    {
      0xa0, 0x80,  /* [0] */
        0x24, 0x80,  /* OCTET/INDEF */
          0x04, 0x82, 0x08, 0x00, /* OCTET_STRING (1) = 2048 */
                0x50, 0x4b,
                0x03, 0x04, 0x14, 0x00, 0x08, 0x08, 0x08, 0x00, 0x04, 0x83, 0x2a, 0x4d,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x0f, 0x00, 0x00, 0x00, 0x64, 0x61, 0x74, 0x61, 0x2f, 0x75, 0x70, 0x64,
                0x61, 0x74, 0x65, 0x32, 0x2e, 0x73, 0x68, 0xa5, 0x92, 0x3d, 0x0e, 0xc3,
                0x20, 0x0c, 0x85, 0xf7, 0x9c, 0xc2, 0x0a, 0x43, 0x52, 0xa9, 0x12, 0x17,
                0x42, 0xf2, 0x50, 0x55, 0xea, 0xd6, 0x0b, 0xf8, 0xf0, 0xc5, 0x18, 0x8c,
                0x0d, 0x64, 0x88, 0x9a, 0x2a, 0x71, 0xfc, 0xf3, 0x3e, 0x5e, 0x21, 0xdb,
                0xfb, 0xf5, 0xf9, 0xc2, 0xbe, 0x6f, 0x12, 0x01, 0x10, 0xe5, 0xbe, 0x75,
                0xa1, 0x53, 0x38, 0x35, 0x82, 0xb2, 0x09, 0x20, 0x45, 0xe0, 0xa0, 0x82,
                0x1a, 0xf3, 0x13, 0xcb, 0xac, 0x96, 0x15, 0x42, 0xf9, 0x95, 0xb4, 0x45,
                0x9c, 0x37, 0x5d, 0x4e, 0x0c, 0x9b, 0x52, 0x24, 0x66, 0xc7, 0x3c, 0x9b,
                0xa0, 0x44, 0x94, 0xf4, 0xe0, 0x2e, 0x1c, 0x5a, 0x3e, 0xc4, 0x82, 0xe0,
                0x40, 0x5b, 0xa4, 0x82, 0x9c, 0x0d, 0x6c, 0x19, 0x25, 0x38, 0xf1, 0x51,
                0x63, 0x59, 0xff, 0x44, 0x02, 0xfb, 0x93, 0xbc, 0x4c, 0x59, 0x15, 0x55,
                0xdf, 0xfc, 0x3f, 0x30, 0x7a, 0x36, 0x2f, 0x59, 0x1e, 0x09, 0xb9, 0x27,
                0x51, 0xd2, 0x27, 0xd3, 0xea, 0xdd, 0xf2, 0xba, 0x27, 0x28, 0x65, 0x6c,
                0x2d, 0x6a, 0xba, 0x5c, 0x68, 0x6c, 0x5d, 0x23, 0x14, 0x51, 0xb8, 0x79,
                0xa6, 0xa1, 0xe9, 0xf8, 0x72, 0x9d, 0x19, 0xdc, 0x66, 0xfa, 0xac, 0x84,
                0x9a, 0x07, 0xc7, 0xa8, 0xe0, 0x85, 0xab, 0x05, 0x78, 0x88, 0xfa, 0x6e,
                0x19, 0xd0, 0x7d, 0xda, 0x55, 0x6e, 0x81, 0x3b, 0xce, 0x1a, 0xff, 0x67,
                0x2b, 0x6c, 0x3e, 0xd0, 0x47, 0xc7, 0x8b, 0xa3, 0xb9, 0x70, 0x0c, 0xd7,
                0x8e, 0x9d, 0x3c, 0xac, 0x8a, 0x1e, 0xec, 0x9d, 0xc2, 0xec, 0xdc, 0x6e,
                0xc5, 0x74, 0x78, 0x61, 0xda, 0x8b, 0xfe, 0xd9, 0xfd, 0x00, 0x50, 0x4b,
                0x07, 0x08, 0x1f, 0x5b, 0x9b, 0xaf, 0xe7, 0x00, 0x00, 0x00, 0x54, 0x04,
                0x00, 0x00, 0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x08, 0x08, 0x08, 0x00,
                0x04, 0x83, 0x2a, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x64, 0x61, 0x74, 0x61,
                0x2f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x30, 0x2e, 0x73, 0x68, 0x95,
                0x50, 0x4b, 0x0a, 0x43, 0x21, 0x10, 0xdb, 0x7b, 0x8a, 0xe0, 0xc6, 0x57,
                0x28, 0x78, 0x21, 0x21, 0x8b, 0x52, 0xe8, 0xae, 0x17, 0x98, 0xc3, 0xbf,
                0xf9, 0xe8, 0xa0, 0xdd, 0xf5, 0x89, 0xc6, 0x4c, 0x26, 0xd1, 0x67, 0x79,
                0xbf, 0x3e, 0x5f, 0xd4, 0x5a, 0x02, 0x01, 0x32, 0xe6, 0x5f, 0x1f, 0x0f,
                0xc7, 0xe1, 0x26, 0x32, 0x5b, 0x80, 0xd1, 0x61, 0x90, 0x86, 0x89, 0xba,
                0xd2, 0x7b, 0xb3, 0x9c, 0x21, 0xa2, 0x5b, 0x49, 0x49, 0x8c, 0x2f, 0x9f,
                0x92, 0x2d, 0x5b, 0x46, 0x17, 0xcb, 0xee, 0xda, 0x3b, 0xe0, 0xc8, 0xa0,
                0xcd, 0x54, 0xb4, 0x2c, 0xb7, 0xb8, 0x42, 0xc4, 0x21, 0x25, 0x49, 0x83,
                0xb2, 0x9f, 0xec, 0x68, 0x15, 0x5c, 0x7c, 0x4c, 0xf4, 0xf3, 0x2f, 0x0a,
                0xf6, 0x11, 0xdc, 0xbb, 0x76, 0x97, 0xcc, 0x7b, 0xdb, 0x7f, 0xb0, 0x9f,
                0xd9, 0x76, 0xa4, 0x2f, 0x83, 0xa6, 0x05, 0x06, 0x7d, 0x5a, 0xda, 0x9c,
                0x8b, 0xcf, 0x37, 0x61, 0x94, 0xb9, 0x24, 0x59, 0x3e, 0x2d, 0xac, 0xec,
                0x5a, 0xca, 0x0d, 0x50, 0x4b, 0x07, 0x08, 0xad, 0x35, 0x22, 0x41, 0x94,
                0x00, 0x00, 0x00, 0xde, 0x01, 0x00, 0x00, 0x50, 0x4b, 0x03, 0x04, 0x14,
                0x00, 0x08, 0x08, 0x08, 0x00, 0x04, 0x83, 0x2a, 0x4d, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00,
                0x00, 0x64, 0x61, 0x74, 0x61, 0x2f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65,
                0x5f, 0x67, 0x77, 0x2e, 0x73, 0x68, 0x9d, 0x52, 0x49, 0x0a, 0xc3, 0x30,
                0x0c, 0xbc, 0xe7, 0x15, 0x22, 0x97, 0xa4, 0x10, 0xf0, 0x6f, 0x7a, 0x32,
                0xcc, 0xa1, 0x14, 0x7a, 0xeb, 0x07, 0xf4, 0xf8, 0x6a, 0xb1, 0x15, 0xb9,
                0x50, 0x92, 0xd4, 0x8a, 0xad, 0x68, 0x1b, 0x39, 0x9a, 0x4c, 0xcf, 0xc7,
                0xeb, 0x4d, 0xf3, 0x3c, 0xb9, 0x26, 0x02, 0x7c, 0x5f, 0x5a, 0x18, 0x2a,
                0x86, 0x6a, 0x50, 0x60, 0x33, 0x51, 0x2d, 0xa4, 0x2a, 0x0a, 0x9a, 0x96,
                0x13, 0x96, 0x1b, 0xee, 0x00, 0x61, 0x79, 0xe5, 0x08, 0xb1, 0xda, 0xbd,
                0x4e, 0x8c, 0x84, 0xcd, 0xb5, 0xb0, 0x62, 0x17, 0xc9, 0xad, 0x64, 0x1a,
                0x6e, 0x2e, 0x1a, 0xa5, 0x25, 0xdc, 0x8b, 0x5f, 0xc1, 0xe1, 0x28, 0x42,
                0x1c, 0x05, 0x62, 0x7d, 0x61, 0x7b, 0x2a, 0xd3, 0x8a, 0x5b, 0xd3, 0xd6,
                0x7f, 0x05, 0x53, 0x16, 0xb7, 0x2d, 0x2b, 0x57, 0x71, 0xbb, 0xb7, 0x7e,
                0x07, 0xca, 0x88, 0xad, 0x2d, 0xed, 0xa8, 0xd0, 0x98, 0x6b, 0x37, 0x37,
                0x45, 0x6b, 0xbb, 0xdb, 0x6d, 0x26, 0x70, 0x37, 0x7a, 0x88, 0x7b, 0x9d,
                0x38, 0x3a, 0xf6, 0xce, 0xa9, 0x8e, 0xeb, 0x27, 0x41, 0x7f, 0xad, 0x1d,
                0x5b, 0xc7, 0x0c, 0x0e, 0xce, 0x06, 0x82, 0x7a, 0x53, 0xd3, 0xc1, 0xf1,
                0x51, 0xff, 0x71, 0xee, 0xa0, 0xc4, 0x61, 0x22, 0x48, 0xa5, 0xc8, 0x23,
                0xb2, 0xc7, 0x5d, 0x4e, 0x62, 0x23, 0x73, 0x36, 0x10, 0x24, 0xd0, 0x77,
                0x92, 0xa7, 0x0c, 0x1c, 0xe3, 0x2c, 0xb6, 0x51, 0x91, 0x39, 0xcb, 0x04,
                0xa9, 0x2e, 0xd5, 0x98, 0xce, 0xf1, 0xed, 0x2c, 0xf6, 0xd5, 0xc5, 0xed,
                0xb7, 0x3a, 0xc6, 0x9e, 0xa7, 0x0f, 0x50, 0x4b, 0x07, 0x08, 0xda, 0x34,
                0xb5, 0x77, 0xe4, 0x00, 0x00, 0x00, 0x0d, 0x04, 0x00, 0x00, 0x50, 0x4b,
                0x03, 0x04, 0x14, 0x00, 0x08, 0x08, 0x08, 0x00, 0x04, 0x83, 0x2a, 0x4d,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x0f, 0x00, 0x00, 0x00, 0x64, 0x61, 0x74, 0x61, 0x2f, 0x75, 0x70, 0x64,
                0x61, 0x74, 0x65, 0x31, 0x2e, 0x73, 0x68, 0xa5, 0x51, 0xcb, 0x0a, 0x03,
                0x21, 0x0c, 0xbc, 0xfb, 0x15, 0xc3, 0x7a, 0xd8, 0x2d, 0x14, 0xfc, 0x21,
                0x21, 0x87, 0x52, 0xe8, 0xad, 0x3f, 0x90, 0x8f, 0xaf, 0x31, 0x1a, 0x1f,
                0xdb, 0x82, 0x4b, 0x5d, 0x34, 0x4e, 0xe2, 0x4c, 0x66, 0xd5, 0x3d, 0x1f,
                0xaf, 0x37, 0xb6, 0xcd, 0x69, 0x04, 0x88, 0x74, 0x5e, 0x1a, 0x34, 0x30,
                0x06, 0x36, 0xc1, 0xb4, 0x19, 0x88, 0x01, 0x12, 0x8c, 0x50, 0x62, 0x5a,
                0x29, 0x9f, 0xb5, 0xb4, 0x89, 0x70, 0xda, 0xb2, 0x95, 0x58, 0x70, 0xe5,
                0x25, 0xd0, 0x69, 0x73, 0x0c, 0x2c, 0xda, 0x21, 0x9d, 0x8d, 0xc8, 0x91,
                0x14, 0xee, 0x52, 0xc5, 0x6e, 0xe9, 0x5d, 0x2d, 0xa8, 0x1c, 0xac, 0xc4,
                0x46, 0x48, 0x68, 0xd2, 0xd6, 0xa3, 0x8c, 0x83, 0x6e, 0x25, 0xe6, 0xfe,
                0x07, 0x31, 0xfa, 0x4f, 0x71, 0x3e, 0xd5, 0xb3, 0xb8, 0xf8, 0x96, 0xff,
                0xa0, 0x30, 0x6a, 0x4b, 0xcb, 0xbc, 0x44, 0x92, 0x9a, 0x46, 0x85, 0x77,
                0x51, 0x2b, 0xb3, 0xe2, 0x72, 0x27, 0xa4, 0x69, 0xaa, 0x25, 0xae, 0xbc,
                0x94, 0xa8, 0xda, 0xd6, 0xc3, 0x67, 0x92, 0xbf, 0xf8, 0xa6, 0xbe, 0x32,
                0x4e, 0xc4, 0xb3, 0xb0, 0x97, 0x81, 0x16, 0x65, 0x87, 0x86, 0x7d, 0xcb,
                0x77, 0xc2, 0x7e, 0x45, 0x78, 0x8a, 0xb6, 0x6f, 0x19, 0x93, 0xad, 0x5d,
                0xfc, 0x92, 0xe3, 0x5f, 0x0d, 0xd0, 0x1b, 0xff, 0xe7, 0x2a, 0x7a, 0x3c,
                0xa9, 0xcf, 0x8e, 0xd7, 0x84, 0xcd, 0xcc, 0x77, 0xc7, 0x03, 0x7d, 0xc1,
                0xf1, 0xe8, 0x14, 0x67, 0xe7, 0xfd, 0x55, 0xcc, 0x8f, 0x37, 0xde, 0xcf,
                0x20, 0xbc, 0xb9, 0x0f, 0x50, 0x4b, 0x07, 0x08, 0x75, 0x30, 0x2f, 0x48,
                0xe1, 0x00, 0x00, 0x00, 0x54, 0x04, 0x00, 0x00, 0x50, 0x4b, 0x03, 0x04,
                0x14, 0x00, 0x08, 0x08, 0x08, 0x00, 0x04, 0x83, 0x2a, 0x4d, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00,
                0x00, 0x00, 0x64, 0x61, 0x74, 0x61, 0x2f, 0x75, 0x70, 0x64, 0x61, 0x74,
                0x65, 0x5f, 0x65, 0x6e, 0x64, 0x70, 0x74, 0x2e, 0x73, 0x68, 0x95, 0x92,
                0xdd, 0x0a, 0xc3, 0x20, 0x0c, 0x85, 0xef, 0xfb, 0x14, 0xa1, 0x37, 0x6d,
                0x61, 0xcc, 0x17, 0x12, 0xce, 0x60, 0x0c, 0x76, 0xb7, 0x17, 0xc8, 0xc3,
                0xcf, 0x18, 0x8d, 0xd1, 0x3a, 0xe8, 0x1c, 0x6d, 0x96, 0xbf, 0x63, 0xf4,
                0xeb, 0xf2, 0x7a, 0xbe, 0x3f, 0xb4, 0xae, 0x8b, 0x5a, 0x22, 0x40, 0x9f,
                0xbf, 0x16, 0xba, 0x8e, 0xae, 0x1b, 0x64, 0xda, 0x4c, 0x14, 0x03, 0x89,
                0xb1, 0x86, 0x62, 0xd3, 0x1b, 0xb9, 0xd6, 0xc2, 0x26, 0xc2, 0xe9, 0x2f,
                0x5b, 0x8a, 0xc5, 0xaf, 0x7d, 0xc9, 0x71, 0xda, 0x1c, 0x03, 0x8b, 0x76,
                0x48, 0xb5, 0x91, 0xb2, 0x85, 0xba, 0x9b, 0x64, 0x69, 0xb3, 0xf0, 0xa6,
                0x23, 0xa8, 0x1c, 0x59, 0x8a, 0xad, 0x21, 0x79, 0x83, 0xb6, 0x96, 0x32,
                0xed, 0x38, 0x8a, 0xcd, 0xfb, 0xef, 0x60, 0xf2, 0x3f, 0xf5, 0x73, 0x95,
                0xef, 0xe2, 0x32, 0xb7, 0x9c, 0x03, 0xa1, 0xd7, 0x96, 0x2d, 0xf3, 0x2b,
                0x42, 0x72, 0x6a, 0xd5, 0xbd, 0x89, 0x5a, 0x79, 0xaa, 0x5f, 0xee, 0x04,
                0x1a, 0x46, 0x4d, 0x71, 0xed, 0x4b, 0x81, 0xaa, 0xed, 0x99, 0x02, 0x27,
                0xa6, 0x33, 0xc6, 0x13, 0x8a, 0x9e, 0x1e, 0x74, 0x34, 0xb7, 0xf2, 0x21,
                0x87, 0x95, 0x4f, 0x3f, 0xe4, 0xfd, 0x5d, 0x56, 0xc6, 0x0d, 0x76, 0xae,
                0x72, 0x3e, 0xea, 0xfe, 0x03, 0xf5, 0x7e, 0x16, 0xa6, 0xc6, 0x4e, 0xa8,
                0xc5, 0xc7, 0xc0, 0x59, 0xa1, 0xb6, 0x58, 0x01, 0xdc, 0xcf, 0x52, 0x3e,
                0xa4, 0x0e, 0xa0, 0x24, 0x2a, 0xe7, 0xa3, 0x03, 0xcc, 0x93, 0x59, 0xf4,
                0x76, 0xcf, 0xa8, 0x98, 0xee, 0x8d, 0x68, 0x20, 0xcb, 0x3b, 0x66, 0x4d,
                0xe5, 0xe7, 0x9a, 0xdd, 0xf0, 0xb8, 0x2e, 0xa8, 0xe0, 0xba, 0xca, 0xba,
                0x7c, 0x01, 0x50, 0x4b, 0x07, 0x08, 0x29, 0xe7, 0xc2, 0x03, 0xf4, 0x00,
                0x00, 0x00, 0x15, 0x04, 0x00, 0x00, 0x50, 0x4b, 0x03, 0x04, 0x14, 0x00,
                0x08, 0x08, 0x08, 0x00, 0x04, 0x83, 0x2a, 0x4d, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00,
                0x64, 0x61, 0x74, 0x61, 0x2f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x33,
                0x2e, 0x73, 0x68, 0xa5, 0x51, 0x41, 0x0e, 0xc3, 0x20, 0x0c, 0xbb, 0xf7,
                0x15, 0x56, 0x39, 0xb4, 0x93, 0x26, 0xf1, 0x21, 0xa4, 0x1c, 0xa6, 0x49,
                0xbb, 0xed, 0x03, 0x79, 0xfc, 0x08, 0x81, 0x34, 0xd0, 0x6e, 0x5a, 0x37,
                0x2a, 0x08, 0x26, 0xb1, 0x71, 0xc3, 0x74, 0xbf, 0x3d, 0x9e, 0x98, 0xe7,
                0x49, 0x23, 0x40, 0xa4, 0xf3, 0xd4, 0xa0, 0x8e, 0xd1, 0xb1, 0x09, 0xa6,
                0xcd, 0x40, 0x8a, 0x90, 0x60, 0x84, 0x1a, 0xf3, 0x4a, 0xa5, 0xd6, 0x8e,
                0x4d, 0x84, 0xf3, 0x96, 0x2d, 0xc5, 0x82, 0x1b, 0x2f, 0x03, 0xa7, 0xcd,
                0x29, 0xb2, 0x68, 0xc7, 0x5c, 0x9b, 0x50, 0x22, 0x29, 0x5c, 0x24, 0x8b,
                0xc5, 0x8e, 0x17, 0xb5, 0xa0, 0x72, 0xb0, 0x14, 0x1b, 0x21, 0xa3, 0x41,
                0x5b, 0x4b, 0x19, 0x2b, 0x5d, 0x6a, 0x2c, 0xf7, 0xaf, 0xc4, 0xf0, 0x9f,
                0xe2, 0x52, 0xe5, 0x59, 0x5c, 0x7d, 0xcb, 0x7f, 0x50, 0xec, 0xb5, 0xe5,
                0xca, 0xb2, 0x24, 0x92, 0x9c, 0x46, 0x85, 0x57, 0x51, 0xab, 0xb3, 0xe1,
                0xda, 0x13, 0xd2, 0x63, 0x6a, 0x29, 0x6e, 0xbc, 0x7c, 0xd0, 0xb4, 0xed,
                0x8e, 0x50, 0x48, 0xe1, 0xe4, 0x9b, 0x86, 0xc6, 0x93, 0xd1, 0x65, 0xf6,
                0xc2, 0xad, 0x66, 0xab, 0xd5, 0x50, 0x71, 0xe8, 0x34, 0xaa, 0xf0, 0x81,
                0xab, 0x03, 0xe1, 0x21, 0xda, 0xde, 0x6b, 0x60, 0xf3, 0xe9, 0x6f, 0x39,
                0x25, 0xbc, 0xc9, 0x79, 0xe3, 0xff, 0xb4, 0xc2, 0xe3, 0x41, 0xfd, 0x77,
                0xc7, 0x78, 0xef, 0xb8, 0xf3, 0xf5, 0x45, 0x8f, 0x7b, 0xa7, 0xd8, 0x3b,
                0xf7, 0xad, 0x18, 0x1f, 0xef, 0x43, 0x2b, 0xe6, 0xe9, 0x05, 0x50, 0x4b,
                0x07, 0x08, 0x82, 0x8d, 0x45, 0x57, 0xdf, 0x00, 0x00, 0x00, 0x54, 0x04,
                0x00, 0x00, 0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x08, 0x08, 0x08, 0x00,
                0x04, 0x83, 0x2a, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x64, 0x61, 0x74, 0x61,
                0x2f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x34, 0x2e, 0x73, 0x68, 0x9d,
                0x51, 0x41, 0x0e, 0xc3, 0x20, 0x0c, 0xbb, 0xf7, 0x15, 0x56, 0x73, 0x68,
                0x27, 0x4d, 0xe2, 0x43, 0x48, 0x39, 0x4c, 0x93, 0x76, 0xdb, 0x07, 0xf2,
                0xf8, 0x11, 0x02, 0x29, 0xd0, 0xae, 0x53, 0x47, 0x05, 0xc1, 0x09, 0x36,
                0x6e, 0x98, 0x9e, 0x8f, 0xd7, 0x1b, 0xf3, 0x3c, 0x59, 0x04, 0x98, 0x6d,
                0x5e, 0x1a, 0xdc, 0x31, 0x3a, 0x36, 0xc3, 0xb5, 0x05, 0x88, 0x01, 0x1a,
                0x9c, 0x50, 0x62, 0x5a, 0x39, 0x9f, 0xf5, 0xb4, 0x8b, 0x48, 0xda, 0x8a,
                0x97, 0x44, 0x71, 0xe5, 0x25, 0xd0, 0x68, 0x4b, 0x0c, 0xa2, 0xda, 0x21,
                0x9d, 0x8d, 0xc8, 0x91, 0x0d, 0x2e, 0x5a, 0xc5, 0xe2, 0xe9, 0xc5, 0x2c,
                0x98, 0x1c, 0xbc, 0x24, 0x4e, 0x48, 0x68, 0xd0, 0xb6, 0xa3, 0x82, 0x95,
                0x6f, 0x25, 0xe6, 0xfb, 0x57, 0x16, 0xb4, 0x9f, 0xe1, 0x7c, 0xaa, 0x65,
                0x49, 0xf1, 0xad, 0xff, 0xc1, 0xa1, 0xd7, 0xd6, 0x2b, 0xf3, 0x12, 0x59,
                0x6b, 0x16, 0x0d, 0xde, 0x55, 0xad, 0xcc, 0x8a, 0x4b, 0x4f, 0xd8, 0xd2,
                0x5c, 0x4b, 0x52, 0x79, 0x29, 0x51, 0xb5, 0xfd, 0x0e, 0xca, 0x24, 0xba,
                0xf8, 0xa6, 0x64, 0x8c, 0x03, 0xda, 0x5e, 0x98, 0x74, 0x60, 0x8b, 0xba,
                0xc3, 0x86, 0x69, 0xcb, 0x0f, 0xc2, 0xf4, 0x4b, 0x78, 0x88, 0xbe, 0xdf,
                0xd3, 0xa9, 0xde, 0xf2, 0x97, 0xf0, 0x60, 0xa9, 0x33, 0x7c, 0xcd, 0x71,
                0x6d, 0x45, 0x8b, 0x8f, 0xe9, 0x9b, 0xe3, 0xbe, 0x41, 0x27, 0x8e, 0xf1,
                0xdd, 0x71, 0xe7, 0x8b, 0xd0, 0xba, 0x3f, 0x14, 0xee, 0x9d, 0x62, 0xef,
                0xbc, 0x6d, 0xc5, 0xf8, 0x78, 0x27, 0xc2, 0xf3, 0xf4, 0x01, 0x50, 0x4b,
                0x07, 0x08, 0x7f, 0x75, 0x1e, 0x1b, 0xe3, 0x00, 0x00, 0x00, 0x54, 0x04,
                0x00, 0x00, 0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x08, 0x08, 0x08, 0x00,
                0x04, 0x83, 0x2a, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x6d, 0x65, 0x74, 0x61,
                0x64, 0x61, 0x74, 0x61, 0x2f, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c,
                0x65, 0x72, 0x2e, 0x73, 0x68, 0xcd, 0x57, 0x6d, 0x6f, 0xda, 0x48, 0x10,
                0xfe, 0x1c, 0xff, 0x8a, 0x89, 0x13, 0xa9, 0xc9, 0x49, 0x98, 0x0b, 0x69,
                0x7b, 0x52, 0x2e, 0x54, 0x47, 0xc1, 0x49, 0x91, 0x08, 0x58, 0xc6, 0x51,
                0x3f, 0x54, 0x95, 0xb3, 0xb1, 0x07,
          0x04, 0x82, 0x08, 0x00,  /* OCTET_STRING (2) = 2048 */
                0x58, 0xd5,
                0xd8, 0xd6, 0xee, 0x3a, 0x2f, 0x8a, 0xf8, 0xef, 0x37, 0x6b, 0x1b, 0xc7,
                0xbc, 0x5d, 0xef, 0x7a, 0xf4, 0x74, 0x2b, 0x44, 0xb0, 0x67, 0xe6, 0xd9,
                0x9d, 0xd9, 0x67, 0x5e, 0x72, 0x74, 0xd8, 0xcc, 0xa4, 0x68, 0xde, 0xf3,
                0xb8, 0x89, 0xf1, 0x03, 0xdc, 0x33, 0x39, 0x33, 0x8c, 0xa3, 0x7d, 0x2f,
                0xe3, 0x08, 0xc6, 0x81, 0xe0, 0xa9, 0x82, 0x21, 0x9b, 0xe3, 0x05, 0xf0,
                0x58, 0x2a, 0x16, 0x45, 0x28, 0x2c, 0x39, 0x3b, 0x28, 0x96, 0xd6, 0xe9,
                0xa1, 0xcc, 0xb5, 0x78, 0x12, 0x5f, 0x80, 0x87, 0x52, 0x81, 0x59, 0xd7,
                0x34, 0xa1, 0x10, 0xc3, 0x24, 0x11, 0xa0, 0x48, 0xcc, 0xe3, 0x29, 0xdc,
                0xa6, 0x21, 0x53, 0x08, 0xdd, 0x88, 0x63, 0xac, 0x0a, 0x98, 0x8e, 0x98,
                0x4a, 0xb2, 0x9f, 0x71, 0xb9, 0x34, 0x60, 0x41, 0x80, 0xa9, 0x92, 0xa0,
                0x66, 0x02, 0x11, 0x98, 0x98, 0x66, 0x73, 0xd2, 0x26, 0xa5, 0x93, 0xb3,
                0x53, 0x48, 0x23, 0xa6, 0x08, 0x71, 0x7e, 0x01, 0x29, 0x7f, 0xff, 0x16,
                0xd6, 0x97, 0x46, 0x2c, 0xd6, 0x49, 0xeb, 0x14, 0xb2, 0x7c, 0x3b, 0x85,
                0x4f, 0x6a, 0xc2, 0x23, 0x8c, 0xc9, 0x1b, 0x38, 0x39, 0x3f, 0x05, 0x45,
                0x98, 0xa8, 0xea, 0xaf, 0x0f, 0x36, 0x80, 0xf2, 0xa5, 0x0f, 0xb8, 0xff,
                0xe8, 0x1e, 0x15, 0xde, 0x32, 0x29, 0xc9, 0x31, 0xed, 0x26, 0x53, 0xe0,
                0xb8, 0x23, 0xc7, 0xef, 0x0e, 0xfa, 0xf6, 0xd0, 0x03, 0x92, 0xf1, 0x98,
                0x5e, 0x23, 0xe0, 0x13, 0x06, 0x99, 0x0e, 0x30, 0xa4, 0x4c, 0xcd, 0x20,
                0x99, 0xe4, 0x6f, 0x8b, 0x30, 0x69, 0x9c, 0xb1, 0xdb, 0xd5, 0xda, 0xfa,
                0x65, 0x94, 0x04, 0x2c, 0xd7, 0x2c, 0x95, 0xc8, 0x71, 0x06, 0xa9, 0x48,
                0x1e, 0x78, 0x88, 0x61, 0x81, 0x47, 0x9a, 0x29, 0x0b, 0xbe, 0xb1, 0x29,
                0x5a, 0x86, 0x41, 0xa6, 0x6d, 0xd3, 0x32, 0x8d, 0x5e, 0xc7, 0xb3, 0xdb,
                0x77, 0x3a, 0x4c, 0x77, 0x86, 0xc1, 0x27, 0x30, 0x23, 0x4e, 0x81, 0x4a,
                0xb3, 0xc0, 0x4f, 0x03, 0x68, 0x7d, 0x68, 0x86, 0xf8, 0xd0, 0x8c, 0xb3,
                0x28, 0xfa, 0x5d, 0xa3, 0xc6, 0x06, 0x05, 0xa5, 0x76, 0xd4, 0x76, 0xa9,
                0x68, 0x60, 0x24, 0x51, 0xcb, 0x96, 0x00, 0xd9, 0xdc, 0xa7, 0xbd, 0x53,
                0x14, 0xea, 0xd9, 0x0f, 0xf2, 0xcb, 0xde, 0x8e, 0x95, 0xaf, 0x3a, 0xe0,
                0xa6, 0xa1, 0x56, 0xcb, 0xe1, 0x0f, 0x30, 0x98, 0x25, 0x60, 0x9a, 0x95,
                0x5d, 0xf1, 0xdc, 0x1f, 0x8e, 0xbd, 0xce, 0x60, 0x60, 0xbb, 0x60, 0xbb,
                0xee, 0xc8, 0x3d, 0x04, 0xcf, 0xb9, 0xed, 0x82, 0x53, 0x82, 0x94, 0x54,
                0xd3, 0x51, 0x8a, 0x13, 0xcd, 0xc5, 0x2c, 0x0e, 0x97, 0xd1, 0x75, 0x3a,
                0xde, 0x27, 0x0b, 0xec, 0xa7, 0x14, 0x03, 0x92, 0x30, 0x1e, 0x65, 0x02,
                0xe5, 0xe1, 0x21, 0x98, 0x9b, 0x5b, 0xd5, 0x8f, 0x48, 0xdb, 0xac, 0x9f,
                0xd1, 0x1f, 0x8e, 0x3c, 0xff, 0x6a, 0x74, 0x3b, 0xec, 0x81, 0x36, 0x99,
                0x70, 0x83, 0x3e, 0x86, 0x63, 0xbb, 0xe3, 0xfe, 0xd8, 0x6b, 0xdf, 0x1d,
                0xbf, 0xd4, 0xec, 0x17, 0xd0, 0x68, 0x10, 0xfb, 0x40, 0x24, 0x56, 0x90,
                0xc4, 0x13, 0x3e, 0xb5, 0x08, 0x49, 0x72, 0xa9, 0x42, 0x2e, 0xe8, 0x0a,
                0xc6, 0x5d, 0xb7, 0xef, 0x78, 0x7e, 0xaf, 0xef, 0xb6, 0xcd, 0xe3, 0x97,
                0x4f, 0xa3, 0x1b, 0x7b, 0x61, 0xfe, 0x60, 0x8e, 0x6b, 0x86, 0xb8, 0xc8,
                0x42, 0x08, 0x92, 0xf9, 0x9c, 0x91, 0xdf, 0x11, 0x8f, 0x91, 0x9c, 0x57,
                0x09, 0xb0, 0x98, 0xf2, 0x4a, 0xb0, 0x67, 0x0b, 0x2a, 0x3a, 0xce, 0x48,
                0x23, 0x22, 0x3a, 0xde, 0x27, 0xc4, 0xb4, 0x80, 0x49, 0xa4, 0x84, 0xd3,
                0x42, 0xbd, 0xea, 0x79, 0x0d, 0x26, 0x65, 0xcf, 0x99, 0x4e, 0xcb, 0x96,
                0xfe, 0x3a, 0x37, 0xb7, 0x6b, 0xc1, 0xaa, 0x96, 0xd6, 0xf9, 0x4c, 0xac,
                0x4c, 0xe2, 0x37, 0x0a, 0x62, 0x24, 0x4a, 0xe6, 0x7c, 0x94, 0xea, 0x39,
                0x42, 0xcd, 0x9a, 0x47, 0x9d, 0xe8, 0x48, 0xfb, 0x46, 0x91, 0xae, 0x13,
                0x5a, 0x9d, 0xd1, 0x85, 0xcd, 0x50, 0x2c, 0xab, 0xc2, 0x3d, 0x46, 0xc9,
                0x23, 0x64, 0x12, 0x1e, 0x9b, 0x70, 0xfc, 0x07, 0x31, 0x59, 0x50, 0xde,
                0x2a, 0x0a, 0x9d, 0xf5, 0x83, 0xd1, 0x11, 0x3a, 0x34, 0x0d, 0x01, 0x0d,
                0xa6, 0x4f, 0xe8, 0xe7, 0xf1, 0x80, 0xcb, 0xcb, 0x4b, 0x42, 0xaf, 0x02,
                0xae, 0xcf, 0x71, 0x4d, 0x97, 0x55, 0xb9, 0x06, 0x92, 0xd8, 0xc2, 0x27,
                0x3c, 0x80, 0x8e, 0x7b, 0x2d, 0x2b, 0x35, 0xef, 0xda, 0xf3, 0x9d, 0x41,
                0xc7, 0xbb, 0x1a, 0xb9, 0x37, 0xed, 0xe3, 0x97, 0x0a, 0xef, 0xcb, 0xaf,
                0x5f, 0x17, 0x3a, 0xd5, 0xfc, 0xab, 0xfe, 0xc0, 0x1e, 0x76, 0x6e, 0xec,
                0x15, 0xe1, 0x19, 0x09, 0xb5, 0xe5, 0x56, 0x61, 0x8b, 0x84, 0xb7, 0x8e,
                0x4e, 0x4f, 0xdf, 0xa3, 0xbd, 0xec, 0x42, 0x8d, 0x54, 0x5e, 0x19, 0xb2,
                0x68, 0x1e, 0xbf, 0xd4, 0xed, 0x17, 0x86, 0xb1, 0x9e, 0x13, 0xbf, 0xfc,
                0x9b, 0x65, 0x6e, 0x81, 0x5b, 0x96, 0xf0, 0x7e, 0x15, 0x11, 0x4a, 0x78,
                0xba, 0x47, 0x26, 0x14, 0x86, 0x16, 0xe5, 0x1d, 0xd2, 0xcd, 0xd0, 0x15,
                0x5a, 0x96, 0xb5, 0x5a, 0x4b, 0x77, 0xc0, 0x75, 0x89, 0x77, 0x53, 0x7d,
                0xe5, 0x45, 0x11, 0xa3, 0x9f, 0xba, 0x6a, 0xcd, 0xe9, 0xc2, 0xa9, 0x6d,
                0xdc, 0x53, 0xb9, 0x9a, 0x8a, 0x3c, 0x67, 0xd7, 0xd7, 0x76, 0xb8, 0xbd,
                0x3a, 0xdb, 0xd6, 0xeb, 0xc3, 0x6b, 0x3d, 0x59, 0xd6, 0x92, 0x0b, 0x58,
                0x4d, 0xe8, 0x9d, 0x96, 0x6a, 0xaa, 0xaa, 0x7e, 0x95, 0x1f, 0x9a, 0x2c,
                0xeb, 0x4c, 0xd9, 0x69, 0x58, 0xf4, 0x2d, 0xc8, 0x1b, 0xd6, 0xd2, 0xb0,
                0xce, 0xa2, 0xbf, 0xdc, 0x51, 0xf7, 0xb4, 0xca, 0xb4, 0xdc, 0xf1, 0xbb,
                0x86, 0x13, 0x2a, 0xcb, 0x2b, 0x96, 0x64, 0xb8, 0xc9, 0xbe, 0xa5, 0xb9,
                0x99, 0xb7, 0x8a, 0x2f, 0xab, 0xde, 0x10, 0x14, 0x98, 0x4e, 0xff, 0xfd,
                0x5b, 0x13, 0xbe, 0x96, 0x15, 0xfe, 0x60, 0xcf, 0x37, 0xb4, 0x05, 0x6f,
                0x95, 0x15, 0x1f, 0x33, 0x1e, 0x15, 0x13, 0x87, 0x3e, 0x08, 0x34, 0xa8,
                0x5e, 0x68, 0x6e, 0x39, 0xfd, 0x06, 0x3d, 0x95, 0x65, 0x50, 0xbe, 0x12,
                0x68, 0xdf, 0xe7, 0xd3, 0x7d, 0x0a, 0xca, 0x3e, 0xb8, 0x3d, 0x3a, 0xe7,
                0xad, 0xff, 0x49, 0x74, 0xce, 0x5b, 0xf5, 0xe8, 0xd0, 0xd3, 0xcf, 0x8f,
                0xce, 0x5a, 0x23, 0xff, 0xef, 0xfc, 0xee, 0xe1, 0x84, 0x65, 0x51, 0x3e,
                0x80, 0x52, 0xef, 0x9b, 0x62, 0x8c, 0x82, 0x0a, 0x38, 0x35, 0x9a, 0xec,
                0x69, 0xcd, 0xed, 0x9f, 0xe5, 0x77, 0x39, 0x11, 0xd4, 0xba, 0x4a, 0x2f,
                0xc9, 0x2b, 0xde, 0x63, 0x22, 0xbe, 0x51, 0xa9, 0xac, 0x24, 0x55, 0x82,
                0x15, 0x7f, 0x1b, 0x2b, 0x4b, 0xa7, 0x20, 0x74, 0x47, 0x43, 0x8f, 0xaa,
                0xce, 0x18, 0x3e, 0xda, 0xc4, 0x2b, 0x1b, 0x8a, 0x2c, 0x5d, 0x55, 0x34,
                0x0d, 0x8b, 0x6a, 0xd4, 0x66, 0xfe, 0x2e, 0x0c, 0x2a, 0x44, 0x8d, 0xc9,
                0x0e, 0x59, 0x90, 0x92, 0xa0, 0x5e, 0x66, 0x16, 0xbb, 0x14, 0x67, 0xf3,
                0x24, 0x84, 0xdf, 0xde, 0xbd, 0xdb, 0x21, 0xff, 0xfe, 0xd9, 0x3b, 0x57,
                0x1e, 0xc5, 0xf5, 0x9f, 0x1d, 0xbd, 0x1e, 0xbd, 0xcf, 0x14, 0x36, 0x3d,
                0x4c, 0xe0, 0xce, 0xc8, 0xed, 0xed, 0xf6, 0x8c, 0x8d, 0xe9, 0x4d, 0xd2,
                0x40, 0x50, 0xcc, 0x7d, 0x56, 0x39, 0x17, 0x58, 0xf4, 0xad, 0x68, 0x34,
                0x31, 0x65, 0x46, 0xff, 0xbb, 0x48, 0x69, 0xfe, 0x2d, 0xa3, 0x10, 0x15,
                0x0d, 0x9d, 0x60, 0x16, 0x1d, 0x35, 0x04, 0x1a, 0x8f, 0x79, 0x80, 0xf5,
                0xa6, 0x47, 0x6c, 0x5d, 0xab, 0xfb, 0x5b, 0x71, 0x95, 0xe0, 0xd3, 0x29,
                0x8d, 0x5d, 0x25, 0xbe, 0xc0, 0x08, 0x69, 0x7e, 0x83, 0x33, 0xc3, 0xf8,
                0x13, 0x50, 0x4b, 0x07, 0x08, 0x66, 0xb5, 0x3a, 0x24, 0x54, 0x04, 0x00,
                0x00, 0x31, 0x0e, 0x00, 0x00, 0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x08,
                0x08, 0x08, 0x00, 0x04, 0x83, 0x2a, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x6d,
                0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2f, 0x70, 0x61, 0x63, 0x6b,
                0x61, 0x67, 0x65, 0x5f, 0x64, 0x65, 0x73, 0x63, 0x2e, 0x6a, 0x73, 0x6f,
                0x6e, 0x5d, 0x8e, 0x41, 0x0b, 0x82, 0x40, 0x10, 0x85, 0xef, 0xfe, 0x8a,
                0x65, 0xcf, 0x29, 0xab, 0x85, 0x98, 0xb7, 0x8e, 0x1d, 0x02, 0x0f, 0x9d,
                0xba, 0x2c, 0xe3, 0x3a, 0xc9, 0x92, 0x8d, 0xb2, 0x0e, 0x91, 0x88, 0xff,
                0xbd, 0xcd, 0x0c, 0xc4, 0xd3, 0x30, 0xef, 0x7d, 0x8f, 0xf7, 0xc6, 0x40,
                0x08, 0xd9, 0x81, 0x79, 0x40, 0x8d, 0xba, 0xc2, 0xde, 0xe8, 0x17, 0xba,
                0xde, 0xb6, 0x24, 0x45, 0x2e, 0x64, 0x1c, 0x29, 0xb9, 0x5b, 0x13, 0x96,
                0xee, 0xed, 0xd7, 0x19, 0xbd, 0xb8, 0x92, 0x09, 0x9e, 0x38, 0x07, 0x3a,
                0x9b, 0x1e, 0x74, 0x09, 0x44, 0xe8, 0x34, 0x63, 0xcf, 0x73, 0x7a, 0xd3,
                0xe0, 0x6c, 0xc7, 0xff, 0x82, 0x4b, 0x6b, 0x80, 0x20, 0x3c, 0x13, 0x63,
                0x23, 0x18, 0xdf, 0x2c, 0x7e, 0xe1, 0x6d, 0x6e, 0x33, 0x6a, 0x99, 0xb5,
                0x02, 0x78, 0xe8, 0x7e, 0x0b, 0x2c, 0xf5, 0x0c, 0x4d, 0xb3, 0xf5, 0x0d,
                0x30, 0xd6, 0xad, 0x1b, 0x66, 0xe6, 0x54, 0x14, 0xba, 0xb4, 0x04, 0xfe,
                0x5d, 0xb0, 0xca, 0xdb, 0xda, 0x38, 0xf4, 0xa7, 0x9a, 0x91, 0x44, 0xc5,
                0x59, 0xa8, 0x8e, 0x61, 0xac, 0xae, 0xc9, 0x3e, 0x4f, 0x0e, 0xb9, 0xca,
                0xa2, 0x38, 0x55, 0x37, 0xe9, 0xf9, 0x29, 0x98, 0x3e, 0x50, 0x4b, 0x07,
                0x08, 0x15, 0xbd, 0xd3, 0x79, 0xb0, 0x00, 0x00, 0x00, 0x37, 0x01, 0x00,
                0x00, 0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x08, 0x08, 0x08, 0x00, 0x04,
                0x83, 0x2a, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x6d, 0x65, 0x74, 0x61, 0x64,
                0x61, 0x74, 0x61, 0x2f, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x65,
                0x72, 0x5f, 0x64, 0x65, 0x73, 0x63, 0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x6d,
                0x8c, 0x4d, 0x0a, 0xc2, 0x30, 0x10, 0x46, 0xf7, 0x3d, 0xc5, 0x90, 0xb5,
                0x94, 0x14, 0xc4, 0x85, 0x37, 0x70, 0xe7, 0x0d, 0xc2, 0x98, 0x4c, 0x35,
                0x90, 0x3f, 0x32, 0xb1, 0x28, 0xa5, 0x77, 0x37, 0x46, 0x10, 0x02, 0xdd,
                0x7e, 0xef, 0xbd, 0x6f, 0x1d, 0x00, 0x84, 0x0d, 0x5c, 0xd0, 0x39, 0xca,
                0xca, 0x10, 0x6b, 0xb5, 0x50, 0x66, 0x1b, 0x83, 0x80, 0x33, 0x88, 0x69,
                0x94, 0xe2, 0xd0, 0x3b, 0x36, 0xcc, 0xf1, 0xcb, 0xd6, 0x3a, 0x77, 0x20,
                0xa0, 0xa7, 0x16, 0xfd, 0xa7, 0x91, 0x1f, 0xad, 0xee, 0xb4, 0xf2, 0x4e,
                0x3f, 0xed, 0x86, 0x7b, 0x18, 0xf3, 0x9d, 0x1b, 0xbe, 0x5e, 0x4e, 0x47,
                0x78, 0x26, 0x83, 0x85, 0x64, 0x3d, 0x02, 0x1f, 0xb5, 0x4a, 0x39, 0xce,
                0xd6, 0xd1, 0xee, 0xaf, 0xc7, 0x97, 0x62, 0xd2, 0x31, 0x98, 0xd6, 0x4f,
                0xb2, 0x0a, 0xdb, 0xb0, 0x7d, 0x00, 0x50, 0x4b, 0x07, 0x08, 0x7d, 0x8d,
                0xc5, 0x21, 0x7f, 0x00, 0x00, 0x00, 0xe2, 0x00, 0x00, 0x00, 0x50, 0x4b,
                0x01, 0x02, 0x14, 0x00, 0x14, 0x00, 0x08, 0x08, 0x08, 0x00, 0x04, 0x83,
                0x2a, 0x4d, 0x1f, 0x5b, 0x9b, 0xaf, 0xe7, 0x00, 0x00, 0x00, 0x54, 0x04,
                0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x61, 0x74, 0x61,
                0x2f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x32, 0x2e, 0x73, 0x68, 0x50,
                0x4b, 0x01, 0x02, 0x14, 0x00, 0x14, 0x00, 0x08, 0x08, 0x08, 0x00, 0x04,
                0x83, 0x2a, 0x4d, 0xad, 0x35, 0x22, 0x41, 0x94, 0x00, 0x00, 0x00, 0xde,
                0x01, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x01, 0x00, 0x00, 0x64, 0x61, 0x74,
                0x61, 0x2f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x30, 0x2e, 0x73, 0x68,
                0x50, 0x4b, 0x01, 0x02, 0x14, 0x00, 0x14, 0x00, 0x08, 0x08, 0x08, 0x00,
                0x04, 0x83, 0x2a, 0x4d, 0xda, 0x34, 0xb5, 0x77, 0xe4, 0x00, 0x00, 0x00,
                0x0d, 0x04, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf5, 0x01, 0x00, 0x00, 0x64, 0x61,
                0x74, 0x61, 0x2f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x5f, 0x67, 0x77,
                0x2e, 0x73, 0x68, 0x50, 0x4b, 0x01, 0x02, 0x14, 0x00, 0x14, 0x00, 0x08,
                0x08, 0x08, 0x00, 0x04, 0x83, 0x2a, 0x4d, 0x75, 0x30, 0x2f, 0x48, 0xe1,
                0x00, 0x00, 0x00, 0x54, 0x04, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x03, 0x00,
                0x00, 0x64, 0x61, 0x74, 0x61, 0x2f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65,
                0x31, 0x2e, 0x73, 0x68, 0x50, 0x4b, 0x01, 0x02, 0x14, 0x00, 0x14, 0x00,
                0x08, 0x08, 0x08, 0x00, 0x04, 0x83, 0x2a, 0x4d, 0x29, 0xe7, 0xc2, 0x03,
                0xf4, 0x00, 0x00, 0x00, 0x15, 0x04, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x04,
                0x00, 0x00, 0x64, 0x61, 0x74, 0x61, 0x2f, 0x75, 0x70, 0x64, 0x61, 0x74,
                0x65, 0x5f, 0x65, 0x6e, 0x64, 0x70, 0x74, 0x2e, 0x73, 0x68, 0x50, 0x4b,
                0x01, 0x02, 0x14, 0x00, 0x14, 0x00, 0x08, 0x08, 0x08, 0x00, 0x04, 0x83,
                0x2a, 0x4d, 0x82, 0x8d, 0x45, 0x57, 0xdf, 0x00, 0x00, 0x00, 0x54, 0x04,
                0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x6c, 0x05, 0x00, 0x00, 0x64, 0x61, 0x74, 0x61,
                0x2f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x33, 0x2e, 0x73, 0x68, 0x50,
                0x4b, 0x01, 0x02, 0x14, 0x00, 0x14, 0x00, 0x08, 0x08, 0x08, 0x00, 0x04,
                0x83, 0x2a, 0x4d, 0x7f, 0x75, 0x1e, 0x1b, 0xe3, 0x00, 0x00, 0x00, 0x54,
                0x04, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x06, 0x00, 0x00, 0x64, 0x61, 0x74,
                0x61, 0x2f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x34, 0x2e, 0x73, 0x68,
                0x50, 0x4b, 0x01, 0x02, 0x14, 0x00, 0x14, 0x00, 0x08, 0x08, 0x08, 0x00,
                0x04, 0x83, 0x2a, 0x4d, 0x66, 0xb5, 0x3a, 0x24, 0x54, 0x04, 0x00, 0x00,
                0x31, 0x0e, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa8, 0x07, 0x00, 0x00, 0x6d, 0x65,
                0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2f, 0x69, 0x6e, 0x73, 0x74, 0x61,
                0x6c, 0x6c, 0x65, 0x72, 0x2e, 0x73, 0x68, 0x50, 0x4b, 0x01, 0x02, 0x14,
                0x00, 0x14, 0x00, 0x08, 0x08, 0x08,
          0x04, 0x81, 0x9d,  /* OCTET_STRING (3) = 157 */
                0x00, 0x04, 0x83,
                0x2a, 0x4d, 0x15, 0xbd, 0xd3, 0x79, 0xb0, 0x00, 0x00, 0x00, 0x37, 0x01,
                0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x3f, 0x0c, 0x00, 0x00, 0x6d, 0x65, 0x74, 0x61,
                0x64, 0x61, 0x74, 0x61, 0x2f, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65,
                0x5f, 0x64, 0x65, 0x73, 0x63, 0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x50, 0x4b,
                0x01, 0x02, 0x14, 0x00, 0x14, 0x00, 0x08, 0x08, 0x08, 0x00, 0x04, 0x83,
                0x2a, 0x4d, 0x7d, 0x8d, 0xc5, 0x21, 0x7f, 0x00, 0x00, 0x00, 0xe2, 0x00,
                0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x37, 0x0d, 0x00, 0x00, 0x6d, 0x65, 0x74, 0x61,
                0x64, 0x61, 0x74, 0x61, 0x2f, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c,
                0x65, 0x72, 0x5f, 0x64, 0x65, 0x73, 0x63, 0x2e, 0x6a, 0x73, 0x6f, 0x6e,
                0x50, 0x4b, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x0a, 0x00,
                0x87, 0x02, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00,  /* EOC */
        0x00, 0x00  /* EOC */
    };

    MAsn1TypeAndCount def[2] =
    {
      {  MASN1_TYPE_SEQUENCE | MASN1_IMPLICIT, 1 },
        {  MASN1_TYPE_OCTET_STRING | MASN1_TYPE_INDEF_BIT , 0 },
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 2, MASN1_FNCT_DECODE, NULL, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array */
    status = MAsn1DecodeIndefiniteUpdateFlag (encoded, sizeof(encoded), MASN1_DECODE_UPDATE,
                                              pRoot,
                                              TestSeqDataReturn,
                                              (void *) &returnInfo,
                                              &bytesRead,
                                              &done);
    retval += UNITTEST_STATUS(10, status);
    if (retval > 0)
        goto exit;

    /* Check number of bytes read */
    retval += UNITTEST_INT(11, bytesRead, 36);
    if (retval > 0)
        goto exit;

    /* Check state */
    retval += UNITTEST_TRUE(12, done);
    if (retval > 0)
        goto exit;

    /* Check number of octet data read */
    retval += UNITTEST_INT(13, returnInfo.len, 24);
    if (retval > 0)
        goto exit;

    /* Cleanup memory */
    FreeTestDataReturn (&returnInfo);
    MAsn1FreeElementArray (&pRoot);

    /* SECOND TEST ARRAY */
    DIGI_MEMSET((ubyte*)&returnInfo, 0, sizeof(returnInfo));
    done = 0;

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 2, MASN1_FNCT_DECODE, NULL, &pRoot);
    retval += UNITTEST_STATUS(100, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array */
    status = MAsn1DecodeIndefiniteUpdateFlag (encoded2, sizeof(encoded2), MASN1_DECODE_UPDATE,
                                              pRoot,
                                              TestSeqDataReturn,
                                              (void *) &returnInfo,
                                              &bytesRead,
                                              &done);
    retval += UNITTEST_STATUS(110, status);
    if (retval > 0)
        goto exit;

    /* Check number of bytes read */
    retval += UNITTEST_INT(111, bytesRead, 4272);
    if (retval > 0)
        goto exit;

    /* Check state */
    retval += UNITTEST_TRUE(112, done);
    if (retval > 0)
        goto exit;

    /* Check number of octet data read */
    retval += UNITTEST_INT(113, returnInfo.len, 2048+2048+157);
    if (retval > 0)
        goto exit;

exit:
    /* Cleanup memory */
    FreeTestDataReturn (&returnInfo);
    MAsn1FreeElementArray (&pRoot);
    return retval;
}


/*----------------------------------------------------------------------*/

static int read_indefOctet_chunked(ubyte4 chunkSize)
{
    MSTATUS status;
    int retval = 0;
    ubyte4 hint = 100 * chunkSize;

    ubyte  *buf = NULL;
    ubyte4 copied = 0;

    MAsn1Element* pRoot = NULL;
    ubyte4 bytesRead;
    sbyte4 cmpResult;
    intBoolean done = 0;
    TestDataReturnInfo returnInfo =
    { NULL, NULL, NULL, 0, 0 };

    /* input data with large octet string element */
    ubyte encoded[] =
    {
      0xA0, 0x80, /* [0] */
        0x24, 0x80, /* OCTET/INDEF */
           0x04, 0x82, 0x10, 0x00, /* OCTET_STRING (1) = 4096 */
                 0x4C, 0x6F, 0x72, 0x65, 0x6D, 0x20, 0x69, 0x70,
                 0x73, 0x75, 0x6D, 0x20, 0x64, 0x6F, 0x6C, 0x6F,
                 0x72, 0x20, 0x73, 0x69, 0x74, 0x20, 0x61, 0x6D,
    };

    /* input data taken from bad CMS case */
    ubyte encoded2[] =
    {
      0xa0, 0x80,  /* [0] */
        0x24, 0x80,  /* OCTET/INDEF */
          0x04, 0x82, 0x08, 0x00, /* OCTET_STRING (1) = 2048 */
                0x50, 0x4b,
                0x03, 0x04, 0x14, 0x00, 0x08, 0x08, 0x08, 0x00, 0x04, 0x83, 0x2a, 0x4d,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x0f, 0x00, 0x00, 0x00, 0x64, 0x61, 0x74, 0x61, 0x2f, 0x75, 0x70, 0x64,
                0x61, 0x74, 0x65, 0x32, 0x2e, 0x73, 0x68, 0xa5, 0x92, 0x3d, 0x0e, 0xc3,
                0x20, 0x0c, 0x85, 0xf7, 0x9c, 0xc2, 0x0a, 0x43, 0x52, 0xa9, 0x12, 0x17,
                0x42, 0xf2, 0x50, 0x55, 0xea, 0xd6, 0x0b, 0xf8, 0xf0, 0xc5, 0x18, 0x8c,
                0x0d, 0x64, 0x88, 0x9a, 0x2a, 0x71, 0xfc, 0xf3, 0x3e, 0x5e, 0x21, 0xdb,
                0xfb, 0xf5, 0xf9, 0xc2, 0xbe, 0x6f, 0x12, 0x01, 0x10, 0xe5, 0xbe, 0x75,
                0xa1, 0x53, 0x38, 0x35, 0x82, 0xb2, 0x09, 0x20, 0x45, 0xe0, 0xa0, 0x82,
                0x1a, 0xf3, 0x13, 0xcb, 0xac, 0x96, 0x15, 0x42, 0xf9, 0x95, 0xb4, 0x45,
                0x9c, 0x37, 0x5d, 0x4e, 0x0c, 0x9b, 0x52, 0x24, 0x66, 0xc7, 0x3c, 0x9b,
                0xa0, 0x44, 0x94, 0xf4, 0xe0, 0x2e, 0x1c, 0x5a, 0x3e, 0xc4, 0x82, 0xe0,
                0x40, 0x5b, 0xa4, 0x82, 0x9c, 0x0d, 0x6c, 0x19, 0x25, 0x38, 0xf1, 0x51,
                0x63, 0x59, 0xff, 0x44, 0x02, 0xfb, 0x93, 0xbc, 0x4c, 0x59, 0x15, 0x55,
                0xdf, 0xfc, 0x3f, 0x30, 0x7a, 0x36, 0x2f, 0x59, 0x1e, 0x09, 0xb9, 0x27,
                0x51, 0xd2, 0x27, 0xd3, 0xea, 0xdd, 0xf2, 0xba, 0x27, 0x28, 0x65, 0x6c,
                0x2d, 0x6a, 0xba, 0x5c, 0x68, 0x6c, 0x5d, 0x23, 0x14, 0x51, 0xb8, 0x79,
                0xa6, 0xa1, 0xe9, 0xf8, 0x72, 0x9d, 0x19, 0xdc, 0x66, 0xfa, 0xac, 0x84,
                0x9a, 0x07, 0xc7, 0xa8, 0xe0, 0x85, 0xab, 0x05, 0x78, 0x88, 0xfa, 0x6e,
                0x19, 0xd0, 0x7d, 0xda, 0x55, 0x6e, 0x81, 0x3b, 0xce, 0x1a, 0xff, 0x67,
                0x2b, 0x6c, 0x3e, 0xd0, 0x47, 0xc7, 0x8b, 0xa3, 0xb9, 0x70, 0x0c, 0xd7,
                0x8e, 0x9d, 0x3c, 0xac, 0x8a, 0x1e, 0xec, 0x9d, 0xc2, 0xec, 0xdc, 0x6e,
                0xc5, 0x74, 0x78, 0x61, 0xda, 0x8b, 0xfe, 0xd9, 0xfd, 0x00, 0x50, 0x4b,
                0x07, 0x08, 0x1f, 0x5b, 0x9b, 0xaf, 0xe7, 0x00, 0x00, 0x00, 0x54, 0x04,
                0x00, 0x00, 0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x08, 0x08, 0x08, 0x00,
                0x04, 0x83, 0x2a, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x64, 0x61, 0x74, 0x61,
                0x2f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x30, 0x2e, 0x73, 0x68, 0x95,
                0x50, 0x4b, 0x0a, 0x43, 0x21, 0x10, 0xdb, 0x7b, 0x8a, 0xe0, 0xc6, 0x57,
                0x28, 0x78, 0x21, 0x21, 0x8b, 0x52, 0xe8, 0xae, 0x17, 0x98, 0xc3, 0xbf,
                0xf9, 0xe8, 0xa0, 0xdd, 0xf5, 0x89, 0xc6, 0x4c, 0x26, 0xd1, 0x67, 0x79,
                0xbf, 0x3e, 0x5f, 0xd4, 0x5a, 0x02, 0x01, 0x32, 0xe6, 0x5f, 0x1f, 0x0f,
                0xc7, 0xe1, 0x26, 0x32, 0x5b, 0x80, 0xd1, 0x61, 0x90, 0x86, 0x89, 0xba,
                0xd2, 0x7b, 0xb3, 0x9c, 0x21, 0xa2, 0x5b, 0x49, 0x49, 0x8c, 0x2f, 0x9f,
                0x92, 0x2d, 0x5b, 0x46, 0x17, 0xcb, 0xee, 0xda, 0x3b, 0xe0, 0xc8, 0xa0,
                0xcd, 0x54, 0xb4, 0x2c, 0xb7, 0xb8, 0x42, 0xc4, 0x21, 0x25, 0x49, 0x83,
                0xb2, 0x9f, 0xec, 0x68, 0x15, 0x5c, 0x7c, 0x4c, 0xf4, 0xf3, 0x2f, 0x0a,
                0xf6, 0x11, 0xdc, 0xbb, 0x76, 0x97, 0xcc, 0x7b, 0xdb, 0x7f, 0xb0, 0x9f,
                0xd9, 0x76, 0xa4, 0x2f, 0x83, 0xa6, 0x05, 0x06, 0x7d, 0x5a, 0xda, 0x9c,
                0x8b, 0xcf, 0x37, 0x61, 0x94, 0xb9, 0x24, 0x59, 0x3e, 0x2d, 0xac, 0xec,
                0x5a, 0xca, 0x0d, 0x50, 0x4b, 0x07, 0x08, 0xad, 0x35, 0x22, 0x41, 0x94,
                0x00, 0x00, 0x00, 0xde, 0x01, 0x00, 0x00, 0x50, 0x4b, 0x03, 0x04, 0x14,
                0x00, 0x08, 0x08, 0x08, 0x00, 0x04, 0x83, 0x2a, 0x4d, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00,
                0x00, 0x64, 0x61, 0x74, 0x61, 0x2f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65,
                0x5f, 0x67, 0x77, 0x2e, 0x73, 0x68, 0x9d, 0x52, 0x49, 0x0a, 0xc3, 0x30,
                0x0c, 0xbc, 0xe7, 0x15, 0x22, 0x97, 0xa4, 0x10, 0xf0, 0x6f, 0x7a, 0x32,
                0xcc, 0xa1, 0x14, 0x7a, 0xeb, 0x07, 0xf4, 0xf8, 0x6a, 0xb1, 0x15, 0xb9,
                0x50, 0x92, 0xd4, 0x8a, 0xad, 0x68, 0x1b, 0x39, 0x9a, 0x4c, 0xcf, 0xc7,
                0xeb, 0x4d, 0xf3, 0x3c, 0xb9, 0x26, 0x02, 0x7c, 0x5f, 0x5a, 0x18, 0x2a,
                0x86, 0x6a, 0x50, 0x60, 0x33, 0x51, 0x2d, 0xa4, 0x2a, 0x0a, 0x9a, 0x96,
                0x13, 0x96, 0x1b, 0xee, 0x00, 0x61, 0x79, 0xe5, 0x08, 0xb1, 0xda, 0xbd,
                0x4e, 0x8c, 0x84, 0xcd, 0xb5, 0xb0, 0x62, 0x17, 0xc9, 0xad, 0x64, 0x1a,
                0x6e, 0x2e, 0x1a, 0xa5, 0x25, 0xdc, 0x8b, 0x5f, 0xc1, 0xe1, 0x28, 0x42,
                0x1c, 0x05, 0x62, 0x7d, 0x61, 0x7b, 0x2a, 0xd3, 0x8a, 0x5b, 0xd3, 0xd6,
                0x7f, 0x05, 0x53, 0x16, 0xb7, 0x2d, 0x2b, 0x57, 0x71, 0xbb, 0xb7, 0x7e,
                0x07, 0xca, 0x88, 0xad, 0x2d, 0xed, 0xa8, 0xd0, 0x98, 0x6b, 0x37, 0x37,
                0x45, 0x6b, 0xbb, 0xdb, 0x6d, 0x26, 0x70, 0x37, 0x7a, 0x88, 0x7b, 0x9d,
                0x38, 0x3a, 0xf6, 0xce, 0xa9, 0x8e, 0xeb, 0x27, 0x41, 0x7f, 0xad, 0x1d,
                0x5b, 0xc7, 0x0c, 0x0e, 0xce, 0x06, 0x82, 0x7a, 0x53, 0xd3, 0xc1, 0xf1,
                0x51, 0xff, 0x71, 0xee, 0xa0, 0xc4, 0x61, 0x22, 0x48, 0xa5, 0xc8, 0x23,
                0xb2, 0xc7, 0x5d, 0x4e, 0x62, 0x23, 0x73, 0x36, 0x10, 0x24, 0xd0, 0x77,
                0x92, 0xa7, 0x0c, 0x1c, 0xe3, 0x2c, 0xb6, 0x51, 0x91, 0x39, 0xcb, 0x04,
                0xa9, 0x2e, 0xd5, 0x98, 0xce, 0xf1, 0xed, 0x2c, 0xf6, 0xd5, 0xc5, 0xed,
                0xb7, 0x3a, 0xc6, 0x9e, 0xa7, 0x0f, 0x50, 0x4b, 0x07, 0x08, 0xda, 0x34,
                0xb5, 0x77, 0xe4, 0x00, 0x00, 0x00, 0x0d, 0x04, 0x00, 0x00, 0x50, 0x4b,
                0x03, 0x04, 0x14, 0x00, 0x08, 0x08, 0x08, 0x00, 0x04, 0x83, 0x2a, 0x4d,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x0f, 0x00, 0x00, 0x00, 0x64, 0x61, 0x74, 0x61, 0x2f, 0x75, 0x70, 0x64,
                0x61, 0x74, 0x65, 0x31, 0x2e, 0x73, 0x68, 0xa5, 0x51, 0xcb, 0x0a, 0x03,
                0x21, 0x0c, 0xbc, 0xfb, 0x15, 0xc3, 0x7a, 0xd8, 0x2d, 0x14, 0xfc, 0x21,
                0x21, 0x87, 0x52, 0xe8, 0xad, 0x3f, 0x90, 0x8f, 0xaf, 0x31, 0x1a, 0x1f,
                0xdb, 0x82, 0x4b, 0x5d, 0x34, 0x4e, 0xe2, 0x4c, 0x66, 0xd5, 0x3d, 0x1f,
                0xaf, 0x37, 0xb6, 0xcd, 0x69, 0x04, 0x88, 0x74, 0x5e, 0x1a, 0x34, 0x30,
                0x06, 0x36, 0xc1, 0xb4, 0x19, 0x88, 0x01, 0x12, 0x8c, 0x50, 0x62, 0x5a,
                0x29, 0x9f, 0xb5, 0xb4, 0x89, 0x70, 0xda, 0xb2, 0x95, 0x58, 0x70, 0xe5,
                0x25, 0xd0, 0x69, 0x73, 0x0c, 0x2c, 0xda, 0x21, 0x9d, 0x8d, 0xc8, 0x91,
                0x14, 0xee, 0x52, 0xc5, 0x6e, 0xe9, 0x5d, 0x2d, 0xa8, 0x1c, 0xac, 0xc4,
                0x46, 0x48, 0x68, 0xd2, 0xd6, 0xa3, 0x8c, 0x83, 0x6e, 0x25, 0xe6, 0xfe,
                0x07, 0x31, 0xfa, 0x4f, 0x71, 0x3e, 0xd5, 0xb3, 0xb8, 0xf8, 0x96, 0xff,
                0xa0, 0x30, 0x6a, 0x4b, 0xcb, 0xbc, 0x44, 0x92, 0x9a, 0x46, 0x85, 0x77,
                0x51, 0x2b, 0xb3, 0xe2, 0x72, 0x27, 0xa4, 0x69, 0xaa, 0x25, 0xae, 0xbc,
                0x94, 0xa8, 0xda, 0xd6, 0xc3, 0x67, 0x92, 0xbf, 0xf8, 0xa6, 0xbe, 0x32,
                0x4e, 0xc4, 0xb3, 0xb0, 0x97, 0x81, 0x16, 0x65, 0x87, 0x86, 0x7d, 0xcb,
                0x77, 0xc2, 0x7e, 0x45, 0x78, 0x8a, 0xb6, 0x6f, 0x19, 0x93, 0xad, 0x5d,
                0xfc, 0x92, 0xe3, 0x5f, 0x0d, 0xd0, 0x1b, 0xff, 0xe7, 0x2a, 0x7a, 0x3c,
                0xa9, 0xcf, 0x8e, 0xd7, 0x84, 0xcd, 0xcc, 0x77, 0xc7, 0x03, 0x7d, 0xc1,
                0xf1, 0xe8, 0x14, 0x67, 0xe7, 0xfd, 0x55, 0xcc, 0x8f, 0x37, 0xde, 0xcf,
                0x20, 0xbc, 0xb9, 0x0f, 0x50, 0x4b, 0x07, 0x08, 0x75, 0x30, 0x2f, 0x48,
                0xe1, 0x00, 0x00, 0x00, 0x54, 0x04, 0x00, 0x00, 0x50, 0x4b, 0x03, 0x04,
                0x14, 0x00, 0x08, 0x08, 0x08, 0x00, 0x04, 0x83, 0x2a, 0x4d, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00,
                0x00, 0x00, 0x64, 0x61, 0x74, 0x61, 0x2f, 0x75, 0x70, 0x64, 0x61, 0x74,
                0x65, 0x5f, 0x65, 0x6e, 0x64, 0x70, 0x74, 0x2e, 0x73, 0x68, 0x95, 0x92,
                0xdd, 0x0a, 0xc3, 0x20, 0x0c, 0x85, 0xef, 0xfb, 0x14, 0xa1, 0x37, 0x6d,
                0x61, 0xcc, 0x17, 0x12, 0xce, 0x60, 0x0c, 0x76, 0xb7, 0x17, 0xc8, 0xc3,
                0xcf, 0x18, 0x8d, 0xd1, 0x3a, 0xe8, 0x1c, 0x6d, 0x96, 0xbf, 0x63, 0xf4,
                0xeb, 0xf2, 0x7a, 0xbe, 0x3f, 0xb4, 0xae, 0x8b, 0x5a, 0x22, 0x40, 0x9f,
                0xbf, 0x16, 0xba, 0x8e, 0xae, 0x1b, 0x64, 0xda, 0x4c, 0x14, 0x03, 0x89,
                0xb1, 0x86, 0x62, 0xd3, 0x1b, 0xb9, 0xd6, 0xc2, 0x26, 0xc2, 0xe9, 0x2f,
                0x5b, 0x8a, 0xc5, 0xaf, 0x7d, 0xc9, 0x71, 0xda, 0x1c, 0x03, 0x8b, 0x76,
                0x48, 0xb5, 0x91, 0xb2, 0x85, 0xba, 0x9b, 0x64, 0x69, 0xb3, 0xf0, 0xa6,
                0x23, 0xa8, 0x1c, 0x59, 0x8a, 0xad, 0x21, 0x79, 0x83, 0xb6, 0x96, 0x32,
                0xed, 0x38, 0x8a, 0xcd, 0xfb, 0xef, 0x60, 0xf2, 0x3f, 0xf5, 0x73, 0x95,
                0xef, 0xe2, 0x32, 0xb7, 0x9c, 0x03, 0xa1, 0xd7, 0x96, 0x2d, 0xf3, 0x2b,
                0x42, 0x72, 0x6a, 0xd5, 0xbd, 0x89, 0x5a, 0x79, 0xaa, 0x5f, 0xee, 0x04,
                0x1a, 0x46, 0x4d, 0x71, 0xed, 0x4b, 0x81, 0xaa, 0xed, 0x99, 0x02, 0x27,
                0xa6, 0x33, 0xc6, 0x13, 0x8a, 0x9e, 0x1e, 0x74, 0x34, 0xb7, 0xf2, 0x21,
                0x87, 0x95, 0x4f, 0x3f, 0xe4, 0xfd, 0x5d, 0x56, 0xc6, 0x0d, 0x76, 0xae,
                0x72, 0x3e, 0xea, 0xfe, 0x03, 0xf5, 0x7e, 0x16, 0xa6, 0xc6, 0x4e, 0xa8,
                0xc5, 0xc7, 0xc0, 0x59, 0xa1, 0xb6, 0x58, 0x01, 0xdc, 0xcf, 0x52, 0x3e,
                0xa4, 0x0e, 0xa0, 0x24, 0x2a, 0xe7, 0xa3, 0x03, 0xcc, 0x93, 0x59, 0xf4,
                0x76, 0xcf, 0xa8, 0x98, 0xee, 0x8d, 0x68, 0x20, 0xcb, 0x3b, 0x66, 0x4d,
                0xe5, 0xe7, 0x9a, 0xdd, 0xf0, 0xb8, 0x2e, 0xa8, 0xe0, 0xba, 0xca, 0xba,
                0x7c, 0x01, 0x50, 0x4b, 0x07, 0x08, 0x29, 0xe7, 0xc2, 0x03, 0xf4, 0x00,
                0x00, 0x00, 0x15, 0x04, 0x00, 0x00, 0x50, 0x4b, 0x03, 0x04, 0x14, 0x00,
                0x08, 0x08, 0x08, 0x00, 0x04, 0x83, 0x2a, 0x4d, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00,
                0x64, 0x61, 0x74, 0x61, 0x2f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x33,
                0x2e, 0x73, 0x68, 0xa5, 0x51, 0x41, 0x0e, 0xc3, 0x20, 0x0c, 0xbb, 0xf7,
                0x15, 0x56, 0x39, 0xb4, 0x93, 0x26, 0xf1, 0x21, 0xa4, 0x1c, 0xa6, 0x49,
                0xbb, 0xed, 0x03, 0x79, 0xfc, 0x08, 0x81, 0x34, 0xd0, 0x6e, 0x5a, 0x37,
                0x2a, 0x08, 0x26, 0xb1, 0x71, 0xc3, 0x74, 0xbf, 0x3d, 0x9e, 0x98, 0xe7,
                0x49, 0x23, 0x40, 0xa4, 0xf3, 0xd4, 0xa0, 0x8e, 0xd1, 0xb1, 0x09, 0xa6,
                0xcd, 0x40, 0x8a, 0x90, 0x60, 0x84, 0x1a, 0xf3, 0x4a, 0xa5, 0xd6, 0x8e,
                0x4d, 0x84, 0xf3, 0x96, 0x2d, 0xc5, 0x82, 0x1b, 0x2f, 0x03, 0xa7, 0xcd,
                0x29, 0xb2, 0x68, 0xc7, 0x5c, 0x9b, 0x50, 0x22, 0x29, 0x5c, 0x24, 0x8b,
                0xc5, 0x8e, 0x17, 0xb5, 0xa0, 0x72, 0xb0, 0x14, 0x1b, 0x21, 0xa3, 0x41,
                0x5b, 0x4b, 0x19, 0x2b, 0x5d, 0x6a, 0x2c, 0xf7, 0xaf, 0xc4, 0xf0, 0x9f,
                0xe2, 0x52, 0xe5, 0x59, 0x5c, 0x7d, 0xcb, 0x7f, 0x50, 0xec, 0xb5, 0xe5,
                0xca, 0xb2, 0x24, 0x92, 0x9c, 0x46, 0x85, 0x57, 0x51, 0xab, 0xb3, 0xe1,
                0xda, 0x13, 0xd2, 0x63, 0x6a, 0x29, 0x6e, 0xbc, 0x7c, 0xd0, 0xb4, 0xed,
                0x8e, 0x50, 0x48, 0xe1, 0xe4, 0x9b, 0x86, 0xc6, 0x93, 0xd1, 0x65, 0xf6,
                0xc2, 0xad, 0x66, 0xab, 0xd5, 0x50, 0x71, 0xe8, 0x34, 0xaa, 0xf0, 0x81,
                0xab, 0x03, 0xe1, 0x21, 0xda, 0xde, 0x6b, 0x60, 0xf3, 0xe9, 0x6f, 0x39,
                0x25, 0xbc, 0xc9, 0x79, 0xe3, 0xff, 0xb4, 0xc2, 0xe3, 0x41, 0xfd, 0x77,
                0xc7, 0x78, 0xef, 0xb8, 0xf3, 0xf5, 0x45, 0x8f, 0x7b, 0xa7, 0xd8, 0x3b,
                0xf7, 0xad, 0x18, 0x1f, 0xef, 0x43, 0x2b, 0xe6, 0xe9, 0x05, 0x50, 0x4b,
                0x07, 0x08, 0x82, 0x8d, 0x45, 0x57, 0xdf, 0x00, 0x00, 0x00, 0x54, 0x04,
                0x00, 0x00, 0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x08, 0x08, 0x08, 0x00,
                0x04, 0x83, 0x2a, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x64, 0x61, 0x74, 0x61,
                0x2f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x34, 0x2e, 0x73, 0x68, 0x9d,
                0x51, 0x41, 0x0e, 0xc3, 0x20, 0x0c, 0xbb, 0xf7, 0x15, 0x56, 0x73, 0x68,
                0x27, 0x4d, 0xe2, 0x43, 0x48, 0x39, 0x4c, 0x93, 0x76, 0xdb, 0x07, 0xf2,
                0xf8, 0x11, 0x02, 0x29, 0xd0, 0xae, 0x53, 0x47, 0x05, 0xc1, 0x09, 0x36,
                0x6e, 0x98, 0x9e, 0x8f, 0xd7, 0x1b, 0xf3, 0x3c, 0x59, 0x04, 0x98, 0x6d,
                0x5e, 0x1a, 0xdc, 0x31, 0x3a, 0x36, 0xc3, 0xb5, 0x05, 0x88, 0x01, 0x1a,
                0x9c, 0x50, 0x62, 0x5a, 0x39, 0x9f, 0xf5, 0xb4, 0x8b, 0x48, 0xda, 0x8a,
                0x97, 0x44, 0x71, 0xe5, 0x25, 0xd0, 0x68, 0x4b, 0x0c, 0xa2, 0xda, 0x21,
                0x9d, 0x8d, 0xc8, 0x91, 0x0d, 0x2e, 0x5a, 0xc5, 0xe2, 0xe9, 0xc5, 0x2c,
                0x98, 0x1c, 0xbc, 0x24, 0x4e, 0x48, 0x68, 0xd0, 0xb6, 0xa3, 0x82, 0x95,
                0x6f, 0x25, 0xe6, 0xfb, 0x57, 0x16, 0xb4, 0x9f, 0xe1, 0x7c, 0xaa, 0x65,
                0x49, 0xf1, 0xad, 0xff, 0xc1, 0xa1, 0xd7, 0xd6, 0x2b, 0xf3, 0x12, 0x59,
                0x6b, 0x16, 0x0d, 0xde, 0x55, 0xad, 0xcc, 0x8a, 0x4b, 0x4f, 0xd8, 0xd2,
                0x5c, 0x4b, 0x52, 0x79, 0x29, 0x51, 0xb5, 0xfd, 0x0e, 0xca, 0x24, 0xba,
                0xf8, 0xa6, 0x64, 0x8c, 0x03, 0xda, 0x5e, 0x98, 0x74, 0x60, 0x8b, 0xba,
                0xc3, 0x86, 0x69, 0xcb, 0x0f, 0xc2, 0xf4, 0x4b, 0x78, 0x88, 0xbe, 0xdf,
                0xd3, 0xa9, 0xde, 0xf2, 0x97, 0xf0, 0x60, 0xa9, 0x33, 0x7c, 0xcd, 0x71,
                0x6d, 0x45, 0x8b, 0x8f, 0xe9, 0x9b, 0xe3, 0xbe, 0x41, 0x27, 0x8e, 0xf1,
                0xdd, 0x71, 0xe7, 0x8b, 0xd0, 0xba, 0x3f, 0x14, 0xee, 0x9d, 0x62, 0xef,
                0xbc, 0x6d, 0xc5, 0xf8, 0x78, 0x27, 0xc2, 0xf3, 0xf4, 0x01, 0x50, 0x4b,
                0x07, 0x08, 0x7f, 0x75, 0x1e, 0x1b, 0xe3, 0x00, 0x00, 0x00, 0x54, 0x04,
                0x00, 0x00, 0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x08, 0x08, 0x08, 0x00,
                0x04, 0x83, 0x2a, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x6d, 0x65, 0x74, 0x61,
                0x64, 0x61, 0x74, 0x61, 0x2f, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c,
                0x65, 0x72, 0x2e, 0x73, 0x68, 0xcd, 0x57, 0x6d, 0x6f, 0xda, 0x48, 0x10,
                0xfe, 0x1c, 0xff, 0x8a, 0x89, 0x13, 0xa9, 0xc9, 0x49, 0x98, 0x0b, 0x69,
                0x7b, 0x52, 0x2e, 0x54, 0x47, 0xc1, 0x49, 0x91, 0x08, 0x58, 0xc6, 0x51,
                0x3f, 0x54, 0x95, 0xb3, 0xb1, 0x07,
          0x04, 0x82, 0x08, 0x00,  /* OCTET_STRING (2) = 2048 */
                0x58, 0xd5,
                0xd8, 0xd6, 0xee, 0x3a, 0x2f, 0x8a, 0xf8, 0xef, 0x37, 0x6b, 0x1b, 0xc7,
                0xbc, 0x5d, 0xef, 0x7a, 0xf4, 0x74, 0x2b, 0x44, 0xb0, 0x67, 0xe6, 0xd9,
                0x9d, 0xd9, 0x67, 0x5e, 0x72, 0x74, 0xd8, 0xcc, 0xa4, 0x68, 0xde, 0xf3,
                0xb8, 0x89, 0xf1, 0x03, 0xdc, 0x33, 0x39, 0x33, 0x8c, 0xa3, 0x7d, 0x2f,
                0xe3, 0x08, 0xc6, 0x81, 0xe0, 0xa9, 0x82, 0x21, 0x9b, 0xe3, 0x05, 0xf0,
                0x58, 0x2a, 0x16, 0x45, 0x28, 0x2c, 0x39, 0x3b, 0x28, 0x96, 0xd6, 0xe9,
                0xa1, 0xcc, 0xb5, 0x78, 0x12, 0x5f, 0x80, 0x87, 0x52, 0x81, 0x59, 0xd7,
                0x34, 0xa1, 0x10, 0xc3, 0x24, 0x11, 0xa0, 0x48, 0xcc, 0xe3, 0x29, 0xdc,
                0xa6, 0x21, 0x53, 0x08, 0xdd, 0x88, 0x63, 0xac, 0x0a, 0x98, 0x8e, 0x98,
                0x4a, 0xb2, 0x9f, 0x71, 0xb9, 0x34, 0x60, 0x41, 0x80, 0xa9, 0x92, 0xa0,
                0x66, 0x02, 0x11, 0x98, 0x98, 0x66, 0x73, 0xd2, 0x26, 0xa5, 0x93, 0xb3,
                0x53, 0x48, 0x23, 0xa6, 0x08, 0x71, 0x7e, 0x01, 0x29, 0x7f, 0xff, 0x16,
                0xd6, 0x97, 0x46, 0x2c, 0xd6, 0x49, 0xeb, 0x14, 0xb2, 0x7c, 0x3b, 0x85,
                0x4f, 0x6a, 0xc2, 0x23, 0x8c, 0xc9, 0x1b, 0x38, 0x39, 0x3f, 0x05, 0x45,
                0x98, 0xa8, 0xea, 0xaf, 0x0f, 0x36, 0x80, 0xf2, 0xa5, 0x0f, 0xb8, 0xff,
                0xe8, 0x1e, 0x15, 0xde, 0x32, 0x29, 0xc9, 0x31, 0xed, 0x26, 0x53, 0xe0,
                0xb8, 0x23, 0xc7, 0xef, 0x0e, 0xfa, 0xf6, 0xd0, 0x03, 0x92, 0xf1, 0x98,
                0x5e, 0x23, 0xe0, 0x13, 0x06, 0x99, 0x0e, 0x30, 0xa4, 0x4c, 0xcd, 0x20,
                0x99, 0xe4, 0x6f, 0x8b, 0x30, 0x69, 0x9c, 0xb1, 0xdb, 0xd5, 0xda, 0xfa,
                0x65, 0x94, 0x04, 0x2c, 0xd7, 0x2c, 0x95, 0xc8, 0x71, 0x06, 0xa9, 0x48,
                0x1e, 0x78, 0x88, 0x61, 0x81, 0x47, 0x9a, 0x29, 0x0b, 0xbe, 0xb1, 0x29,
                0x5a, 0x86, 0x41, 0xa6, 0x6d, 0xd3, 0x32, 0x8d, 0x5e, 0xc7, 0xb3, 0xdb,
                0x77, 0x3a, 0x4c, 0x77, 0x86, 0xc1, 0x27, 0x30, 0x23, 0x4e, 0x81, 0x4a,
                0xb3, 0xc0, 0x4f, 0x03, 0x68, 0x7d, 0x68, 0x86, 0xf8, 0xd0, 0x8c, 0xb3,
                0x28, 0xfa, 0x5d, 0xa3, 0xc6, 0x06, 0x05, 0xa5, 0x76, 0xd4, 0x76, 0xa9,
                0x68, 0x60, 0x24, 0x51, 0xcb, 0x96, 0x00, 0xd9, 0xdc, 0xa7, 0xbd, 0x53,
                0x14, 0xea, 0xd9, 0x0f, 0xf2, 0xcb, 0xde, 0x8e, 0x95, 0xaf, 0x3a, 0xe0,
                0xa6, 0xa1, 0x56, 0xcb, 0xe1, 0x0f, 0x30, 0x98, 0x25, 0x60, 0x9a, 0x95,
                0x5d, 0xf1, 0xdc, 0x1f, 0x8e, 0xbd, 0xce, 0x60, 0x60, 0xbb, 0x60, 0xbb,
                0xee, 0xc8, 0x3d, 0x04, 0xcf, 0xb9, 0xed, 0x82, 0x53, 0x82, 0x94, 0x54,
                0xd3, 0x51, 0x8a, 0x13, 0xcd, 0xc5, 0x2c, 0x0e, 0x97, 0xd1, 0x75, 0x3a,
                0xde, 0x27, 0x0b, 0xec, 0xa7, 0x14, 0x03, 0x92, 0x30, 0x1e, 0x65, 0x02,
                0xe5, 0xe1, 0x21, 0x98, 0x9b, 0x5b, 0xd5, 0x8f, 0x48, 0xdb, 0xac, 0x9f,
                0xd1, 0x1f, 0x8e, 0x3c, 0xff, 0x6a, 0x74, 0x3b, 0xec, 0x81, 0x36, 0x99,
                0x70, 0x83, 0x3e, 0x86, 0x63, 0xbb, 0xe3, 0xfe, 0xd8, 0x6b, 0xdf, 0x1d,
                0xbf, 0xd4, 0xec, 0x17, 0xd0, 0x68, 0x10, 0xfb, 0x40, 0x24, 0x56, 0x90,
                0xc4, 0x13, 0x3e, 0xb5, 0x08, 0x49, 0x72, 0xa9, 0x42, 0x2e, 0xe8, 0x0a,
                0xc6, 0x5d, 0xb7, 0xef, 0x78, 0x7e, 0xaf, 0xef, 0xb6, 0xcd, 0xe3, 0x97,
                0x4f, 0xa3, 0x1b, 0x7b, 0x61, 0xfe, 0x60, 0x8e, 0x6b, 0x86, 0xb8, 0xc8,
                0x42, 0x08, 0x92, 0xf9, 0x9c, 0x91, 0xdf, 0x11, 0x8f, 0x91, 0x9c, 0x57,
                0x09, 0xb0, 0x98, 0xf2, 0x4a, 0xb0, 0x67, 0x0b, 0x2a, 0x3a, 0xce, 0x48,
                0x23, 0x22, 0x3a, 0xde, 0x27, 0xc4, 0xb4, 0x80, 0x49, 0xa4, 0x84, 0xd3,
                0x42, 0xbd, 0xea, 0x79, 0x0d, 0x26, 0x65, 0xcf, 0x99, 0x4e, 0xcb, 0x96,
                0xfe, 0x3a, 0x37, 0xb7, 0x6b, 0xc1, 0xaa, 0x96, 0xd6, 0xf9, 0x4c, 0xac,
                0x4c, 0xe2, 0x37, 0x0a, 0x62, 0x24, 0x4a, 0xe6, 0x7c, 0x94, 0xea, 0x39,
                0x42, 0xcd, 0x9a, 0x47, 0x9d, 0xe8, 0x48, 0xfb, 0x46, 0x91, 0xae, 0x13,
                0x5a, 0x9d, 0xd1, 0x85, 0xcd, 0x50, 0x2c, 0xab, 0xc2, 0x3d, 0x46, 0xc9,
                0x23, 0x64, 0x12, 0x1e, 0x9b, 0x70, 0xfc, 0x07, 0x31, 0x59, 0x50, 0xde,
                0x2a, 0x0a, 0x9d, 0xf5, 0x83, 0xd1, 0x11, 0x3a, 0x34, 0x0d, 0x01, 0x0d,
                0xa6, 0x4f, 0xe8, 0xe7, 0xf1, 0x80, 0xcb, 0xcb, 0x4b, 0x42, 0xaf, 0x02,
                0xae, 0xcf, 0x71, 0x4d, 0x97, 0x55, 0xb9, 0x06, 0x92, 0xd8, 0xc2, 0x27,
                0x3c, 0x80, 0x8e, 0x7b, 0x2d, 0x2b, 0x35, 0xef, 0xda, 0xf3, 0x9d, 0x41,
                0xc7, 0xbb, 0x1a, 0xb9, 0x37, 0xed, 0xe3, 0x97, 0x0a, 0xef, 0xcb, 0xaf,
                0x5f, 0x17, 0x3a, 0xd5, 0xfc, 0xab, 0xfe, 0xc0, 0x1e, 0x76, 0x6e, 0xec,
                0x15, 0xe1, 0x19, 0x09, 0xb5, 0xe5, 0x56, 0x61, 0x8b, 0x84, 0xb7, 0x8e,
                0x4e, 0x4f, 0xdf, 0xa3, 0xbd, 0xec, 0x42, 0x8d, 0x54, 0x5e, 0x19, 0xb2,
                0x68, 0x1e, 0xbf, 0xd4, 0xed, 0x17, 0x86, 0xb1, 0x9e, 0x13, 0xbf, 0xfc,
                0x9b, 0x65, 0x6e, 0x81, 0x5b, 0x96, 0xf0, 0x7e, 0x15, 0x11, 0x4a, 0x78,
                0xba, 0x47, 0x26, 0x14, 0x86, 0x16, 0xe5, 0x1d, 0xd2, 0xcd, 0xd0, 0x15,
                0x5a, 0x96, 0xb5, 0x5a, 0x4b, 0x77, 0xc0, 0x75, 0x89, 0x77, 0x53, 0x7d,
                0xe5, 0x45, 0x11, 0xa3, 0x9f, 0xba, 0x6a, 0xcd, 0xe9, 0xc2, 0xa9, 0x6d,
                0xdc, 0x53, 0xb9, 0x9a, 0x8a, 0x3c, 0x67, 0xd7, 0xd7, 0x76, 0xb8, 0xbd,
                0x3a, 0xdb, 0xd6, 0xeb, 0xc3, 0x6b, 0x3d, 0x59, 0xd6, 0x92, 0x0b, 0x58,
                0x4d, 0xe8, 0x9d, 0x96, 0x6a, 0xaa, 0xaa, 0x7e, 0x95, 0x1f, 0x9a, 0x2c,
                0xeb, 0x4c, 0xd9, 0x69, 0x58, 0xf4, 0x2d, 0xc8, 0x1b, 0xd6, 0xd2, 0xb0,
                0xce, 0xa2, 0xbf, 0xdc, 0x51, 0xf7, 0xb4, 0xca, 0xb4, 0xdc, 0xf1, 0xbb,
                0x86, 0x13, 0x2a, 0xcb, 0x2b, 0x96, 0x64, 0xb8, 0xc9, 0xbe, 0xa5, 0xb9,
                0x99, 0xb7, 0x8a, 0x2f, 0xab, 0xde, 0x10, 0x14, 0x98, 0x4e, 0xff, 0xfd,
                0x5b, 0x13, 0xbe, 0x96, 0x15, 0xfe, 0x60, 0xcf, 0x37, 0xb4, 0x05, 0x6f,
                0x95, 0x15, 0x1f, 0x33, 0x1e, 0x15, 0x13, 0x87, 0x3e, 0x08, 0x34, 0xa8,
                0x5e, 0x68, 0x6e, 0x39, 0xfd, 0x06, 0x3d, 0x95, 0x65, 0x50, 0xbe, 0x12,
                0x68, 0xdf, 0xe7, 0xd3, 0x7d, 0x0a, 0xca, 0x3e, 0xb8, 0x3d, 0x3a, 0xe7,
                0xad, 0xff, 0x49, 0x74, 0xce, 0x5b, 0xf5, 0xe8, 0xd0, 0xd3, 0xcf, 0x8f,
                0xce, 0x5a, 0x23, 0xff, 0xef, 0xfc, 0xee, 0xe1, 0x84, 0x65, 0x51, 0x3e,
                0x80, 0x52, 0xef, 0x9b, 0x62, 0x8c, 0x82, 0x0a, 0x38, 0x35, 0x9a, 0xec,
                0x69, 0xcd, 0xed, 0x9f, 0xe5, 0x77, 0x39, 0x11, 0xd4, 0xba, 0x4a, 0x2f,
                0xc9, 0x2b, 0xde, 0x63, 0x22, 0xbe, 0x51, 0xa9, 0xac, 0x24, 0x55, 0x82,
                0x15, 0x7f, 0x1b, 0x2b, 0x4b, 0xa7, 0x20, 0x74, 0x47, 0x43, 0x8f, 0xaa,
                0xce, 0x18, 0x3e, 0xda, 0xc4, 0x2b, 0x1b, 0x8a, 0x2c, 0x5d, 0x55, 0x34,
                0x0d, 0x8b, 0x6a, 0xd4, 0x66, 0xfe, 0x2e, 0x0c, 0x2a, 0x44, 0x8d, 0xc9,
                0x0e, 0x59, 0x90, 0x92, 0xa0, 0x5e, 0x66, 0x16, 0xbb, 0x14, 0x67, 0xf3,
                0x24, 0x84, 0xdf, 0xde, 0xbd, 0xdb, 0x21, 0xff, 0xfe, 0xd9, 0x3b, 0x57,
                0x1e, 0xc5, 0xf5, 0x9f, 0x1d, 0xbd, 0x1e, 0xbd, 0xcf, 0x14, 0x36, 0x3d,
                0x4c, 0xe0, 0xce, 0xc8, 0xed, 0xed, 0xf6, 0x8c, 0x8d, 0xe9, 0x4d, 0xd2,
                0x40, 0x50, 0xcc, 0x7d, 0x56, 0x39, 0x17, 0x58, 0xf4, 0xad, 0x68, 0x34,
                0x31, 0x65, 0x46, 0xff, 0xbb, 0x48, 0x69, 0xfe, 0x2d, 0xa3, 0x10, 0x15,
                0x0d, 0x9d, 0x60, 0x16, 0x1d, 0x35, 0x04, 0x1a, 0x8f, 0x79, 0x80, 0xf5,
                0xa6, 0x47, 0x6c, 0x5d, 0xab, 0xfb, 0x5b, 0x71, 0x95, 0xe0, 0xd3, 0x29,
                0x8d, 0x5d, 0x25, 0xbe, 0xc0, 0x08, 0x69, 0x7e, 0x83, 0x33, 0xc3, 0xf8,
                0x13, 0x50, 0x4b, 0x07, 0x08, 0x66, 0xb5, 0x3a, 0x24, 0x54, 0x04, 0x00,
                0x00, 0x31, 0x0e, 0x00, 0x00, 0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x08,
                0x08, 0x08, 0x00, 0x04, 0x83, 0x2a, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x6d,
                0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2f, 0x70, 0x61, 0x63, 0x6b,
                0x61, 0x67, 0x65, 0x5f, 0x64, 0x65, 0x73, 0x63, 0x2e, 0x6a, 0x73, 0x6f,
                0x6e, 0x5d, 0x8e, 0x41, 0x0b, 0x82, 0x40, 0x10, 0x85, 0xef, 0xfe, 0x8a,
                0x65, 0xcf, 0x29, 0xab, 0x85, 0x98, 0xb7, 0x8e, 0x1d, 0x02, 0x0f, 0x9d,
                0xba, 0x2c, 0xe3, 0x3a, 0xc9, 0x92, 0x8d, 0xb2, 0x0e, 0x91, 0x88, 0xff,
                0xbd, 0xcd, 0x0c, 0xc4, 0xd3, 0x30, 0xef, 0x7d, 0x8f, 0xf7, 0xc6, 0x40,
                0x08, 0xd9, 0x81, 0x79, 0x40, 0x8d, 0xba, 0xc2, 0xde, 0xe8, 0x17, 0xba,
                0xde, 0xb6, 0x24, 0x45, 0x2e, 0x64, 0x1c, 0x29, 0xb9, 0x5b, 0x13, 0x96,
                0xee, 0xed, 0xd7, 0x19, 0xbd, 0xb8, 0x92, 0x09, 0x9e, 0x38, 0x07, 0x3a,
                0x9b, 0x1e, 0x74, 0x09, 0x44, 0xe8, 0x34, 0x63, 0xcf, 0x73, 0x7a, 0xd3,
                0xe0, 0x6c, 0xc7, 0xff, 0x82, 0x4b, 0x6b, 0x80, 0x20, 0x3c, 0x13, 0x63,
                0x23, 0x18, 0xdf, 0x2c, 0x7e, 0xe1, 0x6d, 0x6e, 0x33, 0x6a, 0x99, 0xb5,
                0x02, 0x78, 0xe8, 0x7e, 0x0b, 0x2c, 0xf5, 0x0c, 0x4d, 0xb3, 0xf5, 0x0d,
                0x30, 0xd6, 0xad, 0x1b, 0x66, 0xe6, 0x54, 0x14, 0xba, 0xb4, 0x04, 0xfe,
                0x5d, 0xb0, 0xca, 0xdb, 0xda, 0x38, 0xf4, 0xa7, 0x9a, 0x91, 0x44, 0xc5,
                0x59, 0xa8, 0x8e, 0x61, 0xac, 0xae, 0xc9, 0x3e, 0x4f, 0x0e, 0xb9, 0xca,
                0xa2, 0x38, 0x55, 0x37, 0xe9, 0xf9, 0x29, 0x98, 0x3e, 0x50, 0x4b, 0x07,
                0x08, 0x15, 0xbd, 0xd3, 0x79, 0xb0, 0x00, 0x00, 0x00, 0x37, 0x01, 0x00,
                0x00, 0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x08, 0x08, 0x08, 0x00, 0x04,
                0x83, 0x2a, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x6d, 0x65, 0x74, 0x61, 0x64,
                0x61, 0x74, 0x61, 0x2f, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x65,
                0x72, 0x5f, 0x64, 0x65, 0x73, 0x63, 0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x6d,
                0x8c, 0x4d, 0x0a, 0xc2, 0x30, 0x10, 0x46, 0xf7, 0x3d, 0xc5, 0x90, 0xb5,
                0x94, 0x14, 0xc4, 0x85, 0x37, 0x70, 0xe7, 0x0d, 0xc2, 0x98, 0x4c, 0x35,
                0x90, 0x3f, 0x32, 0xb1, 0x28, 0xa5, 0x77, 0x37, 0x46, 0x10, 0x02, 0xdd,
                0x7e, 0xef, 0xbd, 0x6f, 0x1d, 0x00, 0x84, 0x0d, 0x5c, 0xd0, 0x39, 0xca,
                0xca, 0x10, 0x6b, 0xb5, 0x50, 0x66, 0x1b, 0x83, 0x80, 0x33, 0x88, 0x69,
                0x94, 0xe2, 0xd0, 0x3b, 0x36, 0xcc, 0xf1, 0xcb, 0xd6, 0x3a, 0x77, 0x20,
                0xa0, 0xa7, 0x16, 0xfd, 0xa7, 0x91, 0x1f, 0xad, 0xee, 0xb4, 0xf2, 0x4e,
                0x3f, 0xed, 0x86, 0x7b, 0x18, 0xf3, 0x9d, 0x1b, 0xbe, 0x5e, 0x4e, 0x47,
                0x78, 0x26, 0x83, 0x85, 0x64, 0x3d, 0x02, 0x1f, 0xb5, 0x4a, 0x39, 0xce,
                0xd6, 0xd1, 0xee, 0xaf, 0xc7, 0x97, 0x62, 0xd2, 0x31, 0x98, 0xd6, 0x4f,
                0xb2, 0x0a, 0xdb, 0xb0, 0x7d, 0x00, 0x50, 0x4b, 0x07, 0x08, 0x7d, 0x8d,
                0xc5, 0x21, 0x7f, 0x00, 0x00, 0x00, 0xe2, 0x00, 0x00, 0x00, 0x50, 0x4b,
                0x01, 0x02, 0x14, 0x00, 0x14, 0x00, 0x08, 0x08, 0x08, 0x00, 0x04, 0x83,
                0x2a, 0x4d, 0x1f, 0x5b, 0x9b, 0xaf, 0xe7, 0x00, 0x00, 0x00, 0x54, 0x04,
                0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x61, 0x74, 0x61,
                0x2f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x32, 0x2e, 0x73, 0x68, 0x50,
                0x4b, 0x01, 0x02, 0x14, 0x00, 0x14, 0x00, 0x08, 0x08, 0x08, 0x00, 0x04,
                0x83, 0x2a, 0x4d, 0xad, 0x35, 0x22, 0x41, 0x94, 0x00, 0x00, 0x00, 0xde,
                0x01, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x01, 0x00, 0x00, 0x64, 0x61, 0x74,
                0x61, 0x2f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x30, 0x2e, 0x73, 0x68,
                0x50, 0x4b, 0x01, 0x02, 0x14, 0x00, 0x14, 0x00, 0x08, 0x08, 0x08, 0x00,
                0x04, 0x83, 0x2a, 0x4d, 0xda, 0x34, 0xb5, 0x77, 0xe4, 0x00, 0x00, 0x00,
                0x0d, 0x04, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf5, 0x01, 0x00, 0x00, 0x64, 0x61,
                0x74, 0x61, 0x2f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x5f, 0x67, 0x77,
                0x2e, 0x73, 0x68, 0x50, 0x4b, 0x01, 0x02, 0x14, 0x00, 0x14, 0x00, 0x08,
                0x08, 0x08, 0x00, 0x04, 0x83, 0x2a, 0x4d, 0x75, 0x30, 0x2f, 0x48, 0xe1,
                0x00, 0x00, 0x00, 0x54, 0x04, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x03, 0x00,
                0x00, 0x64, 0x61, 0x74, 0x61, 0x2f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65,
                0x31, 0x2e, 0x73, 0x68, 0x50, 0x4b, 0x01, 0x02, 0x14, 0x00, 0x14, 0x00,
                0x08, 0x08, 0x08, 0x00, 0x04, 0x83, 0x2a, 0x4d, 0x29, 0xe7, 0xc2, 0x03,
                0xf4, 0x00, 0x00, 0x00, 0x15, 0x04, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x04,
                0x00, 0x00, 0x64, 0x61, 0x74, 0x61, 0x2f, 0x75, 0x70, 0x64, 0x61, 0x74,
                0x65, 0x5f, 0x65, 0x6e, 0x64, 0x70, 0x74, 0x2e, 0x73, 0x68, 0x50, 0x4b,
                0x01, 0x02, 0x14, 0x00, 0x14, 0x00, 0x08, 0x08, 0x08, 0x00, 0x04, 0x83,
                0x2a, 0x4d, 0x82, 0x8d, 0x45, 0x57, 0xdf, 0x00, 0x00, 0x00, 0x54, 0x04,
                0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x6c, 0x05, 0x00, 0x00, 0x64, 0x61, 0x74, 0x61,
                0x2f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x33, 0x2e, 0x73, 0x68, 0x50,
                0x4b, 0x01, 0x02, 0x14, 0x00, 0x14, 0x00, 0x08, 0x08, 0x08, 0x00, 0x04,
                0x83, 0x2a, 0x4d, 0x7f, 0x75, 0x1e, 0x1b, 0xe3, 0x00, 0x00, 0x00, 0x54,
                0x04, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x06, 0x00, 0x00, 0x64, 0x61, 0x74,
                0x61, 0x2f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x34, 0x2e, 0x73, 0x68,
                0x50, 0x4b, 0x01, 0x02, 0x14, 0x00, 0x14, 0x00, 0x08, 0x08, 0x08, 0x00,
                0x04, 0x83, 0x2a, 0x4d, 0x66, 0xb5, 0x3a, 0x24, 0x54, 0x04, 0x00, 0x00,
                0x31, 0x0e, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa8, 0x07, 0x00, 0x00, 0x6d, 0x65,
                0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2f, 0x69, 0x6e, 0x73, 0x74, 0x61,
                0x6c, 0x6c, 0x65, 0x72, 0x2e, 0x73, 0x68, 0x50, 0x4b, 0x01, 0x02, 0x14,
                0x00, 0x14, 0x00, 0x08, 0x08, 0x08,
          0x04, 0x81, 0x9d,  /* OCTET_STRING (3) = 157 */
                0x00, 0x04, 0x83,
                0x2a, 0x4d, 0x15, 0xbd, 0xd3, 0x79, 0xb0, 0x00, 0x00, 0x00, 0x37, 0x01,
                0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x3f, 0x0c, 0x00, 0x00, 0x6d, 0x65, 0x74, 0x61,
                0x64, 0x61, 0x74, 0x61, 0x2f, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65,
                0x5f, 0x64, 0x65, 0x73, 0x63, 0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x50, 0x4b,
                0x01, 0x02, 0x14, 0x00, 0x14, 0x00, 0x08, 0x08, 0x08, 0x00, 0x04, 0x83,
                0x2a, 0x4d, 0x7d, 0x8d, 0xc5, 0x21, 0x7f, 0x00, 0x00, 0x00, 0xe2, 0x00,
                0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x37, 0x0d, 0x00, 0x00, 0x6d, 0x65, 0x74, 0x61,
                0x64, 0x61, 0x74, 0x61, 0x2f, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c,
                0x65, 0x72, 0x5f, 0x64, 0x65, 0x73, 0x63, 0x2e, 0x6a, 0x73, 0x6f, 0x6e,
                0x50, 0x4b, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x0a, 0x00,
                0x87, 0x02, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00,  /* EOC */
        0x00, 0x00  /* EOC */
    };

    MAsn1TypeAndCount def[2] =
    {
      {  MASN1_TYPE_SEQUENCE | MASN1_IMPLICIT, 1 },
        {  MASN1_TYPE_OCTET_STRING | MASN1_TYPE_INDEF_BIT , 0 },
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 2, MASN1_FNCT_DECODE, NULL, &pRoot);
    retval += UNITTEST_STATUS(hint, status);
    if (retval > 0)
        goto exit;

    /* Decode data using chunks of size 'chunkSize' */
    status = DIGI_MALLOC ((void**) &buf, chunkSize);
    retval += UNITTEST_STATUS(hint + 9, status);
    if (retval > 0)
        goto exit;

    while (!done && (sizeof(encoded) > copied))
    {
        ubyte4 newData;
        ubyte4 bytesRead;

        /* Copy next chunk or the final byte(s) */
        if (chunkSize < (sizeof(encoded) - copied))
        {
            newData = chunkSize;
        }
        else
        {
            newData = sizeof(encoded) - copied;
        }
        DIGI_MEMCPY (buf, encoded + copied, newData);
        copied += newData;

        /* Decode from memory array */
        status = MAsn1DecodeIndefiniteUpdateFlag (buf, newData, MASN1_DECODE_UPDATE,
                                                  pRoot,
                                                  TestSeqDataReturn,
                                                  (void *) &returnInfo,
                                                  &bytesRead,
                                                  &done);
        retval += UNITTEST_STATUS(hint + 10, status);
        if (retval > 0)
        {
            printf("Failed1 @%d\n", copied);
            goto exit;
        }
    }

    /* Check state */
    retval += UNITTEST_TRUE(hint + 11, FALSE==done);
    if (retval > 0)
        goto exit;

    /* Check number of octet data read so far */
    retval += UNITTEST_INT(hint + 12, returnInfo.len, 24);
    if (retval > 0)
        goto exit;

    /* Cleanup memory */
    DIGI_FREE((void**)&buf);
    FreeTestDataReturn (&returnInfo);
    MAsn1FreeElementArray (&pRoot);

    /* SECOND TEST ARRAY */
    DIGI_MEMSET((ubyte*)&returnInfo, 0, sizeof(returnInfo));
    done = 0;
    copied = 0;

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 2, MASN1_FNCT_DECODE, NULL, &pRoot);
    retval += UNITTEST_STATUS(hint+20, status);
    if (retval > 0)
        goto exit;

    /* Decode data using chunks of size 'chunkSize' */
    status = DIGI_MALLOC ((void**) &buf, chunkSize);
    retval += UNITTEST_STATUS(hint + 29, status);
    if (retval > 0)
        goto exit;

    while (!done && (sizeof(encoded2) > copied))
    {
        ubyte4 newData;
        ubyte4 bytesRead;

        /* Copy next chunk or the final byte(s) */
        if (chunkSize < (sizeof(encoded2) - copied))
        {
            newData = chunkSize;
        }
        else
        {
            newData = sizeof(encoded2) - copied;
        }
        DIGI_MEMCPY (buf, encoded2 + copied, newData);
        copied += newData;

        /* Decode from memory array */
        status = MAsn1DecodeIndefiniteUpdateFlag (buf, newData, MASN1_DECODE_UPDATE,
                                                  pRoot,
                                                  TestSeqDataReturn,
                                                  (void *) &returnInfo,
                                                  &bytesRead,
                                                  &done);
        retval += UNITTEST_STATUS(hint + 20, status);
        if (retval > 0)
        {
            printf("Failed2 @%d\n", copied);
            goto exit;
        }
    }

    /* Check state */
    retval += UNITTEST_TRUE(hint + 21, done);
    if (retval > 0)
        goto exit;

    /* Check number of octet data read so far */
    retval += UNITTEST_INT(hint + 22, returnInfo.len, 2048+2048+157);
    if (retval > 0)
        goto exit;

exit:
    /* Cleanup memory */
    DIGI_FREE((void**)&buf);
    FreeTestDataReturn (&returnInfo);
    MAsn1FreeElementArray (&pRoot);
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_MAsn1Element_indefOctetChunked()
{
    int retval = 0;
    ubyte4 cLen = 1;

    while (cLen < 4096)
    {
        retval = read_indefOctet_chunked(cLen);
        if (retval > 0)
        {
            printf("Failed @%d\n", cLen);
            goto exit;
        }

        cLen += 1;
    }

exit:
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_Signature()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    ubyte* pCert = NULL;
    ubyte4 certLen;
    ubyte4 bytesRead;
    const char* fileName = "signature_eof_pb.der";

    /* Sequence with OID and octet */
    MAsn1TypeAndCount def[5] =
    {
            { MASN1_TYPE_SEQUENCE, 2 },
            { MASN1_TYPE_SEQUENCE, 2 },
            { MASN1_TYPE_OID, 0 },
            { MASN1_TYPE_ENCODED | MASN1_OPTIONAL, 0 },
            { MASN1_TYPE_OCTET_STRING, 0 }
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 5, MASN1_FNCT_DECODE, NULL, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Read data from file */
    status = DIGICERT_readFile(fileName, &pCert, &certLen);
    retval += UNITTEST_STATUS(10, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array */
    status = MAsn1Decode (pCert, certLen, pRoot, &bytesRead);
    retval += UNITTEST_STATUS(0, status);

exit:
    /* Cleanup memory */
    if (NULL != pCert)
    {
        DIGI_FREE ((void **) &pCert);
    }

    MAsn1FreeElementArray (&pRoot);
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_NestedDecoding()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    MAsn1Element* pRoot2 = NULL;
    ubyte* pCert = NULL;
    ubyte4 certLen;
    ubyte4 bytesRead;
    ubyte4 bytesRead2;

    const char* fileName = "server1cert.der";

    /* Sequence with encoded data and a BIT_STRING */
    MAsn1TypeAndCount def[4] =
    {
            { MASN1_TYPE_SEQUENCE, 3 },
            { MASN1_TYPE_ENCODED, 0 },
            { MASN1_TYPE_ENCODED, 0 },
            { MASN1_TYPE_BIT_STRING, 0 }
    };

    MAsn1TypeAndCount def2[3] =
    {
            { MASN1_TYPE_SEQUENCE, 2 },
            { MASN1_TYPE_INTEGER, 0 },
            { MASN1_TYPE_INTEGER, 0 }
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 4, MASN1_FNCT_DECODE, NULL, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Read data from file */
    status = DIGICERT_readFile(fileName, &pCert, &certLen);
    retval += UNITTEST_STATUS(10, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array */

    status = MAsn1Decode (pCert, certLen, pRoot, &bytesRead);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Set up decoding of sub-element [3]:
     *  sequence with two INTEGER values */
    status = MAsn1CreateElementArray (def2, 3, MASN1_FNCT_DECODE, NULL,
                                      &pRoot2);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array */
    status = MAsn1Decode (pRoot[3].value.pValue + 1, pRoot[3].valueLen, pRoot2,
                          &bytesRead2);
    retval += UNITTEST_STATUS(0, status);

exit:
    /* Cleanup memory */
    if (NULL != pCert)
    {
        DIGI_FREE ((void **) &pCert);
    }
    MAsn1FreeElementArray (&pRoot2);
    MAsn1FreeElementArray (&pRoot);
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_ChunkedDecoding()
{
    MSTATUS status;
    int retval = 0;

    MAsn1Element* pRoot = NULL;
    intBoolean finished = 0;
    ubyte4 bytesRead;
    ubyte buf[1];
    ubyte4 idx;

    /* input data */
    ubyte encoded[] =
            { 0x30, 0x82, 0x01, 0x0E,
                    0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x02,
                    0x86, 0x82, 0x01, 0x00,
                    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
                    0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
                    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
                    0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
                    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
                    0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
                    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
                    0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
                    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
                    0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
                    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
                    0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
                    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
                    0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
                    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
                    0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
                    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
                    0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
                    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
                    0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
                    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
                    0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
                    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
                    0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
                    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
                    0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
                    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
                    0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
                    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
                    0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
                    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
                    0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
            };

    /* Test sequence with OID and tagged '[6]' byte array (string) */
    MAsn1TypeAndCount def[3] =
    {
            { MASN1_TYPE_SEQUENCE, 2 },
            { MASN1_TYPE_OID, 0 },
            { MASN1_TYPE_OCTET_STRING | MASN1_IMPLICIT | 6, 0 },
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 3, MASN1_FNCT_DECODE, NULL, &pRoot);
    retval += UNITTEST_STATUS(0, status);
    if (retval > 0)
        goto exit;

    /* Sanity check of encoded data */
    status = MAsn1DecodeUpdateFlag (encoded, sizeof(encoded), MASN1_DECODE_UPDATE,
                                    pRoot, &bytesRead, &finished);
    retval += UNITTEST_STATUS(1, status);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(2, bytesRead, sizeof(encoded));
    if (retval > 0)
        goto exit;

    retval += UNITTEST_TRUE(9, finished);
    if (retval > 0)
        goto exit;

    MAsn1FreeElementArray (&pRoot);

    /* Now, chunk the encoded data */
    status = MAsn1CreateElementArray (def, 3, MASN1_FNCT_DECODE, NULL, &pRoot);
    retval += UNITTEST_STATUS(3, status);
    if (retval > 0)
        goto exit;

    finished = 0;

    for (idx = 0; idx < sizeof(encoded); ++idx)
    {
        ubyte4 bytesRead;

        /* Decode next chunk */
        buf[0] = encoded[idx];

        status = MAsn1DecodeUpdateFlag (buf, 1, MASN1_DECODE_UPDATE,
                                        pRoot, &bytesRead, &finished);
        retval += UNITTEST_STATUS(11 + 100 * idx, status);
        if (retval > 0)
            goto exit;

        retval += UNITTEST_INT(12, bytesRead, 1);
        if (retval > 0)
            goto exit;
    }

    retval += UNITTEST_TRUE(19, finished);

exit:
    MAsn1FreeElementArray (&pRoot);
    return retval;
}


/*----------------------------------------------------------------------*/

static int
read_ca_chunked(ubyte4 chunkSize,
                ubyte** ppKeepData,
                ubyte4* pKeepDataLen)
{
    MSTATUS status;
    int retval = 0;

    ubyte4 hint = 100 * chunkSize;
    ubyte* pKeepData = *ppKeepData = NULL;
    ubyte4 keepDataLen = *pKeepDataLen = 0;
    ubyte* pCert = NULL;
    ubyte4 certLen;
    ubyte* buf = NULL;

    MAsn1Element* pRoot = NULL;
    MAsn1Element* pRoot2 = NULL;

    ubyte4 copied = 0;

    intBoolean keepDone = 0;
    intBoolean finished = 0;
    ubyte* tmpData = NULL;
    ubyte4 tmpDataLen = 0;
    ubyte4 bytesRead2;
    sbyte4 cmpResult;

    const char* fileName = "motorola_ca.der";

    /* Sequence with encoded data and a BIT_STRING */
    MAsn1TypeAndCount def[4] =
    {
            { MASN1_TYPE_SEQUENCE, 3 },
            { MASN1_TYPE_ENCODED, 0 },
            { MASN1_TYPE_ENCODED, 0 },
            { MASN1_TYPE_BIT_STRING, 0 }
    };

    MAsn1TypeAndCount def2[3] =
    {
            { MASN1_TYPE_SEQUENCE, 2 },
            { MASN1_TYPE_OID, 0 },
            { MASN1_TYPE_ENCODED | MASN1_OPTIONAL, 0 }
    };

    /* Create the 'array' root */
    status = MAsn1CreateElementArray (def, 4, MASN1_FNCT_DECODE, NULL, &pRoot);
    retval += UNITTEST_STATUS(hint, status);
    if (retval > 0)
        goto exit;

    /* Read data from file */
    status = DIGICERT_readFile(fileName, &pCert, &certLen);
    retval += UNITTEST_STATUS(hint + 10, status);
    if (retval > 0)
        goto exit;

    /* Do not run test for large chunk sizes */
    if (chunkSize > certLen)
    {
        goto exit;
    }

    /* Decode data using chunks of size 'chunkSize' */
    status = DIGI_MALLOC ((void**) &buf, chunkSize);
    retval += UNITTEST_STATUS(hint + 99, status);
    if (retval > 0)
        goto exit;

    while ((FALSE == finished) && (certLen > copied))
    {
        ubyte4 newData;
        ubyte4 bytesRead;

        /* Copy next chunk or the final byte(s) */
        if (chunkSize < (certLen - copied))
        {
            newData = chunkSize;
        }
        else
        {
            newData = certLen - copied;
        }
        DIGI_MEMCPY (buf, pCert + copied, newData);
        copied += newData;

        /* Decode next chunk */
        status = MAsn1DecodeUpdateFlag (buf, newData, MASN1_DECODE_UPDATE,
                                        pRoot, &bytesRead, &finished);
        retval += UNITTEST_STATUS(hint + 11, status);
        if (retval > 0)
            goto exit;

        /* Any data arrived at sequence [2]? */
        if ((NULL != pRoot[2].value.pValue) &&
            (pRoot[2].state < MASN1_STATE_DECODE_LEN))
        {
            /* Save in temp space until we have the correct encoding length */
            if (tmpData == NULL)
            {
                DIGI_MALLOC ((void**)&tmpData, 16);
                tmpDataLen = 0;
            }
            DIGI_MEMCPY (tmpData + tmpDataLen, pRoot[2].value.pValue,
                        pRoot[2].valueLen);
            tmpDataLen += pRoot[2].valueLen;
        }
        else if ((NULL != pRoot[2].value.pValue) &&
                 (pRoot[2].state < MASN1_STATE_DECODE_COMPLETE))
        {
            /* Save in area until this ASN.1 element is complete. The size
             * of the buffer can now be set to the length of the encoding. */
            ubyte* storeAt = NULL;

            if (NULL == pKeepData)
            {
                keepDataLen = pRoot[2].encodingLen;

                status = DIGI_MALLOC ((void**) &pKeepData, keepDataLen);
                retval += UNITTEST_STATUS(hint + 98, status);
                if (retval > 0)
                    goto exit;

                if (NULL != tmpData)
                {
                    DIGI_MEMCPY (pKeepData, tmpData, tmpDataLen);

                    FREE (tmpData);
                    tmpData = NULL;
                    tmpDataLen = 0;
                }
            }

            storeAt = pKeepData
                    + (keepDataLen - pRoot[2].buffer.remaining
                       - pRoot[2].valueLen);
            DIGI_MEMCPY (storeAt, pRoot[2].value.pValue, pRoot[2].valueLen);
        }
        else if ((FALSE == keepDone) &&
                 (MASN1_STATE_DECODE_COMPLETE == pRoot[2].state))
        {
            /* Complete the data in the 'save area' so we can parse it later. */
            ubyte* storeAt = NULL;

            if (NULL == pKeepData)
            {
                keepDataLen = pRoot[2].encodingLen;

                status = DIGI_MALLOC ((void**) &pKeepData, keepDataLen);
                retval += UNITTEST_STATUS(hint + 999, status);
                if (retval > 0)
                    goto exit;

                if (NULL != tmpData)
                {
                    DIGI_MEMCPY (pKeepData, tmpData, tmpDataLen);

                    FREE (tmpData);
                    tmpData = NULL;
                    tmpDataLen = 0;
                }
            }

            storeAt = pKeepData
                    + (keepDataLen - pRoot[2].buffer.remaining
                       - pRoot[2].valueLen);
            DIGI_MEMCPY (storeAt, pRoot[2].value.pValue, pRoot[2].valueLen);
            keepDone = 1;
        }
    }

    /* Did we fully capture encoded sequence [2]?*/
    retval += UNITTEST_INT(hint + 12, keepDone, 1);
    if (retval > 0)
        goto exit;

    /* Set up decoding of sub-element [2]:
     *  sequence with an OID and optional encoded value */
    status = MAsn1CreateElementArray (def2, 3, MASN1_FNCT_DECODE, NULL,
                                      &pRoot2);
    retval += UNITTEST_STATUS(hint + 30, status);
    if (retval > 0)
        goto exit;

    /* Decode from memory array in 'save area' */
    status = MAsn1Decode (pKeepData, keepDataLen, pRoot2, &bytesRead2);
    retval += UNITTEST_STATUS(hint + 40, status);
    if (retval > 0)
        goto exit;

    /* Found the correct OID? */
    status = ASN1_compareOID (SHA1_WITH_RSA_ENCR, SHA1_WITH_RSA_ENCR_LEN,
                              pRoot2[1].encoding.pEncoding,
                              pRoot2[1].encodingLen, NULL, &cmpResult);
    retval += UNITTEST_STATUS(hint + 41, status);
    if (retval > 0)
        goto exit;

    retval += UNITTEST_INT(hint + 15, cmpResult, 0);
    if (retval > 0)
        goto exit;

    /* Let memory go back to caller */
    *ppKeepData = pKeepData;
    pKeepData = NULL;

exit:
    /* Cleanup memory */
    DIGI_FREE ((void **) &pKeepData);
    DIGI_FREE ((void **) &pCert);
    DIGI_FREE ((void **) &buf);
    MAsn1FreeElementArray (&pRoot2);
    MAsn1FreeElementArray (&pRoot);
    return retval;
}


/*----------------------------------------------------------------------*/

int mocdecode_test_CA_ChunkedDecoding()
{
    int retval = 0;
    ubyte4 cLen = 1;

    while (cLen < 1024)
    {
        ubyte* pKeepData = NULL;
        ubyte4 keepDataLen = 0;

        retval += read_ca_chunked (cLen, &pKeepData, &keepDataLen);
        if (retval > 0)
            goto exit;

        DIGI_FREE ((void **) &pKeepData);
        cLen += 1;
    }

exit:
    return retval;
}
