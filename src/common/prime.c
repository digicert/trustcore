/*
 * prime.c
 *
 * Prime Factory
 *
 * Copyright 2025 DigiCert Project Authors. All Rights Reserved.
 * 
 * DigiCert® TrustCore and TrustEdge are licensed under a dual-license model:
 * - **Open Source License**: GNU AGPL v3. See: https://github.com/digicert/trustcore-test/blob/main/LICENSE
 * - **Commercial License**: Available under DigiCert’s Master Services Agreement. See: https://github.com/digicert/trustcore-test/blob/main/LICENSE_COMMERCIAL.txt  
 *   or https://www.digicert.com/master-services-agreement/
 * 
 * For commercial licensing, contact DigiCert at sales@digicert.com.*
 *
 */

#include "../common/moptions.h"
#include "../common/mtypes.h"
#include "../common/mocana.h"
#include "../crypto/hw_accel.h"
#include "../common/mdefs.h"
#include "../common/merrors.h"
#include "../common/mstdlib.h"
#include "../common/mrtos.h"
#include "../common/random.h"
#include "../common/vlong.h"
#include "../common/lucas.h"
#include "../common/prime.h"
#include "../common/memory_debug.h"

/*------------------------------------------------------------------*/

#ifndef __DISABLE_DIGICERT_PRIME_TEST__

static ubyte m_primeTable[] =
{   3,   5,   7,  11,  13,  17,  19,  23,  29,  31,  37,  41,  43,  47,  53,  59,
   61,  67,  71,  73,  79,  83,  89,  97, 101, 103, 107, 109, 113, 127, 131, 137,
  139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227,
  229, 233, 239, 241, 251 };

#define SIZEOF_PRIME_TABLE  (sizeof(m_primeTable) / sizeof(ubyte))

#endif /* __DISABLE_DIGICERT_PRIME_TEST__ */

/* based on the size of the prime, we determine the number of rounds necessary */
#ifndef NUM_PRIME_ATTEMPTS_GREATER_512
#define NUM_PRIME_ATTEMPTS_GREATER_512      8
#endif

#ifndef NUM_PRIME_ATTEMPTS_LESS_512
#define NUM_PRIME_ATTEMPTS_LESS_512         28
#endif


/*------------------------------------------------------------------*/

#ifndef __DISABLE_DIGICERT_PRIME_TEST__

static const ubyte m_primeNibbleDiffTable[] =
{
    /* this table is a compacted trial divsion table, which has been compacted from a ubyte4 lookup table (26168 bytes) to nibble diff table (~3310 bytes) */
    /* each nibble (left to right) is a compressed diff to next prime. diff = (nibble * 2) + 2. the table may have composites as diff can be greater than 32 (suitable for trial division) */
    /* to manually trace the table, (note: starting point is 3), 3 + (0 * 2) + 2 = 5, 5 + (0 * 2) + 2 = 7, 7 + (1 * 2) + 2 = 11, .... */
    0x00, 0x10, 0x10, 0x12, 0x02, 0x10, 0x12, 0x20, 0x21, 0x02, 0x12, 0x31, 0x01, 0x01, 0x61, 0x20, 0x40, 0x22, 0x12, 0x20, 0x40, 0x10, 0x55, 0x10, 0x12, 0x04, 0x22, 0x20, 0x21, 0x04, 0x61, 0x01,
    0x62, 0x40, 0x12, 0x32, 0x21, 0x23, 0x13, 0x40, 0x40, 0x21, 0x23, 0x10, 0x15, 0x31, 0x31, 0x25, 0x08, 0x24, 0x22, 0x02, 0x42, 0x20, 0x22, 0x10, 0x54, 0x01, 0x22, 0x05, 0x12, 0x34, 0x34, 0x32,
    0x21, 0x32, 0x13, 0x16, 0x45, 0x04, 0x01, 0x04, 0x61, 0x01, 0x61, 0x01, 0x91, 0x34, 0x31, 0x22, 0x61, 0x22, 0x32, 0x51, 0x20, 0x40, 0x24, 0x04, 0x02, 0x81, 0x01, 0x22, 0x32, 0x2a, 0x04, 0x34,
    0x22, 0x35, 0x12, 0x20, 0x25, 0x48, 0x01, 0x20, 0x21, 0x01, 0x50, 0x2f, 0x02, 0x23, 0x84, 0x61, 0x01, 0x23, 0x10, 0x25, 0x40, 0x10, 0x12, 0x55, 0x35, 0x21, 0x23, 0x13, 0x16, 0x12, 0x01, 0x20,
    0x24, 0x92, 0x10, 0xb1, 0x04, 0x50, 0x43, 0x22, 0x28, 0x21, 0x05, 0x45, 0x37, 0x62, 0x10, 0x10, 0x45, 0x22, 0x80, 0x70, 0xa2, 0x32, 0x10, 0x13, 0x24, 0x04, 0x64, 0x25, 0x01, 0x04, 0x50, 0x70,
    0x21, 0x04, 0x38, 0xb1, 0x23, 0x70, 0x13, 0x70, 0x13, 0x22, 0x15, 0x0a, 0x20, 0x21, 0x26, 0x21, 0x02, 0x12, 0x52, 0x26, 0x12, 0x53, 0x21, 0xc8, 0x43, 0x12, 0x02, 0xa5, 0x07, 0x31, 0x56, 0x40,
    0x13, 0x22, 0x10, 0x12, 0x31, 0x02, 0x40, 0x43, 0x16, 0x45, 0x02, 0x10, 0x76, 0x12, 0x32, 0x18, 0x34, 0x22, 0x34, 0x56, 0x12, 0x20, 0xd0, 0x43, 0x16, 0x13, 0x52, 0x51, 0x29, 0x40, 0x7c, 0x10,
    0x52, 0x15, 0x23, 0x13, 0xa0, 0x10, 0x5d, 0x02, 0x22, 0x12, 0x05, 0x15, 0x04, 0x07, 0x07, 0x29, 0x73, 0x10, 0x10, 0xa3, 0x52, 0x40, 0x12, 0x02, 0x40, 0x54, 0x04, 0x62, 0x12, 0x32, 0x27, 0x50,
    0x16, 0x21, 0x34, 0x32, 0x2a, 0x20, 0x46, 0x12, 0x80, 0x46, 0x10, 0x46, 0x13, 0x81, 0x20, 0x12, 0x05, 0x19, 0xa5, 0x01, 0x22, 0x02, 0xa0, 0x27, 0x25, 0x02, 0x57, 0x01, 0x26, 0x10, 0x8b, 0x42,
    0x04, 0x04, 0x04, 0x20, 0x40, 0x42, 0x3e, 0x40, 0x43, 0x24, 0x82, 0x55, 0x08, 0x21, 0x22, 0x80, 0x46, 0x21, 0x01, 0xb0, 0x52, 0x73, 0x22, 0x87, 0x01, 0x20, 0x22, 0x42, 0x55, 0x80, 0x21, 0x83,
    0xb1, 0x01, 0x20, 0x51, 0x6e, 0x42, 0x56, 0x24, 0x50, 0x12, 0x32, 0x40, 0x16, 0x22, 0x12, 0x04, 0x07, 0x53, 0x81, 0x25, 0x02, 0x22, 0xd2, 0x61, 0x34, 0x35, 0x81, 0x01, 0xb5, 0x20, 0x72, 0x26,
    0x46, 0x1e, 0x22, 0x23, 0x21, 0x05, 0x21, 0x02, 0xa2, 0x01, 0x80, 0x15, 0x02, 0x1c, 0x22, 0x13, 0x4f, 0x70, 0x21, 0x01, 0x04, 0x62, 0x13, 0x42, 0x91, 0x02, 0xe1, 0x34, 0x22, 0x32, 0x51, 0x20,
    0x21, 0x20, 0x40, 0x72, 0x91, 0x56, 0xd2, 0x91, 0x83, 0x21, 0x26, 0x22, 0x40, 0x45, 0x34, 0x04, 0x35, 0x4b, 0x01, 0x32, 0x13, 0x84, 0x22, 0x02, 0x45, 0x04, 0x22, 0x23, 0x24, 0x20, 0x22, 0x24,
    0x3b, 0x2a, 0x08, 0x13, 0x4e, 0x38, 0x10, 0x42, 0x02, 0x18, 0x35, 0x87, 0x20, 0x52, 0x40, 0x40, 0x24, 0x61, 0xb0, 0x70, 0x40, 0x49, 0x10, 0x13, 0x72, 0x20, 0x57, 0x31, 0x2e, 0x04, 0x02, 0x12,
    0x23, 0x21, 0x52, 0x35, 0x16, 0x54, 0xb2, 0x52, 0x0a, 0x38, 0x42, 0x61, 0x02, 0x43, 0x21, 0x2e, 0x64, 0x05, 0x40, 0x70, 0x8b, 0x82, 0x78, 0x20, 0x81, 0x20, 0x43, 0x42, 0x23, 0x12, 0x04, 0x05,
    0x12, 0x20, 0x51, 0x68, 0x12, 0x91, 0x32, 0x13, 0x16, 0x21, 0x65, 0x10, 0xe1, 0xb2, 0x25, 0x56, 0x21, 0x01, 0x82, 0x53, 0x21, 0x50, 0x5e, 0x70, 0x2a, 0x62, 0x45, 0x20, 0x13, 0x42, 0x2b, 0x62,
    0x13, 0x58, 0x40, 0x40, 0x12, 0x92, 0x16, 0x10, 0x16, 0x25, 0xb4, 0x23, 0x40, 0xe1, 0x20, 0x51, 0x62, 0xf0, 0x53, 0x24, 0x01, 0x94, 0x37, 0x04, 0x61, 0x05, 0x27, 0x23, 0x13, 0x12, 0x32, 0x25,
    0x21, 0x22, 0x38, 0x19, 0x15, 0x04, 0x20, 0x45, 0x01, 0x92, 0xe2, 0x13, 0x45, 0x20, 0xd0, 0x21, 0x07, 0x50, 0x24, 0x3b, 0x52, 0x82, 0x16, 0x21, 0x53, 0x25, 0x12, 0x52, 0x50, 0x79, 0x10, 0x48,
    0x31, 0x61, 0x02, 0xa2, 0x62, 0x24, 0x20, 0x40, 0x10, 0xa0, 0x12, 0x25, 0x26, 0x45, 0x23, 0x1f, 0x16, 0x52, 0x12, 0x05, 0x25, 0x70, 0x43, 0xa0, 0x52, 0x12, 0x80, 0x52, 0x15, 0x32, 0x51, 0x25,
    0x20, 0x55, 0x16, 0x27, 0x20, 0x43, 0x82, 0xf0, 0x0d, 0x0a, 0x20, 0x45, 0x02, 0x13, 0xa2, 0x04, 0x31, 0x23, 0x15, 0x85, 0x91, 0x22, 0x31, 0x07, 0x50, 0x43, 0x40, 0x12, 0x65, 0xa3, 0xd0, 0x19,
    0x10, 0x16, 0x45, 0x05, 0x70, 0xd3, 0xa3, 0x12, 0x26, 0x13, 0x52, 0x21, 0x91, 0x80, 0x52, 0x12, 0x68, 0x43, 0x4f, 0x24, 0x22, 0x02, 0x72, 0x05, 0x2d, 0x04, 0x37, 0x23, 0x24, 0xb9, 0x40, 0x40,
    0x51, 0x29, 0x10, 0x58, 0x40, 0x40, 0x19, 0x7c, 0x13, 0x21, 0x52, 0x35, 0x52, 0x13, 0xa0, 0x76, 0x42, 0x55, 0x62, 0x19, 0x15, 0x20, 0x22, 0x73, 0xa0, 0xd3, 0x21, 0x91, 0x5b, 0x91, 0x34, 0x07,
    0x05, 0x5f, 0x00, 0x12, 0x52, 0x23, 0x21, 0x02, 0xb1, 0x94, 0x22, 0x61, 0x22, 0x05, 0x24, 0x04, 0x29, 0x1c, 0x10, 0x2a, 0x0b, 0x12, 0x01, 0x2b, 0x23, 0x10, 0xf0, 0x23, 0x75, 0x04, 0x04, 0x23,
    0x13, 0x5a, 0x26, 0x1c, 0x10, 0x54, 0x31, 0x35, 0x16, 0x27, 0x23, 0x12, 0x23, 0x24, 0x50, 0x22, 0x73, 0x22, 0x54, 0x02, 0x81, 0x22, 0x25, 0x83, 0x24, 0x38, 0x16, 0x28, 0x43, 0x45, 0x02, 0x55,
    0xf1, 0x12, 0x31, 0x20, 0x18, 0x52, 0x32, 0x21, 0x80, 0x10, 0xb1, 0x22, 0x6e, 0x21, 0x25, 0x29, 0x13, 0x13, 0x22, 0x1e, 0x04, 0x53, 0x43, 0xb2, 0x51, 0x61, 0x20, 0xd6, 0x70, 0x52, 0x19, 0x42,
    0x22, 0x34, 0x56, 0x46, 0x76, 0x46, 0x27, 0x23, 0x27, 0x94, 0x02, 0x10, 0x15, 0x04, 0x02, 0xa2, 0x01, 0x83, 0x43, 0xa0, 0x48, 0x61, 0x01, 0x80, 0x12, 0x34, 0x0e, 0x1e, 0x04, 0x08, 0x18, 0x26,
    0x40, 0x19, 0xf1, 0x21, 0x26, 0x19, 0x46, 0xa2, 0x0e, 0x54, 0x80, 0x16, 0x2a, 0x80, 0x52, 0x13, 0x13, 0x24, 0x05, 0x84, 0x67, 0x61, 0x22, 0x02, 0x10, 0xd0, 0xd2, 0x01, 0x26, 0x15, 0x67, 0x61,
    0x23, 0x21, 0x22, 0x23, 0x13, 0x16, 0x73, 0x21, 0x53, 0x70, 0x43, 0x12, 0xc2, 0x43, 0x12, 0x56, 0xe1, 0x6a, 0x35, 0x12, 0x34, 0x26, 0x42, 0x04, 0x55, 0x62, 0x28, 0x42, 0x38, 0x12, 0x02, 0x40,
    0x43, 0x22, 0x40, 0x84, 0x05, 0x12, 0x34, 0x56, 0x51, 0x34, 0x22, 0x91, 0x67, 0x64, 0x34, 0x50, 0x82, 0x54, 0x50, 0x10, 0x52, 0x13, 0x1f, 0x51, 0x01, 0x04, 0x52, 0x26, 0x12, 0x22, 0x32, 0xf1,
    0x81, 0x20, 0x52, 0x22, 0x16, 0xa5, 0x08, 0x42, 0xcb, 0x10, 0x10, 0x16, 0x12, 0x23, 0x75, 0x0f, 0x41, 0x01, 0xb2, 0x20, 0x81, 0x62, 0xd8, 0x62, 0x45, 0x02, 0x5e, 0x21, 0x22, 0x61, 0x0b, 0x12,
    0x2c, 0x48, 0x23, 0x22, 0xe1, 0x55, 0x07, 0x02, 0x15, 0x80, 0x21, 0xc5, 0x25, 0x1b, 0xb5, 0x20, 0x5d, 0x31, 0x25, 0x08, 0x21, 0x22, 0x97, 0x02, 0x28, 0x42, 0x01, 0x32, 0x2b, 0x72, 0x34, 0x26,
    0xa3, 0x72, 0x05, 0x10, 0xa3, 0x8f, 0x00, 0x28, 0x12, 0x23, 0x43, 0x82, 0x10, 0x13, 0x70, 0x55, 0x28, 0x12, 0x22, 0x02, 0x54, 0x95, 0x81, 0x20, 0x70, 0x46, 0x1e, 0x04, 0x50, 0xb2, 0x73, 0x40,
    0x5a, 0x20, 0x79, 0x40, 0x55, 0x84, 0x52, 0x04, 0x02, 0x48, 0x05, 0x21, 0x20, 0xbd, 0x01, 0x04, 0x07, 0x53, 0xa0, 0x21, 0x04, 0x29, 0x54, 0x35, 0x22, 0x21, 0x80, 0x15, 0x80, 0x52, 0x10, 0x75,
    0x56, 0x13, 0x81, 0x56, 0x22, 0x13, 0x21, 0x95, 0x46, 0x10, 0x70, 0x5e, 0x12, 0xb9, 0xb4, 0x35, 0x45, 0x25, 0x52, 0x37, 0x62, 0x12, 0xf1, 0x94, 0xe5, 0x01, 0x0d, 0x56, 0x2a, 0x31, 0x82, 0x68,
    0x12, 0x02, 0xf0, 0x80, 0x72, 0x80, 0xb1, 0x02, 0x52, 0x54, 0x32, 0x75, 0x34, 0x6f, 0x32, 0x02, 0x15, 0x61, 0x01, 0x01, 0x32, 0x42, 0x20, 0x22, 0x25, 0x2b, 0x40, 0x42, 0x52, 0x26, 0x22, 0xf9,
    0x92, 0x40, 0x43, 0x45, 0x50, 0x21, 0x67, 0x35, 0x2a, 0x04, 0x32, 0xa0, 0xa2, 0x34, 0x55, 0x04, 0x25, 0x01, 0x64, 0x02, 0x81, 0x53, 0x85, 0x22, 0x12, 0x26, 0x10, 0x55, 0x12, 0x88, 0x50, 0x75,
    0x38, 0x4c, 0x12, 0x32, 0x21, 0x04, 0x91, 0x23, 0x19, 0x40, 0xf0, 0x01, 0xb0, 0x55, 0x42, 0x05, 0xe2, 0x57, 0x50, 0xa8, 0x56, 0x40, 0x55, 0x10, 0x12, 0x50, 0x78, 0x0f, 0x33, 0x72, 0x34, 0x01,
    0x83, 0x43, 0x51, 0x80, 0x84, 0x01, 0x01, 0x3d, 0x02, 0xa5, 0x26, 0x81, 0x23, 0x22, 0x43, 0x10, 0x84, 0x29, 0xa3, 0x2e, 0x10, 0x18, 0x2e, 0x01, 0x32, 0x12, 0x56, 0xf0, 0x62, 0x10, 0x21, 0x61,
    0x02, 0xd0, 0x12, 0x34, 0x04, 0x04, 0x01, 0xe0, 0x55, 0x48, 0x56, 0x40, 0x52, 0x42, 0x65, 0x16, 0x18, 0x04, 0x31, 0x34, 0x58, 0x83, 0x28, 0x76, 0x22, 0x46, 0x12, 0x05, 0x51, 0x22, 0x50, 0x70,
    0x52, 0x16, 0x21, 0x05, 0x81, 0xf1, 0x85, 0x50, 0x10, 0x13, 0x51, 0xf1, 0x28, 0x05, 0x42, 0x5b, 0x32, 0x27, 0x50, 0x84, 0x94, 0x02, 0x81, 0x0f, 0x32, 0x07, 0x01, 0x38, 0x45, 0x20, 0x43, 0x12,
    0x50, 0x48, 0x32, 0x19, 0x12, 0xf1, 0x20, 0x42, 0xb2, 0x67, 0x28, 0x04, 0x94, 0x32, 0x12, 0x04, 0x05, 0x10, 0x13, 0x42, 0x58, 0x65, 0x73, 0x27, 0x31, 0x02, 0x8b, 0x84, 0x50, 0x16, 0x42, 0x22,
    0x85, 0x0d, 0x86, 0x75, 0x6b, 0x5a, 0x20, 0x43, 0x10, 0x16, 0x52, 0x12, 0x61, 0x01, 0xe2, 0x02, 0x40, 0xea, 0x01, 0x23, 0x22, 0x75, 0x52, 0x31, 0x0b, 0x51, 0x23, 0x22, 0x40, 0x25, 0xd6, 0x21,
    0x53, 0x25, 0x12, 0x62, 0x54, 0x22, 0x32, 0x21, 0x01, 0x35, 0x16, 0x84, 0x07, 0x29, 0x24, 0x31, 0xef, 0x15, 0x3a, 0x50, 0x25, 0x72, 0x20, 0x81, 0xc1, 0x38, 0x43, 0x42, 0x61, 0x9a, 0x85, 0x3d,
    0x52, 0x23, 0x25, 0xb7, 0x61, 0x65, 0x24, 0x59, 0x21, 0x38, 0x58, 0x40, 0x19, 0x46, 0x12, 0x04, 0xb8, 0x01, 0x97, 0x64, 0x62, 0x12, 0x92, 0x42, 0x05, 0x2e, 0x43, 0x21, 0x23, 0xf3, 0x01, 0x05,
    0x81, 0x23, 0x42, 0x88, 0x05, 0x73, 0x21, 0x22, 0x0f, 0x96, 0x19, 0x70, 0x12, 0x50, 0x25, 0x52, 0x16, 0x42, 0x26, 0x46, 0x73, 0x25, 0x13, 0xa2, 0x08, 0xa2, 0x08, 0x27, 0x64, 0x25, 0x02, 0x13,
    0x85, 0x70, 0x16, 0x13, 0x55, 0xe7, 0x31, 0x02, 0xa5, 0x34, 0x22, 0x26, 0x28, 0x45, 0x04, 0x01, 0xc1, 0x53, 0x18, 0x34, 0x67, 0x22, 0x34, 0x23, 0x25, 0x49, 0x43, 0x15, 0xc8, 0x15, 0x82, 0xe2,
    0x32, 0xa5, 0x01, 0x22, 0x04, 0x01, 0x22, 0x02, 0xa8, 0x28, 0x53, 0x52, 0x45, 0x07, 0x04, 0x04, 0x82, 0x91, 0x02, 0xa2, 0x28, 0x26, 0x57, 0x02, 0x21, 0x65, 0x10, 0x87, 0xf1, 0x52, 0x6d, 0x05,
    0x25, 0x21, 0x07, 0xe3, 0xb2, 0xe4, 0x08, 0x12, 0x53, 0xa0, 0x2a, 0x80, 0x40, 0x4e, 0x0d, 0x26, 0x72, 0x97, 0x02, 0x1f, 0x10, 0x12, 0x05, 0x12, 0x25, 0x02, 0x12, 0x32, 0x19, 0x1f, 0x43, 0x70,
    0xa0, 0x12, 0x32, 0x76, 0x18, 0x31, 0x92, 0x55, 0x24, 0x04, 0x05, 0xd5, 0x80, 0x84, 0x34, 0xf7, 0x01, 0x23, 0x40, 0x4e, 0x0f, 0x12, 0x42, 0x08, 0x12, 0x37, 0x67, 0x26, 0x19, 0x12, 0x04, 0x50,
    0x25, 0x22, 0x15, 0x02, 0x15, 0x23, 0x10, 0x28, 0x42, 0x35, 0x2a, 0x02, 0x58, 0x16, 0x21, 0x92, 0x73, 0x13, 0xa3, 0x52, 0x27, 0x58, 0xe3, 0x10, 0x12, 0xc1, 0x6b, 0xa2, 0x02, 0x42, 0x62, 0x25,
    0x42, 0x05, 0x45, 0x38, 0x84, 0x23, 0x72, 0x23, 0x79, 0x10, 0x40, 0x45, 0x23, 0x24, 0x94, 0x8c, 0x12, 0xe0, 0x13, 0x25, 0x58, 0x13, 0xa2, 0x05, 0xf0, 0x28, 0x52, 0x0d, 0x67, 0x61, 0x65, 0x12,
    0x20, 0xf1, 0x12, 0x95, 0xb2, 0xa0, 0x78, 0x55, 0x80, 0x22, 0x21, 0x26, 0x10, 0xa3, 0x52, 0x42, 0x35, 0x85, 0x24, 0x0a, 0x62, 0x21, 0x82, 0x9a, 0x05, 0xb1, 0x88, 0x0a, 0x01, 0x53, 0x54, 0x61,
    0x08, 0x7f, 0x22, 0x22, 0x54, 0x25, 0x32, 0x12, 0x6e, 0x24, 0x3a, 0x23, 0x54, 0x04, 0x02, 0x40, 0x45, 0x89, 0x21, 0x3a, 0x22, 0xe2, 0x62, 0x55, 0x24, 0x04, 0xe0, 0x73, 0x10, 0x28, 0x10, 0x21,
    0xc1, 0x32, 0x40, 0x12, 0x31, 0x2e, 0x50, 0x22, 0x19, 0xa3, 0x10, 0x1f, 0xf3, 0x31, 0x3a, 0x01, 0x64, 0x01, 0x92, 0x48, 0x29, 0x72, 0x32, 0x19, 0x5a, 0x01, 0x05, 0x48, 0x0a, 0x28, 0xe0, 0x46,
    0x43, 0x7f, 0x82, 0x43, 0x45, 0x28, 0x0a, 0x20, 0x12, 0x32, 0x24, 0x80, 0xa0, 0x76, 0x42, 0x05, 0x49, 0x16, 0x21, 0xf1, 0x01, 0x25, 0x01, 0x65, 0x21, 0x20, 0x21, 0x94, 0x04, 0x25, 0x0b, 0x55,
    0x22, 0x1b, 0x01, 0xb0, 0x21, 0x23, 0x72, 0x04, 0x56, 0x2f, 0x02, 0x62, 0x10, 0xea, 0x31, 0x23, 0x10, 0xd0, 0x21, 0xc8, 0xa0, 0x27, 0x20, 0x75, 0x05, 0x12, 0x26, 0x42, 0x35, 0x18, 0x04, 0x37,
    0x22, 0xe0, 0x48, 0x04, 0x31, 0x35, 0xbf, 0x30, 0x54, 0x25, 0x05, 0x10, 0x12, 0x86, 0x52, 0x16, 0xe1, 0x34, 0x32, 0x48, 0x31, 0x67, 0x23, 0x12, 0x04, 0x05, 0x10, 0x12, 0x31, 0x2f, 0xb4, 0x38,
    0x40, 0x24, 0x01, 0x82, 0x50, 0x70, 0xa2, 0x23, 0x81, 0x85, 0x32, 0x19, 0x2e, 0xa5, 0x02, 0x81, 0xfe, 0x10, 0x52, 0x40, 0x55, 0xd0, 0x16, 0xa2, 0x02, 0x24, 0x61, 0x04, 0x23, 0x46, 0x42, 0x05,
    0xa8, 0x34, 0x85, 0x05, 0x15, 0x04, 0x02, 0x82, 0x2f, 0x02, 0x05, 0x12, 0x88, 0x07, 0x22, 0x32, 0x48, 0x34, 0x34, 0x01, 0x8c, 0x5a, 0x01, 0x0a, 0x22, 0x67, 0x29, 0x45, 0x08, 0xf4, 0x1b, 0x02,
    0x45, 0x02, 0x43, 0x12, 0x55, 0x31, 0x25, 0xe9, 0x2b, 0x24, 0x50, 0x49, 0x22, 0x15, 0x64, 0x85, 0x32, 0x51, 0x64, 0x05, 0xe7, 0x05, 0x21, 0x01, 0x2c, 0x18, 0x01, 0x26, 0xfa, 0x2f, 0x90, 0x72,
    0x25, 0xc1, 0x02, 0xa2, 0x05, 0x52, 0x48, 0x05, 0x54, 0x85, 0x23, 0x24, 0x23, 0x10, 0x19, 0xb2, 0x24, 0x64, 0x0a, 0x26, 0x4c, 0x18, 0x35, 0x54, 0x52, 0x37, 0x23, 0x22, 0xa0, 0x49, 0x42, 0xf5,
    0x82, 0x40, 0x12, 0x61, 0xc1, 0x05, 0x43, 0x13, 0x51, 0x53, 0xa3, 0x24, 0x82, 0x23, 0x25, 0x13, 0x84, 0x52, 0x50, 0x21, 0x07, 0x55, 0x64, 0x62, 0x45, 0x05, 0x21, 0x20, 0x51, 0xc2, 0x82, 0x42,
    0x08, 0x43, 0x1c, 0x49, 0x27, 0x95, 0x43, 0x40, 0x72, 0x94, 0x91, 0xe0, 0x13, 0x70, 0x81, 0x02, 0x48, 0x56, 0x82, 0x79, 0x21, 0x32, 0x12, 0x53, 0x40, 0x52, 0x10, 0x24, 0x07, 0x56, 0x42, 0x32,
    0xd0, 0x28, 0xef, 0x00, 0x75, 0x08, 0x72, 0x34, 0x34, 0x34, 0xf5, 0x22, 0x19, 0x10, 0x16, 0xd3, 0x27, 0x6e, 0x2e, 0x16, 0x42, 0x23, 0x18, 0x52, 0x0a, 0x53, 0x25, 0x16, 0x12, 0x01, 0x89, 0x27,
    0xf2, 0x70, 0x12, 0x0f, 0x3f, 0x46, 0x12, 0x0b, 0x42, 0x08, 0x45, 0x07, 0x02, 0x72, 0x31, 0x04, 0x23, 0x40, 0x87, 0x35, 0x85, 0x25, 0x42, 0x28, 0x56, 0x10, 0x49, 0x25, 0x27, 0xc1, 0x80, 0x1f,
    0x43, 0x21, 0x22, 0x62, 0x81, 0x08, 0x43, 0x43, 0x40, 0x12, 0x04, 0xf4, 0x35, 0x12, 0x80, 0x73, 0x10, 0x46, 0x54, 0x91, 0x34, 0xf2, 0x12, 0x04, 0x94, 0x52, 0x5c, 0x51, 0x3d, 0x31, 0x3b, 0x24,
    0x32, 0x75, 0x34, 0x53, 0xa2, 0x04, 0x02, 0x42, 0x23, 0x21, 0x6d, 0x37, 0x83, 0x12, 0x91, 0x82, 0x0b, 0xb2, 0x25, 0x51, 0x0a, 0x04, 0x23, 0x51, 0x98, 0x21, 0x5b, 0x22, 0xfa, 0x32, 0x1c, 0xf1,
    0x10, 0x1c, 0x55, 0x12, 0x23, 0x54, 0x05, 0x78, 0x23, 0x25, 0x84, 0x0f, 0xa1, 0x04, 0xe5, 0x31, 0x37, 0x65, 0x21, 0x25, 0x20, 0x16, 0x51, 0x62, 0xb2, 0x24, 0x55, 0x98, 0x22, 0x73, 0x12, 0x91,
    0xf1, 0x64, 0x02, 0x57, 0x01, 0x25, 0x04, 0x32, 0x10, 0x46, 0x22, 0x58, 0xf0, 0x34, 0x2b, 0x20, 0x45, 0x0e, 0x46, 0x55, 0x72, 0x20, 0x81, 0x2e, 0x61, 0x22, 0x02, 0x12, 0x62, 0x13, 0x45, 0x2f,
    0x43, 0xa0, 0x42, 0xb3, 0x1e, 0x20, 0x57, 0x32, 0x12, 0x37, 0x62, 0x21, 0x04, 0x50, 0x76, 0x10, 0x19, 0x84, 0x04, 0x25, 0xe3, 0x85, 0x40, 0x22, 0x15, 0x50, 0x15, 0x8b, 0x04, 0x23, 0x73, 0x25,
    0x46, 0x25, 0x22, 0x10, 0xb1, 0x23, 0x21, 0x01, 0x26, 0x13, 0x4b, 0xb5, 0x02, 0x5a, 0xe0, 0x28, 0x42, 0x23, 0x10, 0x24, 0x34, 0x23, 0x72, 0x62, 0x1b, 0x34, 0x05, 0x21, 0xf1, 0x0a, 0x23, 0x24,
    0x32, 0x54, 0x64, 0x28, 0x50, 0x51, 0xc4, 0x67, 0x83, 0x85, 0x52, 0x76, 0xb4, 0x53, 0xa2, 0x04, 0xfd, 0x20, 0x13, 0x76, 0x42, 0xb2, 0x58, 0xb0, 0xe1, 0x05, 0x24, 0x01, 0x62, 0x70, 0x43, 0xa9,
    0x21, 0xf2, 0x81, 0x01, 0x01, 0x3f, 0x96, 0xa0, 0xa9, 0x43, 0x40, 0x21, 0x61, 0x29, 0x12, 0x05, 0x52, 0x57, 0x05, 0x43, 0x12, 0x0d, 0x53, 0x45, 0x01, 0x6d, 0x32, 0x10, 0x12, 0x05, 0xfc, 0x26,
    0x40, 0x2d, 0xf1, 0xe3, 0x21, 0x25, 0x50, 0x12, 0x26, 0x73, 0xe1, 0x04, 0x32, 0x12, 0xc1, 0x50, 0x48, 0x55, 0x80, 0x15, 0x35, 0x49, 0x13, 0x75, 0x32, 0x73, 0x45, 0x62, 0x13, 0x51, 0x92, 0xf3,
    0x37, 0x2f, 0x10, 0x21, 0x20, 0xa8, 0x04, 0x2f, 0x16, 0x51, 0x83, 0x16, 0x40, 0x43, 0x10, 0x87, 0x56, 0x46, 0x22, 0xf4, 0x42, 0x29, 0x43, 0x51, 0x58, 0x04, 0x68, 0x48, 0x32, 0x16, 0x24, 0xe6,
    0x22, 0x15, 0xf2, 0x10, 0x12, 0x35, 0x42, 0x82, 0xf8, 0x21, 0x25, 0x34, 0xf2, 0xa0, 0x45, 0x80, 0x21, 0xe3, 0x22, 0x84, 0x01, 0x59, 0x43, 0xb4, 0x02, 0xa2, 0x08, 0x45, 0x0e, 0x85, 0xd0, 0x21,
    0x26, 0x25, 0x43, 0x15, 0xc4, 0x32, 0x70, 0x48, 0x62, 0x12, 0x67, 0x02, 0x15, 0x91, 0x91, 0x25, 0x0f, 0x11, 0x20, 0x40, 0xa3, 0x24, 0x55, 0x86, 0xbf, 0x11, 0x9b, 0x42, 0x0d, 0x28, 0x31, 0x23,
    0x21, 0x05, 0xd8, 0x67, 0x68, 0x43, 0x21, 0x22, 0x3a, 0x50, 0x48, 0x20, 0x84, 0x05, 0x48, 0xf2, 0x12, 0x23, 0x22, 0x49, 0x25, 0x43, 0x46, 0x24, 0x61, 0x0a, 0x80, 0x40, 0x19, 0x10, 0xf0, 0x05,
    0x24, 0x04, 0x82, 0x65, 0x5a, 0x32, 0x72, 0x31, 0x52, 0x31, 0xf1, 0x22, 0x9b, 0x25, 0x84, 0x04, 0xc2, 0x73, 0x21, 0xb8, 0x35, 0x54, 0x85, 0x0b, 0x15, 0x85, 0x64, 0x01, 0xb5, 0x64, 0x20, 0x21,
    0x2c, 0x12, 0x20, 0xa3, 0x81, 0x83, 0x1b, 0x05, 0x51, 0x0f, 0x90, 0x82, 0x12, 0x50, 0x25, 0x43, 0x10, 0xb4, 0x04, 0x05, 0x28, 0xf3, 0x29, 0x70, 0x52, 0x45, 0x01, 0x26, 0x55, 0xa2, 0x31, 0x07,
    0x85, 0x02, 0x72, 0x02, 0x15, 0xe3, 0x70, 0x84, 0xb0, 0x2b, 0x10, 0xa0, 0x70, 0x25, 0x18, 0x31, 0x61, 0x8b, 0x20, 0x24, 0x04, 0xf2, 0x24, 0x62, 0x2b, 0x10, 0x57, 0x67, 0x50, 0x24, 0xc1, 0x05,
    0x21, 0x53, 0x54, 0x82, 0x6d, 0x02, 0x40, 0x16, 0xf0, 0x02, 0xa0, 0x46, 0x10, 0x73, 0x42, 0x34, 0x31, 0x20, 0x72, 0x28, 0xe6, 0x21, 0xe0, 0x46, 0x19, 0x43, 0x13, 0x81, 0x62, 0x1b, 0x22, 0x88,
    0x0f, 0x12, 0x46, 0x51, 0x20, 0xe2, 0x10, 0x2d, 0x91, 0x95, 0xb7, 0x85, 0x62, 0x15, 0xf5, 0x24, 0x34, 0x28, 0x07, 0x62, 0xa2, 0x50, 0x81, 0x3e, 0x51, 0x50, 0x4f, 0x2a, 0x01, 0x62, 0x5b, 0x10,
    0x16, 0x54, 0x07, 0x29, 0x19, 0xa5, 0x01, 0x05, 0xab, 0x22, 0x02, 0x12, 0x04, 0x55, 0x20, 0x27, 0x32, 0x18, 0x55, 0x61, 0x52, 0x32, 0x82, 0x45, 0x62, 0x13, 0xa2, 0x0d, 0x80, 0x84, 0x26, 0x40,
    0x46, 0x24, 0x0a, 0x23, 0x27, 0x53, 0xa0, 0x16, 0x85, 0x2b, 0x24, 0x05, 0xa8, 0x29, 0x24, 0x61, 0x02, 0x5a, 0x65, 0x12, 0x3a, 0x04, 0x53, 0xf3, 0x02, 0x43, 0x1f, 0x49, 0x1f, 0x54, 0x25, 0x50,
    0x43, 0x21, 0x31, 0xc8, 0x13, 0xd2, 0x82, 0x50, 0x42, 0x26, 0x45, 0x6b, 0x21, 0x9a, 0x08, 0x12, 0x50, 0x78, 0x62, 0x21, 0x23, 0x81, 0x6e, 0x18, 0x34, 0x01, 0x35, 0x15, 0x80, 0x54, 0x07, 0x31,
    0xe0, 0x2d, 0x04, 0x08, 0x46, 0x1c, 0x28, 0x19, 0x21, 0x38, 0x15, 0xcb, 0x19, 0xa0, 0x8a, 0x01, 0x50, 0x22, 0x21, 0x26, 0x1b, 0x52, 0x80, 0x5d, 0x61, 0x23, 0xa2, 0x58, 0x31, 0x92, 0x12, 0x08,
    0x21, 0x55, 0x3d, 0x23, 0x40, 0xb5, 0x4b, 0x34, 0x95, 0x25, 0x51, 0x65, 0xbf, 0x08, 0x34, 0x28, 0x31, 0x37, 0x62, 0x12, 0xb0, 0x21, 0x20, 0x72, 0x29, 0xb1, 0x01, 0x61, 0x80, 0x25, 0x16, 0x10,
    0x87, 0x22, 0x07, 0x92, 0x2e, 0x13, 0x2b, 0x72, 0x23, 0x5e, 0x18, 0x83, 0x1c, 0x40, 0xa3, 0x46, 0x21, 0x83, 0x5d, 0x02, 0x15, 0x2b, 0x23, 0x49, 0x73, 0xe2, 0x21, 0x04, 0x62, 0x4f, 0xa8, 0x01,
    0x01, 0x3a, 0x38, 0x5d, 0x07, 0x58, 0x64, 0x85, 0x2f, 0x46, 0x24, 0x04, 0x02, 0xa0, 0x12, 0x34, 0x26, 0x21, 0x5e, 0xb2, 0x23, 0x21, 0x01, 0x23, 0x22, 0xa8, 0x31, 0x08, 0x21, 0x07, 0x89, 0x42,
    0x2e, 0x05, 0xd2, 0x22, 0x05, 0x43, 0x88, 0x13, 0x84, 0x0d, 0x04, 0x61, 0x0e, 0x5a, 0xc4, 0x32, 0x43, 0x76, 0x22, 0x46, 0x21, 0x04, 0x50, 0x24, 0x31, 0x04, 0xca, 0x20, 0x58, 0x1c, 0x13, 0x42,
    0x64, 0x08, 0x24, 0x92, 0x21, 0xb0, 0x13, 0x27, 0x67, 0x80, 0x15, 0x04, 0x02, 0x54, 0x22, 0x92, 0x12, 0xf2, 0x12, 0x56, 0x15, 0x34, 0x55, 0x31, 0x26, 0x42, 0x50, 0x48, 0x08, 0x43, 0x40, 0x51,
    0x6d, 0x07, 0x08, 0x24, 0x23, 0x76, 0xe4, 0x92, 0x4b, 0x0d, 0x05, 0x72, 0x3f, 0x11, 0x31, 0x65, 0x43, 0x51, 0x23, 0x12, 0x6a, 0x32, 0x10, 0x42, 0x94, 0x32, 0x2a, 0x80, 0x72, 0x91, 0xc1, 0x6a,
    0x61, 0x52, 0x31, 0x22, 0xc4, 0x08, 0x81, 0x07, 0x08, 0x12, 0x31, 0x25, 0x02, 0x2d, 0xf2, 0x13, 0x7c, 0x10, 0x45, 0x04, 0x32, 0x45, 0x04, 0x0b, 0x1e, 0xc2, 0x28, 0x22, 0xa0, 0x48, 0xc1, 0x83,
    0x22, 0x57, 0x23, 0x72, 0x37, 0x0f, 0x4f, 0xc3, 0x12, 0x01, 0x37, 0x29, 0x15, 0x52, 0x50, 0x40, 0x2a, 0x04, 0x23, 0x24, 0x62, 0x21, 0x83, 0x43, 0x76, 0x40, 0x40, 0x52, 0x19, 0x43, 0xf9, 0x34,
    0x20, 0x43, 0x42, 0x23, 0x40, 0xa0, 0x12, 0x61, 0x0b, 0x51, 0xc8, 0x12, 0x6e, 0x21, 0x20, 0xa3, 0x12, 0x0a, 0x23, 0x72, 0x61, 0x28, 0x35, 0x25, 0xbe, 0x73, 0xf0, 0x3a, 0x26, 0x48, 0x61, 0x53,
    0x1f, 0x12, 0x20, 0x40, 0x19, 0x22, 0x45, 0x20, 0xf3, 0x32, 0xd2, 0x05, 0x81, 0xb6, 0x22, 0x49, 0x46, 0x76, 0x72, 0x3f, 0x11, 0x55, 0x25, 0xf8, 0x52, 0x12, 0x23, 0x24, 0x04, 0x08, 0x46, 0x73,
    0x21, 0x91, 0x04, 0x26, 0x84, 0xf2, 0x48, 0x04, 0x05, 0x10, 0x16, 0x24, 0x3f, 0x32, 0x91, 0x53, 0x2f, 0x03, 0xa3, 0x54, 0x07, 0xf4, 0x53, 0xa3, 0xa3, 0x2f, 0x00, 0x21, 0x62, 0x70, 0xa2, 0x3b,
    0xa2, 0x05, 0x12, 0x61, 0x3b, 0x12, 0x20, 0xa9, 0x21, 0x61, 0x22, 0x32, 0x42, 0x32, 0x76, 0x22, 0xa2, 0xbf, 0x28, 0x28, 0x43, 0xe8, 0x27, 0x52, 0x50, 0x21, 0x53, 0x2a, 0x32, 0x16, 0x48, 0x94,
    0x02, 0x10, 0xd8, 0x04, 0x22, 0x26, 0xf3, 0xb0, 0x13, 0x51, 0x91, 0xf8, 0x72, 0xf1, 0x32, 0x12, 0x61, 0x2c, 0x24, 0x68, 0x42, 0x26, 0x42, 0x26, 0x2b, 0x16, 0xa3, 0x54, 0x35, 0x84, 0x83, 0xb4,
    0x31, 0xb2, 0x82, 0x04, 0xe0, 0x40, 0x10, 0xf3, 0x0d, 0x32, 0x28, 0x24, 0x61, 0x8e, 0x80, 0x5e, 0x2e, 0x18, 0x50, 0x16, 0x24, 0x23, 0x24, 0x50, 0x25, 0x40, 0x81, 0x91, 0x26, 0x22, 0xa2, 0x23,
    0x88, 0x40, 0x40, 0x21, 0x25, 0x80, 0x43, 0x18, 0x02, 0x22, 0x43, 0x42, 0x85, 0x35, 0x21, 0x26, 0x70, 0x51, 0x2f, 0x22, 0x27, 0x9d, 0x94, 0x22, 0x61, 0xc1, 0x64, 0x86, 0xd0, 0x16, 0x70, 0xd2,
    0x32, 0xf0, 0x31, 0x80, 0x73, 0x2f, 0x33, 0x81, 0xe2, 0x50, 0xe2, 0x46, 0xf3, 0x64, 0x05, 0x43, 0x13, 0x22, 0xd0, 0x15, 0x67, 0x3e, 0x78, 0x04, 0x82, 0xf1, 0x82, 0x05, 0x48, 0x02, 0x46, 0x8d,
    0x23, 0x70, 0x19, 0x43, 0x84, 0x04, 0x31, 0x25, 0x29, 0x10, 0x21, 0x94, 0xc8, 0x40, 0x82, 0x76, 0x1c, 0x16, 0x45, 0x62, 0x21, 0x64, 0x0e, 0x8a, 0x0 
};

#define NIBBLE_START_POINT              (3)
#define MAX_NIBBLE_PRIME                (65521)
#define PRIME_NIBBLE_DIFF_TABLE_SIZE    (sizeof(m_primeNibbleDiffTable) / sizeof(ubyte))
#endif


/*------------------------------------------------------------------*/

#ifndef __DISABLE_DIGICERT_PRIME_TEST__
static ubyte4
squareRoot(ubyte4 number)
{
    ubyte4  lo = 1;
    ubyte4  hi = 1 + (number>> 2);
    ubyte4  mid;

    if (hi > 0xffff)
        hi = 0xffff;

    do
    {
        mid = (lo + hi + 1) >> 1;

        if ((mid*mid) > number)
            hi = mid - 1;
        else
            lo = mid + 1;
    }
    while (hi >= lo);

    return lo-1;
}
#endif


/*------------------------------------------------------------------*/

#ifndef __DISABLE_DIGICERT_PRIME_TEST__
extern MSTATUS
PRIME_simpleSmallPrimeTest(ubyte4 primeCandidate, intBoolean *pRetIsPrime)
{
    ubyte4  index;
    ubyte4  total = 2 * PRIME_NIBBLE_DIFF_TABLE_SIZE;
    ubyte4  position = NIBBLE_START_POINT;
    ubyte4  _2nibble;
    ubyte4  nibble;
    ubyte4  upper;
    MSTATUS status = OK;

    if (NULL == pRetIsPrime)
    {
        status = ERR_NULL_POINTER;
        goto exit;
    }

    *pRetIsPrime = FALSE;

    if ((2 == primeCandidate) || (3 == primeCandidate))
    {
        /* the odd case... */
        *pRetIsPrime = TRUE;
        goto exit;
    }

    /* easy to detect non primes */
    if ((!(primeCandidate & 1)) || (1 >= primeCandidate))
        goto exit;

    upper = squareRoot(primeCandidate);

    for (index = 0; index < total; index++)
    {
        if (0 == (primeCandidate % position))
            goto exit;

        _2nibble = m_primeNibbleDiffTable[(index / 2)];
        nibble = (_2nibble >> (4 * ((index ^ 1) & 1))) & 0x0f;

        position += (nibble * 2) + 2;

        if ((upper < position) || (MAX_NIBBLE_PRIME < position))
        {
            /* number is prime! */
            *pRetIsPrime = TRUE;
            break;
        }
    }

exit:
    return status;

} /* PRIME_simpleSmallPrimeTest */
#endif


/*------------------------------------------------------------------*/

#ifndef __DISABLE_DIGICERT_PRIME_TEST__

extern MSTATUS
PRIME_simplePrimeTest(MOC_MOD(hwAccelDescr hwAccelCtx) vlong *pPrime, ubyte4 startingIndex, ubyte4 endingIndex, intBoolean *pRetIsPrime, vlong **ppVlongQueue)
{
    ubyte4  index      = startingIndex;
    vlong*  pDivisor   = NULL;
    vlong*  pRemainder = NULL;
    MSTATUS status;

    *pRetIsPrime = FALSE;

    if (OK > (status = VLONG_makeVlongFromUnsignedValue((ubyte4)m_primeTable[0], &pDivisor, ppVlongQueue)))
        goto exit;

    DEBUG_RELABEL_MEMORY(pDivisor);

    while (index < endingIndex)
    {
        /* quickly, place prime number in divisor */
        pDivisor->pUnits[0] = (ubyte4)m_primeTable[index];

        VLONG_freeVlong(&pRemainder, ppVlongQueue);
        if (OK > (status = VLONG_operatorModSignedVlongs(MOC_MOD(hwAccelCtx) pPrime, pDivisor, &pRemainder, ppVlongQueue)))
            goto exit;

        DEBUG_RELABEL_MEMORY(pRemainder);

        /* not prime, if remainder is zero */
        if (TRUE == VLONG_isVlongZero(pRemainder))
            goto exit;

        index++;
    }

    if (index == endingIndex)
        *pRetIsPrime = TRUE;

exit:
    VLONG_freeVlong(&pRemainder, ppVlongQueue);
    VLONG_freeVlong(&pDivisor, ppVlongQueue);

    return status;

} /* simplePrimeTest */

#endif /* __DISABLE_DIGICERT_PRIME_TEST__ */


/*------------------------------------------------------------------*/

#if (defined(__ENABLE_DIGICERT_PRIME_SIEVE__))

extern MSTATUS
PRIME_simpleDualPrimeTest(MOC_MOD(hwAccelDescr hwAccelCtx) vlong *pPrimeA, vlong *pPrimeB, ubyte4 startingIndex, ubyte4 endingIndex, intBoolean *pRetIsPrime, vlong **ppVlongQueue)
{
    ubyte4  index      = startingIndex;
    vlong*  pDivisor   = NULL;
    vlong*  pRemainder = NULL;
    MSTATUS status;

    *pRetIsPrime = FALSE;

    if (OK > (status = VLONG_makeVlongFromUnsignedValue((ubyte4)m_primeTable[0], &pDivisor, ppVlongQueue)))
        goto exit;

    while (index < endingIndex)
    {
        /* quickly, place prime number in divisor */
        pDivisor->pUnits[0] = (ubyte4)m_primeTable[index];

        VLONG_freeVlong(&pRemainder, ppVlongQueue);
        if (OK > (status = VLONG_operatorModSignedVlongs(MOC_MOD(hwAccelCtx) pPrimeA, pDivisor, &pRemainder, ppVlongQueue)))
            goto exit;

        /* not prime, if remainder is zero */
        if (TRUE == VLONG_isVlongZero(pRemainder))
            goto exit;

        VLONG_freeVlong(&pRemainder, ppVlongQueue);
        if (OK > (status = VLONG_operatorModSignedVlongs(MOC_MOD(hwAccelCtx) pPrimeB, pDivisor, &pRemainder, ppVlongQueue)))
            goto exit;

        /* not prime, if remainder is zero */
        if (TRUE == VLONG_isVlongZero(pRemainder))
            goto exit;

        index++;
    }

    if (index == endingIndex)
        *pRetIsPrime = TRUE;

exit:
    VLONG_freeVlong(&pRemainder, ppVlongQueue);
    VLONG_freeVlong(&pDivisor, ppVlongQueue);

    return status;

} /* simpleDualPrimeTest */

#endif /* (defined(__ENABLE_DIGICERT_PRIME_SIEVE__)) */


/*------------------------------------------------------------------*/

#if (defined(__ENABLE_DIGICERT_PRIME_SIEVE__) || !defined(__DISABLE_DIGICERT_PRIME_TEST__))
static MSTATUS
performRabinMillerTest(MOC_MOD(hwAccelDescr hwAccelCtx)
        ModExpHelper MEH, vlong *p, vlong *a, intBoolean *isGoodPrime,
        vlong **ppVlongQueue)
{
    vlong*  m   = NULL;
    vlong*  p_1 = NULL;  /* p-1 */
    vlong*  z   = NULL;
    vlong*  tmp = NULL;
    ubyte4  j, b;
    MSTATUS status;

    j = 0;
    b = 0;
    *isGoodPrime = FALSE;

    if (OK > (status = VLONG_allocVlong(&tmp, ppVlongQueue)))
        goto exit;

    DEBUG_RELABEL_MEMORY(tmp);

    /* p_1 = (p-1) */
    if (OK > (status = VLONG_makeVlongFromVlong(p, &p_1, ppVlongQueue)))
        goto exit;

    DEBUG_RELABEL_MEMORY(p_1);

    if (OK > (status = VLONG_decrement(p_1, ppVlongQueue)))
        goto exit;

    /* m = (p-1) */
    if (OK > (status = VLONG_makeVlongFromVlong(p_1, &m, ppVlongQueue)))
        goto exit;

    DEBUG_RELABEL_MEMORY(m);

    /* compute m, such that p = 1 + 2^b * m */
    while (0 == (m->pUnits[0] & 1))
    {
        /* divide by 2 until m is odd */
        VLONG_shrVlong(m);
        b++;
    }

    /* z = a^m mod p */
    if (OK > (status = VLONG_modExp(MOC_MOD(hwAccelCtx) MEH, a, m, &z, ppVlongQueue)))
        goto exit;

    DEBUG_RELABEL_MEMORY(z);

    /* if ((z=1) or (z=(p-1))), p is probably prime */
    if ((VLONG_compareUnsigned(z,1) == 0) || (VLONG_compareSignedVlongs(z, p_1) == 0))
    {
        *isGoodPrime = TRUE;
        goto exit;
    }

    for (j++; j < b; j++)
    {
        /* tmp = z^2 */
        if (OK > (status = VLONG_vlongSignedSquare(tmp, z)))
            goto exit;

        VLONG_freeVlong(&z, ppVlongQueue);

        /* z = z^2 mod p */
        if (OK > (status = VLONG_operatorModSignedVlongs(MOC_MOD(hwAccelCtx) tmp, p, &z, ppVlongQueue)))
            goto exit;

        DEBUG_RELABEL_MEMORY(z);

        /* if z = p-1, p is probably prime */
        if (0 == VLONG_compareSignedVlongs(z, p_1))
        {
            *isGoodPrime = TRUE;
            goto exit;
        }

        /* if j > 0 and z = 1, p is not prime */
        if (VLONG_compareUnsigned(z,1) == 0)
            goto exit;
    }

exit:
    VLONG_freeVlong(&m, ppVlongQueue);
    VLONG_freeVlong(&p_1, ppVlongQueue);
    VLONG_freeVlong(&z, ppVlongQueue);
    VLONG_freeVlong(&tmp, ppVlongQueue);

    return status;

} /* performRabinMillerTest */

/*------------------------------------------------------------------*/

static ubyte4
PRIME_numRoundsRequired(ubyte4 bitLength, PrimeTestType type)
{
    ubyte4 numRounds = 50;          /* less than 100 bits, or no Lucas test */

    switch (type)
    {
        case prime_Legacy:
        {
            switch (bitLength >> 8)
            {
                case 0:
                {
                    if (100 <= bitLength)
                        numRounds = 27;     /* 100 - 255 bits */

                    break;
                }

                case 1:
                {
                    numRounds = 15;         /* 256 - 511 bits */
                    break;
                }

                case 2:
                {
                    numRounds = 8;          /* 512 - 767 bits*/
                    break;
                }

                case 3:
                {
                    numRounds = 4;          /* 768 - 1023 bits*/
                    break;
                }

                default:
                {
                    numRounds = 2;          /* 1024 bits or more */
                    break;
                }
            }
            break;
        }
        case prime_DSA:
        case prime_RSA:
        {
            /* updated for FIPS 186-5 */
            /* Note: >= 4K is also 3 for the 2^{-secStr) column entry */
            if (bitLength >= 3072)
            {
                numRounds = 3;
            }
            /* Note: >= 2K is also 4 for the 2^{-secStr) column entry */
            else if (bitLength >= 1536)
            {
                numRounds = 4;
            }
            /* Note: >= 768  & 1K is also 5 for the 2^{-secStr) column entry */
            else if (bitLength >= 512 )
            {
                numRounds = 5;
            }

            /* Note: This is used for DSA keys */
            else if (bitLength >= 256 )
            {
                numRounds = 27;
            }
            else if (bitLength >= 224 )
            {
                numRounds = 24;
            }
            else if (bitLength >= 160 )
            {
                numRounds = 19;
            }
            else if (bitLength >= 100 )
            {
                numRounds = 27; /* From legacy code above */
            }
            else /* bitLength < 100  */
            {
                numRounds = 50; /* Default from legacy code above */
            }
            break;
        }
    }

    return numRounds;

} /* PRIME_numRoundsRequired */

#endif /* (defined(__ENABLE_DIGICERT_PRIME_SIEVE__) || !defined(__DISABLE_DIGICERT_PRIME_TEST__)) */

/*------------------------------------------------------------------*/

#ifndef __DISABLE_DIGICERT_PRIME_TEST__

extern MSTATUS
PRIME_doPrimeTestsEx(MOC_MOD(hwAccelDescr hwAccelCtx) randomContext *pRandomContext,
                   vlong *pPrime, PrimeTestType type, intBoolean *pIsPrime, vlong **ppVlongQueue)
{
    ModExpHelper    MEH = NULL;
    vlong*          a = NULL;
    sbyte4          index;
    ubyte4          numRounds;
    MSTATUS         status;

    if ((NULL == pPrime) || (NULL == pIsPrime))
    {
        status = ERR_NULL_POINTER;
        goto exit;
    }

    if (0 == (pPrime->pUnits[0] & 1))
    {
        status = ERR_EVEN_NUMBER;
        goto exit;
    }

    *pIsPrime = FALSE;

    /* do a fast simple check */
    if ((OK > (status = PRIME_simplePrimeTest(MOC_MOD(hwAccelCtx) pPrime, 0, SIZEOF_PRIME_TABLE, pIsPrime, ppVlongQueue))) || (FALSE == *pIsPrime))
        goto exit;

    /* ANSI X9.80-2005: num of rounds required is dependent on size of the prime */
    numRounds = PRIME_numRoundsRequired(VLONG_bitLength(pPrime), type);

    if (OK > (status = VLONG_makeVlongFromUnsignedValue(1, &a, ppVlongQueue)))
        goto exit;

    DEBUG_RELABEL_MEMORY(a);

    /* set up montgomery exp helper based on p */
    if (OK > (status = VLONG_newModExpHelper(MOC_MOD(hwAccelCtx)
                                             &MEH, pPrime, ppVlongQueue)))
        goto exit;

    DEBUG_RELABEL_MEMORY(MEH);
 
    /* try random primes */
    for (index = numRounds; index > 0; index--)
    {
        VLONG_freeVlong(&a, ppVlongQueue);

        /* a must be between 2..(p-2) */
        if (OK > (status = VLONG_makeRandomVlong(pRandomContext, &a, VLONG_bitLength(pPrime) - 1, ppVlongQueue)))
            goto exit;

        DEBUG_RELABEL_MEMORY(a);

        if (OK > (status = VLONG_addImmediate(a, 2, ppVlongQueue)))
            goto exit;

        if ((OK > (status = performRabinMillerTest(MOC_MOD(hwAccelCtx) MEH, pPrime, a, pIsPrime, ppVlongQueue))) ||
            (FALSE == *pIsPrime))
        {
            goto exit;
        }
    }

#ifdef __ENABLE_DIGICERT_RSA_LUCAS_TEST__
    status = LUCAS_primeTest(MOC_MOD(hwAccelCtx) pPrime, pIsPrime, ppVlongQueue);
#endif

exit:
    VLONG_deleteModExpHelper(&MEH, ppVlongQueue);
    VLONG_freeVlong(&a, ppVlongQueue);

    return status;
}

/*------------------------------------------------------------------*/

extern MSTATUS
PRIME_doPrimeTests(MOC_MOD(hwAccelDescr hwAccelCtx) randomContext *pRandomContext,
                   vlong *pPrime, intBoolean *pIsPrime, vlong **ppVlongQueue)
{
    return PRIME_doPrimeTestsEx(MOC_MOD(hwAccelCtx) pRandomContext, pPrime, prime_Legacy, pIsPrime, ppVlongQueue);
}

#endif /* __DISABLE_DIGICERT_PRIME_TEST__ */


/*------------------------------------------------------------------*/

#if (defined(__ENABLE_DIGICERT_PRIME_SIEVE__))
extern MSTATUS
PRIME_doDualPrimeTests(MOC_MOD(hwAccelDescr hwAccelCtx) randomContext *pRandomContext,
                       sbyte4 startingIndex, vlong *pPrimeA, vlong *pPrimeB, intBoolean *pIsBothPrime, vlong **ppVlongQueue)
{
    ModExpHelper    MEHa = NULL;
    ModExpHelper    MEHb = NULL;
    vlong*          a = NULL;
    sbyte4          index;
    ubyte4          numRounds;
    MSTATUS         status;

    if ((NULL == pPrimeA) || (NULL == pPrimeB) || (NULL == pIsBothPrime))
    {
        status = ERR_NULL_POINTER;
        goto exit;
    }

    if ((0 == (pPrimeA->pUnits[0] & 1)) || (0 == (pPrimeB->pUnits[0] & 1)))
    {
        status = ERR_EVEN_NUMBER;
        goto exit;
    }

    *pIsBothPrime = FALSE;

    /* do a fast simple check */
    if ((OK > (status = PRIME_simpleDualPrimeTest(MOC_MOD(hwAccelCtx) pPrimeA, pPrimeB, startingIndex, SIZEOF_PRIME_TABLE, pIsBothPrime, ppVlongQueue))) || (FALSE == *pIsBothPrime))
        goto exit;

    /* ANSI X9.80-2005: num of rounds required is dependent on size of the prime */
    numRounds = PRIME_numRoundsRequired(VLONG_bitLength(pPrimeB), prime_Legacy);

    if (OK > (status = VLONG_makeVlongFromUnsignedValue(1, &a, ppVlongQueue)))
        goto exit;

    /* set up montgomery exp helper based on p */
    if (OK > (status = VLONG_newModExpHelper(MOC_MOD(hwAccelCtx)
                                             &MEHa, pPrimeA, ppVlongQueue)))
        goto exit;

    /* set up montgomery exp helper based on p */
    if (OK > (status = VLONG_newModExpHelper(MOC_MOD(hwAccelCtx)
                                             &MEHb, pPrimeB, ppVlongQueue)))
        goto exit;

    /* try random primes */
    for (index = numRounds; index > 0; index--)
    {
        VLONG_freeVlong(&a, ppVlongQueue);

        /* a must be between 2..(p-2) */
        if (OK > (status = VLONG_makeRandomVlong(pRandomContext, &a, VLONG_bitLength(pPrimeA) - 1, ppVlongQueue)))
            goto exit;

        if (OK > (status = VLONG_addImmediate(a, 2, ppVlongQueue)))
            goto exit;

        if ((OK > (status = performRabinMillerTest(MOC_MOD(hwAccelCtx) MEHa, pPrimeA, a, pIsBothPrime, ppVlongQueue))) ||
            (FALSE == *pIsBothPrime))
        {
            goto exit;
        }

        VLONG_freeVlong(&a, ppVlongQueue);

        /* a must be between 2..(p-2) */
        if (OK > (status = VLONG_makeRandomVlong(pRandomContext, &a, VLONG_bitLength(pPrimeB) - 1, ppVlongQueue)))
            goto exit;

        if (OK > (status = VLONG_addImmediate(a, 2, ppVlongQueue)))
            goto exit;

        if ((OK > (status = performRabinMillerTest(MOC_MOD(hwAccelCtx) MEHb, pPrimeB, a, pIsBothPrime, ppVlongQueue))) ||
            (FALSE == *pIsBothPrime))
        {
            goto exit;
        }
    }

    if ((OK > (status = LUCAS_primeTest(MOC_MOD(hwAccelCtx) pPrimeA, pIsBothPrime, ppVlongQueue))) || (FALSE == *pIsBothPrime))
        goto exit;

    status = LUCAS_primeTest(MOC_MOD(hwAccelCtx) pPrimeB, pIsBothPrime, ppVlongQueue);

exit:
    VLONG_deleteModExpHelper(&MEHb, ppVlongQueue);
    VLONG_deleteModExpHelper(&MEHa, ppVlongQueue);
    VLONG_freeVlong(&a, ppVlongQueue);

    return status;

} /* PRIME_doDualPrimeTests */

#endif /* (defined(__ENABLE_DIGICERT_PRIME_SIEVE__)) */


/*------------------------------------------------------------------*/

#if (!defined(__PRIME_GEN_HARDWARE__) && (!defined(__DISABLE_DIGICERT_PRIME_TEST__)))

extern MSTATUS
PRIME_generateSizedPrime(MOC_PRIME(hwAccelDescr hwAccelCtx) randomContext *pRandomContext,
                         vlong **ppRetPrime, ubyte4 numBitsLong, vlong **ppVlongQueue)
{
    vlong*      pPrime     = NULL;
    vlong*      pDivisor   = NULL;
    vlong*      pRemainder = NULL;
    intBoolean  isPrime    = FALSE;
    MSTATUS     status;

    *ppRetPrime = NULL;

    if (OK > (status = VLONG_makeRandomVlong(pRandomContext, &pPrime, numBitsLong, ppVlongQueue)))
        goto exit;

    if (OK > (status = VLONG_makeVlongFromUnsignedValue(3, &pDivisor, ppVlongQueue)))
        goto exit;

    if (OK > (status = VLONG_operatorModSignedVlongs(MOC_MOD(hwAccelCtx) pPrime, pDivisor, &pRemainder, ppVlongQueue)))
        goto exit;

    /* prime is now a multiple of 3 */
    /* 3, 6, 9, 12, 15, 18 */
    if (OK > (status = VLONG_subtractSignedVlongs(pPrime, pRemainder, ppVlongQueue)))
        goto exit;

    /* move to next odd value */
    /* 5, 11, 17, 23 */
    if (FALSE == VLONG_isVlongBitSet(pPrime, 0))
    {
        if (OK > (status = VLONG_addImmediate(pPrime, 3, ppVlongQueue)))
            goto exit;
    }

    /* move to 5 */
    if (OK > (status = VLONG_addImmediate(pPrime, 2, ppVlongQueue)))
        goto exit;

    /* 3, 5, 7, 9, 11, 13, 15 */
    while (1)
    {
        /* test first value */
        /* test 5 */
        if (OK > (status = PRIME_doPrimeTestsEx(MOC_MOD(hwAccelCtx) pRandomContext, pPrime, prime_Legacy, &isPrime, ppVlongQueue)))
            goto exit;

        if (TRUE == isPrime)
            break;

        /* move to next odd number */
        /* move to 7 */
        if (OK > (status = VLONG_addImmediate(pPrime, 2, ppVlongQueue)))
            goto exit;

        /* do next prime test */
        /* test 7 */
        if (OK > (status = PRIME_doPrimeTestsEx(MOC_MOD(hwAccelCtx) pRandomContext, pPrime, prime_Legacy, &isPrime, ppVlongQueue)))
            goto exit;

        if (TRUE == isPrime)
            break;

        /* skip next odd number */
        /* skip 9, move to 11 */
        if (OK > (status = VLONG_addImmediate(pPrime, 4, ppVlongQueue)))
            goto exit;
    }

    *ppRetPrime = pPrime; pPrime = NULL;

exit:
    VLONG_freeVlong(&pRemainder, 0);
    VLONG_freeVlong(&pDivisor, 0);
    VLONG_freeVlong(&pPrime, 0);
    VLONG_freeVlongQueue(ppVlongQueue);

    return status;
}

#endif /* __PRIME_GEN_HARDWARE__ */

