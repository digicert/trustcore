/*
 * nist_ec_drng.c
 *
 * RNG described in NIST SP800 90
 *
 * Copyright 2025 DigiCert Project Authors. All Rights Reserved.
 * 
 * DigiCert® TrustCore and TrustEdge are licensed under a dual-license model:
 * - **Open Source License**: GNU AGPL v3. See: https://github.com/digicert/trustcore-test/blob/main/LICENSE
 * - **Commercial License**: Available under DigiCert’s Master Services Agreement. See: https://github.com/digicert/trustcore-test/blob/main/LICENSE_COMMERCIAL.txt  
 *   or https://www.digicert.com/master-services-agreement/
 * 
 * *For commercial licensing, contact DigiCert at sales@digicert.com.*
 *
 */

/*------------------------------------------------------------------*/

#include "../common/moptions.h"

#ifdef __ENABLE_DIGICERT_RNG_DRBG_ECC__

#include "../common/mtypes.h"
#include "../common/mocana.h"
#include "../crypto/hw_accel.h"

#if defined(__ENABLE_DIGICERT_ECC__)

#include "../common/mdefs.h"
#include "../common/merrors.h"
#include "../common/mstdlib.h"
#include "../common/mrtos.h"
#include "../crypto/crypto.h"
#include "../common/random.h"
#include "../common/int64.h"

#include "../crypto/sha1.h"

#undef __ENABLE_DIGICERT_VLONG_ECC_CONVERSION__
#include "../crypto/primefld.h"
#include "../crypto/primeec.h"
#include "../crypto/primefld_priv.h"
#include "../crypto/primeec_priv.h"
#include "../harness/harness.h"

#include "../crypto/nist_ec_drng.h"


typedef struct NIST_EC_DRBG_Ctx
{
    PEllipticCurvePtr pCurve;
    const BulkHashAlgo* pBHA;
    ubyte4 reseedCounter;
    ubyte4 outLenBits;   /* in bits */
    ubyte4 seedLenBits;  /* in bits */
    PFEPtr s;
    PFEPtr d;
    PFEPtr pQx;
    PFEPtr pQy;
    PFEPtr tmpX;
    PFEPtr tmpY;
    ubyte* byteBuff;
} NIST_EC_DRBG_Ctx;


#define SECRET_BYTES_LENGTH(c)  (2 * ((c->pCurve->pPF->numBits + 7) / 8) )

/*-------------------------------------------------------------------------*/

#if !defined( __DISABLE_DIGICERT_ECC_P521__)
#define MAX_EC_SEED_LEN    (521+7/8)
#elif !defined(__DISABLE_DIGICERT_ECC_P384__)
#define MAX_EC_SEED_LEN    (384/8)
#else
#define MAX_EC_SEED_LEN    (256/8)
#endif


/*-----------------------------------------------------------------------*/

static MSTATUS
NIST_ECDRBG_setPFEFromBitString( PrimeFieldPtr pPF, PFEPtr k, ubyte* bits, ubyte4 bitLen)
{
    /* set k with the value of the bits in bits generated by the Hash_df function
        the specs says to use the leftmost bits */
    ubyte4 i, shift, numBytes;

    /* bitLen > 0 => numBytes >= 1 */
    numBytes = (bitLen + 7) / 8;
    shift = 8 - (bitLen % 8);

    if (shift != 8) /* we need to shift */
    {
        ubyte u, v;

        u = 0;
        for (i = 0; i < numBytes; ++i)
        {
             v = bits[i];
             bits[i] = (u | (v >> shift));
             u = (v << (8 - shift));
        }
    }

    /* we cannot use PRIMEFIELD_setToByteString because it checks
    that k is less than the p of the curve */
    BI_setUnitsToByteString( pPF->n, k->units, bits, numBytes);
    /* we don't make sure it's less than the order of the curve ...*/

    return OK;
}


/*-----------------------------------------------------------------------*/

static MSTATUS
NIST_ECDRBG_getBitStringFromPFE( PrimeFieldPtr pPF,
                             ConstPFEPtr k, ubyte** bits, sbyte4* bitLen)
{
    MSTATUS status = OK;
    ubyte4 i, shift, numBytes;
    ubyte* b = 0;

    /* convert s to a byte string padded on the right with 0 */
    if (OK > ( status = PRIMEFIELD_getAsByteString( pPF, k, &b, bitLen)))
    {
        goto exit;
    }
    (*bitLen) *= 8;

    /* pad with 0 -- necessary only for EC_P521 */
    numBytes = (pPF->numBits + 7) / 8;
    shift = 8 - (pPF->numBits % 8);

    if (shift != 8) /* we need to shift left */
    {
        for (i = 0; i < numBytes - 1; ++i)
        {
             b[i] <<= shift;
             b[i] |= ( (b[i+1]) >> (8 - shift));
        }
        /* last one */
        b[numBytes -1] <<= shift;
    }

    *bits = b;
    b = 0;

exit:
    if ( b)
    {
        FREE(b);
    }
    return status;
}



/*-------------------------------------------------------------------*/

static MSTATUS
NIST_RNG_Hash_df(MOC_HASH(hwAccelDescr hwAccelCtx)
                 const BulkHashAlgo* pBHA,
                 const ubyte* inputs[/*numInputs*/],
                 ubyte4 inputLens[/*numInputs*/],
                 ubyte4 numInputs,
                 ubyte* output, ubyte4 outputLenBits)
{
    MSTATUS status = OK;
    BulkCtx ctx = 0;
    ubyte* cryptoBuff = 0;
    ubyte* resultBuff;
    ubyte4 i, totalInputLen;
    ubyte4 outputLenBytes;

    outputLenBytes = (outputLenBits + 7) /8;

    if ( outputLenBytes > (pBHA->digestSize * 255))
    {
        return ERR_NIST_RNG_HASH_DF_BAD_OUTPUT_LEN;
    }

    totalInputLen = 0;
    for (i = 0; i < numInputs; ++i)
    {
        totalInputLen += inputLens[i];
    }

    if (OK > ( status = CRYPTO_ALLOC( hwAccelCtx, 5 + totalInputLen + pBHA->digestSize,
                                     TRUE, &cryptoBuff)))
    {
        goto exit;
    }

    /* allocate a hash context */
    if (OK > ( status = pBHA->allocFunc( MOC_HASH(hwAccelCtx) &ctx)))
        goto exit;

    BIGEND32( cryptoBuff+1, outputLenBits); /* outputLen in bits */
    resultBuff = cryptoBuff + 5;
    for (i = 0; i < numInputs; ++i)
    {
        DIGI_MEMCPY( resultBuff, inputs[i], inputLens[i]);
        resultBuff += inputLens[i];
    }

    for (cryptoBuff[0] = 1; outputLenBytes; ++(cryptoBuff[0]))
    {
        if (OK > ( status = pBHA->initFunc(MOC_HASH(hwAccelCtx) ctx)))
        {
            goto exit;
        }

        /* send first part of buffer */
        if (OK > ( status = pBHA->updateFunc( MOC_HASH(hwAccelCtx) ctx,
                                             cryptoBuff, 5 + totalInputLen)))
        {
            goto exit;
        }

        /* retrieve result in last part of buffer */
        if (OK > ( status = pBHA->finalFunc( MOC_HASH(hwAccelCtx) ctx,
                                            resultBuff)))
        {
            goto exit;
        }
        /* copy to result and increment loop counters */
        if (outputLenBytes >= pBHA->digestSize)
        {
            DIGI_MEMCPY( output, resultBuff, pBHA->digestSize);
            output += pBHA->digestSize;
            outputLenBytes -= pBHA->digestSize;
        }
        else
        {
            DIGI_MEMCPY( output, resultBuff, outputLenBytes);
            outputLenBytes = 0;
        }
    }

exit:
    CRYPTO_FREE( hwAccelCtx, TRUE, &cryptoBuff);

    pBHA->freeFunc( MOC_HASH(hwAccelCtx) &ctx);

    return status;
}


/*-----------------------------------------------------------------------*/

MSTATUS
NIST_ECDRBG_newContext( MOC_HASH(hwAccelDescr hwAccelCtx)
                       NIST_EC_DRBG_Ctx **ppNewContext,
                       PEllipticCurvePtr pCurve,
                       ubyte4 rsaHashAlgoId,
                       const ubyte* d, ubyte4 dLen,
                       const ubyte* entropyInput, ubyte4 entropyInputLen,
                       const ubyte* nonce, ubyte4 nonceLen,
                       const ubyte* personalization, ubyte4 personalizationLen)
{
    MSTATUS status = OK;
    PrimeFieldPtr pPF;
    NIST_EC_DRBG_Ctx* pNewCtx = NULL;
    ubyte* inputs[3];
    ubyte4 inputLens[3];
    ubyte seed[MAX_EC_SEED_LEN];


    if (!ppNewContext || !entropyInput || !entropyInputLen ||
        !nonce || !nonceLen)
    {
        status = ERR_NULL_POINTER;
        goto exit;
    }

    /* make sure d is the correct size for the curve */


    /* check lengths of arguments must be less than 2^13 bits or 2 ^ 10 bytes or 1024 bytes */
    if ( (entropyInputLen > 1024) || (personalizationLen > 1024))
    {
        status = ERR_NIST_RNG_EC_DRBG_ARG_TOO_LONG;
        goto exit;
    }

    pNewCtx = (NIST_EC_DRBG_Ctx*) MALLOC(sizeof(NIST_EC_DRBG_Ctx));
    if (!pNewCtx)
    {
        status = ERR_MEM_ALLOC_FAIL;
        goto exit;
    }
    DIGI_MEMSET( (ubyte*) pNewCtx, 0,  sizeof(NIST_EC_DRBG_Ctx));
    pNewCtx->pCurve = pCurve;
    pNewCtx->reseedCounter = 0;

#ifndef __DISABLE_DIGICERT_ECC_P256__
    if (EC_compareEllipticCurves(EC_P256, pCurve))
    {

        /* max security strength = 128 */
        /* make sure entropy and nonce len are big enough (128 bits and 128/2 bits resp) */
        if (entropyInputLen < 16 || nonceLen < 8)
        {
            status = ERR_NIST_RNG_EC_ENTROPY_OR_NONCE_TOO_SHORT;
            goto exit;
        }
        /* check the hash algo is be compatible with that curve */
        if (rsaHashAlgoId != ht_sha1 && rsaHashAlgoId != ht_sha224 &&
            rsaHashAlgoId != ht_sha256 && rsaHashAlgoId != ht_sha384 &&
            rsaHashAlgoId != ht_sha512)
        {
            status = ERR_NIST_RNG_EC_DBRG_INVALID_HASH_ID;
            goto exit;
        }
        pNewCtx->seedLenBits = 256;
        pNewCtx->outLenBits = 240; /* 30 bytes */
    }
    else
#endif
#ifndef __DISABLE_DIGICERT_ECC_P384__
    if (EC_compareEllipticCurves(EC_P384, pCurve))
    {
        /* max security strength = 192 */
        if (entropyInputLen < 24 || nonceLen < 12)
        {
            status = ERR_NIST_RNG_EC_ENTROPY_OR_NONCE_TOO_SHORT;
            goto exit;
        }

        if (rsaHashAlgoId != ht_sha224 &&
            rsaHashAlgoId != ht_sha256 && rsaHashAlgoId != ht_sha384 &&
            rsaHashAlgoId != ht_sha512)
        {
            status = ERR_NIST_RNG_EC_DBRG_INVALID_HASH_ID;
            goto exit;
        }
        pNewCtx->seedLenBits = 384;
        pNewCtx->outLenBits = 368; /* 46 bytes */
    }
    else
#endif
#ifndef __DISABLE_DIGICERT_ECC_P521__
    if (EC_compareEllipticCurves(EC_P521, pCurve))
    {
        /* max security strength = 256 */
        if (entropyInputLen < 32 || nonceLen < 16)
        {
            status = ERR_NIST_RNG_EC_ENTROPY_OR_NONCE_TOO_SHORT;
            goto exit;
        }

        if (rsaHashAlgoId != ht_sha256 && rsaHashAlgoId != ht_sha384 &&
            rsaHashAlgoId != ht_sha512)
        {
            status = ERR_NIST_RNG_EC_DBRG_INVALID_HASH_ID;
            goto exit;
        }
        pNewCtx->seedLenBits = 521;
        pNewCtx->outLenBits = 504; /* 63 bytes */
    }
    else
#endif
    {
        status = ERR_NIST_RNG_UNSUPPORTED_CURVE;
        goto exit;
    }


    if (OK > ( status = CRYPTO_getRSAHashAlgo(rsaHashAlgoId, &pNewCtx->pBHA)))
    {
        goto exit;
    }

    /* generate the initial seed */
    inputs[0] = (ubyte *) entropyInput; inputLens[0] = entropyInputLen;
    inputs[1] = (ubyte *) nonce; inputLens[1] = nonceLen;
    inputs[2] = (ubyte *) personalization; inputLens[2] = personalizationLen;
    if (OK > ( status = NIST_RNG_Hash_df( MOC_HASH(hwAccelCtx)
                                          pNewCtx->pBHA, (const ubyte**) inputs,
                                          inputLens,
                                         (inputs[2] && inputLens[2]) ? 3 : 2,
                                         seed, pNewCtx->seedLenBits)))
    {
        goto exit;
    }


    pPF = EC_getUnderlyingField( pCurve);

    if (OK > ( status = PRIMEFIELD_newElement( pPF, &pNewCtx->d)))
    {
        goto exit;
    }

    if (OK > ( status = PRIMEFIELD_setToByteString(pPF, pNewCtx->d, d, dLen)))
    {
        status = ERR_INVALID_ARG;
        goto exit;
    }

    /* generate the Q point from d and the curve P */
    if (OK > ( status = PRIMEFIELD_newElement( pPF, &pNewCtx->pQx)))
    {
        goto exit;
    }
    if (OK > ( status = PRIMEFIELD_newElement( pPF, &pNewCtx->pQy)))
    {
        goto exit;
    }

    if (OK > ( status = EC_multiplyPoint(pPF, pNewCtx->pQx, pNewCtx->pQy,
                                         pNewCtx->d, pCurve->pPx, pCurve->pPy)))
    {
        goto exit;
    }

    if (OK > ( status = PRIMEFIELD_newElement( pPF, &pNewCtx->s)))
    {
        goto exit;
    }
    if (OK > ( status = PRIMEFIELD_newElement( pPF, &pNewCtx->tmpX)))
    {
        goto exit;
    }
    if (OK > ( status = PRIMEFIELD_newElement( pPF, &pNewCtx->tmpY)))
    {
        goto exit;
    }

    pNewCtx->byteBuff = (ubyte*) MALLOC(2 * ((pPF->numBits + 7) / 8)); /* generated  + history */
    if (!pNewCtx->byteBuff)
    {
        status = ERR_MEM_ALLOC_FAIL;
        goto exit;
    }

    if (OK > ( status = NIST_ECDRBG_setPFEFromBitString( pPF, pNewCtx->s,
                                                        seed, pNewCtx->seedLenBits)))
    {
        goto exit;
    }

    *ppNewContext = pNewCtx;
    pNewCtx = 0;


exit:

    NIST_ECDRBG_deleteContext(&pNewCtx);
    return status;

}


/*-----------------------------------------------------------------------*/

MSTATUS NIST_ECDRBG_deleteContext( NIST_EC_DRBG_Ctx **ppNewContext)
{
    NIST_EC_DRBG_Ctx* pCtx = NULL;
    PrimeFieldPtr pField = NULL;

    if (!ppNewContext || !*ppNewContext)
    {
        return ERR_NULL_POINTER;
    }

    pCtx = (NIST_EC_DRBG_Ctx*)(*ppNewContext);

    if (pCtx->pCurve)
    {
        pField = EC_getUnderlyingField(pCtx->pCurve);

        PRIMEFIELD_deleteElement( pField, &pCtx->s);
        PRIMEFIELD_deleteElement( pField, &pCtx->tmpX);
        PRIMEFIELD_deleteElement( pField, &pCtx->tmpY);
        PRIMEFIELD_deleteElement( pField, &pCtx->d);
        PRIMEFIELD_deleteElement( pField, &pCtx->pQx);
        PRIMEFIELD_deleteElement( pField, &pCtx->pQy);
    }

    if ( (pCtx->byteBuff) && pField )
    {
        DIGI_MEMSET( pCtx->byteBuff, 0, (pField->numBits + 7) / 8);
        FREE(pCtx->byteBuff);
    }

    DIGI_MEMSET( (ubyte*) pCtx, 0, sizeof(NIST_EC_DRBG_Ctx));
    FREE(pCtx);

    *ppNewContext = 0;

    return OK;
}


/*-----------------------------------------------------------------------*/

MSTATUS
NIST_ECDRBG_getSecretLength( NIST_EC_DRBG_Ctx* pContext, ubyte4* secretLength)
{
    if (!pContext || !secretLength)
    {
        return ERR_NULL_POINTER;
    }

    *secretLength = SECRET_BYTES_LENGTH(pContext);
    return OK;
}


/*-----------------------------------------------------------------------*/

MSTATUS
NIST_ECDRBG_reseed( MOC_HASH(hwAccelDescr hwAccelCtx) NIST_EC_DRBG_Ctx* pCtx,
                    const ubyte* entropyInput, ubyte4 entropyInputLen,
                    const ubyte* additionalInput, ubyte4 additionalInputLen)
{
    MSTATUS status = OK;
    ubyte* bits = 0;
    sbyte4 bitsLen;
    PrimeFieldPtr pPF;
    ubyte seed[MAX_EC_SEED_LEN];
    ubyte* inputs[3];
    ubyte4 inputLens[3];

    if ( !pCtx || !entropyInput )
        return ERR_NULL_POINTER;

    if (!additionalInput)
        additionalInputLen = 0;

    pPF = EC_getUnderlyingField(pCtx->pCurve);

    if (OK > ( status = NIST_ECDRBG_getBitStringFromPFE( pPF, pCtx->s,
                                                            &bits, &bitsLen)))
    {
        goto exit;
    }

    inputs[0] = bits; inputLens[0] = bitsLen/8;
    inputs[1] = (ubyte *) entropyInput; inputLens[1] = entropyInputLen;
    inputs[2] = (ubyte *) additionalInput; inputLens[2] = additionalInputLen;
    if (OK > ( status = NIST_RNG_Hash_df( MOC_HASH(hwAccelCtx)
                                          pCtx->pBHA, (const ubyte**)inputs,
                                          inputLens,
                                         (inputs[2] && inputLens[2]) ? 3 : 2,
                                         seed, pCtx->seedLenBits)))
    {
        goto exit;
    }

    if (OK > ( status = NIST_ECDRBG_setPFEFromBitString( pPF, pCtx->s,
                                                        seed, pCtx->seedLenBits)))
    {
        goto exit;
    }

    pCtx->reseedCounter = 0;

exit:

    if (bits)
    {
        FREE(bits);
    }

    return status;
}


/*--------------------------------------------------------------------------*/

MSTATUS NIST_ECDRBG_setStateFromOutput( MOC_HASH(hwAccelDescr hwAccelCtx)
                                       NIST_EC_DRBG_Ctx *pCtx,
                                       const ubyte* output,
                                       ubyte4  outputLen)
{
    MSTATUS status;
    PrimeFieldPtr pPF;
    ECCKey* pS1 = 0; /* used to store intermediate values */
    ECCKey* pS2 = 0; /* used to store intermediate values */

    if (!pCtx || !output)
    {
        return ERR_NULL_POINTER;
    }

    if (outputLen != SECRET_BYTES_LENGTH(pCtx))
    {
        return ERR_INVALID_ARG;
    }


    pPF = EC_getUnderlyingField(pCtx->pCurve);

    /* allocate temporary storage for computations */
    if (OK > ( status = EC_newKey(pCtx->pCurve, &pS1)))
    {
        goto exit;
    }
    if (OK > ( status = EC_newKey(pCtx->pCurve, &pS2)))
    {
        goto exit;
    }

    if (OK > ( status = PRIMEFIELD_setToByteString(pPF, pS1->Qx,
                                                   output, outputLen/2)))
    {
        goto exit;
    }

    /* pS2->k = second part of output */
    if (OK > ( status = PRIMEFIELD_setToByteString(pPF, pS2->k,
                                                   output + outputLen/2,
                                                   outputLen/2)))
    {
        goto exit;
    }

    /* compute the e factor into pS1->k */
    if (OK > ( status = PRIMEFIELD_inverseAux(pPF->n, pS1->k, pCtx->d,
                                              pCtx->pCurve->n)))
    {
        goto exit;
    }

    /* compute one of the 2 y coord and try it */
    if (OK > ( status = EC_computeYFromX(pCtx->pCurve, pS1->Qx, pS1->Qy)))
    {
        goto exit;
    }

    /* compute e * Qx Qy -> one possible state s in tmpX */
    if (OK > ( status = EC_multiplyPoint(pPF, pCtx->tmpX, pCtx->tmpY,
                                         pS1->k, pS1->Qx, pS1->Qy)))
    {
        goto exit;
    }

    /* try that state (tmpX) to see if it generates the rest of the output */
    if (OK > ( status = EC_multiplyPoint(pPF, pS2->Qx, pS2->Qy,
                                         pCtx->tmpX,
                                         pCtx->pQx, pCtx->pQy)))
    {
        goto exit;
    }

    if ( PRIMEFIELD_match(pPF, pS2->k, pS2->Qx))
    {
        goto match;
    }

    /* compute the other y coord into pS2->Qy */
    if (OK > (status = PRIMEFIELD_copyElement(pPF, pS2->Qy,
                                              (ConstPFEPtr) pPF->units)))
    {
        goto exit;
    }

    if (OK > ( status = PRIMEFIELD_subtract(pPF, pS2->Qy, pS1->Qy)))
    {
        goto exit;
    }

    /* compute e * Qx Qy -> one possible state s in tmpX */
    if (OK > ( status = EC_multiplyPoint(pPF, pCtx->tmpX, pCtx->tmpY,
                                         pS1->k, pS1->Qx, pS2->Qy)))
    {
        goto exit;
    }

    /* try that state (tmpX) to see if it generates the rest of the output */
    if (OK > ( status = EC_multiplyPoint(pPF, pS2->Qx, pS2->Qy,
                                         pCtx->tmpX,
                                         pCtx->pQx, pCtx->pQy)))
    {
        goto exit;
    }

    if ( PRIMEFIELD_match(pPF, pS2->k, pS2->Qx))
    {
        goto match;
    }

    status = ERR_FALSE;
    goto exit;

match:

    /* match -- one more multiplication to get the state */
    status = EC_multiplyPoint(pPF, pCtx->s, pCtx->tmpY, pCtx->tmpX,
                              pCtx->pCurve->pPx, pCtx->pCurve->pPy);

exit:

    EC_deleteKey(&pS1);
    EC_deleteKey(&pS2);

    return status;
}


/*-----------------------------------------------------------------------*/

MSTATUS
NIST_ECDRBG_generate(MOC_HASH(hwAccelDescr hwAccelCtx)
                     NIST_EC_DRBG_Ctx* pCtx,
                     const ubyte* additionalInput,
                     ubyte4 additionalInputLen,
                     ubyte* output, ubyte4 outputLenBits)
{
    MSTATUS status = OK;
    ubyte4 newCounter;
    ubyte seed[MAX_EC_SEED_LEN];
    PrimeFieldPtr pPF;
    PFEPtr addend = 0;

    if ( !pCtx || !output )
    {
        return ERR_NULL_POINTER;
    }

    if (!additionalInput)
    {
        additionalInputLen = 0;
    }

    newCounter = pCtx->reseedCounter +
            ((outputLenBits + pCtx->outLenBits - 1)  /  pCtx->outLenBits);

    if (newCounter == pCtx->reseedCounter) /* can happen if outputLenBits == 0 */
    {
        ++newCounter; /* still an increment */
    }

    if (newCounter < pCtx->reseedCounter ) /* overflow */
    {
        return ERR_NIST_RNG_DBRG_RESEED_NEEDED;
    }

    pPF = EC_getUnderlyingField(pCtx->pCurve);

    if (OK > ( status = PRIMEFIELD_newElement( pPF, &addend)))
    {
        goto exit;
    }

    if ( additionalInput && additionalInputLen)
    {
        if (OK > ( status = NIST_RNG_Hash_df(MOC_HASH(hwAccelCtx) pCtx->pBHA, &additionalInput,
                                                &additionalInputLen, 1,
                                                seed, pCtx->seedLenBits)))
        {
            goto exit;
        }

        if (OK > ( status = NIST_ECDRBG_setPFEFromBitString( pPF, addend, seed,
                                                          pCtx->seedLenBits)))
        {
            goto exit;
        }
    }
    else
    {
        if (OK > ( status = PRIMEFIELD_setToUnsigned( pPF, addend, 0)))
        {
            goto exit;
        }
    }

    do
    {
        /* xor the two field elements */
        if (OK > ( status = PRIMEFIELD_xor( pPF, pCtx->s, addend)))
        {
            goto exit;
        }

        if (OK > ( status = EC_modOrder( pCtx->pCurve, pCtx->s)))
        {
            goto exit;
        }

        /* first point multiplication -- s(i) * P -> r */
        if (OK > (status = EC_multiplyPoint( pPF, pCtx->s, pCtx->tmpY, pCtx->s,
                                            pCtx->pCurve->pPx,
                                            pCtx->pCurve->pPy)))
        {
            goto exit;
        }

        /* second point multiplication -- r * Q -> t  */
        if (OK > (status = EC_multiplyPoint( pPF, pCtx->tmpX, pCtx->tmpY,
                                            pCtx->s, pCtx->pQx, pCtx->pQy)))
        {
            goto exit;
        }

        /* convert to byte string */
        if (OK > ( status = PRIMEFIELD_writeByteString( pPF, pCtx->tmpX,
                                                       pCtx->byteBuff,
                                                        (pPF->numBits + 7) / 8)))
        {
            goto exit;
        }

        if ( outputLenBits < pCtx->outLenBits)
        {
            DIGI_MEMCPY( output,
                        pCtx->byteBuff + ((pPF->numBits + 7 - pCtx->outLenBits) / 8),
                        (outputLenBits + 7) / 8);
            output += (outputLenBits / 8);
            outputLenBits %= 8;
            if (outputLenBits)
            {
                output[0] &=  ~(0x00FFU >> outputLenBits);
            }
            outputLenBits = 0;
        }
        else
        {
            DIGI_MEMCPY( output,
                        pCtx->byteBuff + ((pPF->numBits + 7 - pCtx->outLenBits) / 8),
                        pCtx->outLenBits / 8);
            outputLenBits -= pCtx->outLenBits;
            output += (pCtx->outLenBits / 8);
        }

        ++(pCtx->reseedCounter);

    } while ( outputLenBits);

    /* one more multiplication  -- this is the state */
    if (OK > (status = EC_multiplyPoint( pPF, pCtx->s, pCtx->tmpY, pCtx->s,
                                    pCtx->pCurve->pPx, pCtx->pCurve->pPy)))
    {
        goto exit;
    }

    /* clear other parts of the state */
    if (OK > ( status = PRIMEFIELD_setToUnsigned( pPF, pCtx->tmpX, 0)))
    {
        goto exit;
    }
    if (OK > ( status = PRIMEFIELD_setToUnsigned( pPF, pCtx->tmpY, 0)))
    {
        goto exit;
    }
    DIGI_MEMSET( pCtx->byteBuff, 0, (pPF->numBits + 7) / 8);

exit:

    PRIMEFIELD_deleteElement( pPF, &addend);

    return status;
}


/*---------------------------------------------------------------------------*/

MSTATUS
NIST_ECDRBG_generateSecret(MOC_HASH(hwAccelDescr hwAccelCtx)
                           NIST_EC_DRBG_Ctx* pCtx,
                           const ubyte* additionalInput,
                           ubyte4 additionalInputLen,
                           ubyte* secret, ubyte4 secretLenBytes)
{
    MSTATUS status = OK;
    ubyte4 newCounter;
    ubyte seed[MAX_EC_SEED_LEN];
    PrimeFieldPtr pPF;
    PFEPtr addend = 0;
    int i;

    if ( !pCtx || !secret )
    {
        return ERR_NULL_POINTER;
    }

    if (secretLenBytes != SECRET_BYTES_LENGTH(pCtx))
    {
        return ERR_INVALID_ARG;
    }

    if (!additionalInput)
    {
        additionalInputLen = 0;
    }

    newCounter = pCtx->reseedCounter + 2;

    if (newCounter < pCtx->reseedCounter ) /* overflow */
    {
        return ERR_NIST_RNG_DBRG_RESEED_NEEDED;
    }

    pPF = EC_getUnderlyingField(pCtx->pCurve);

    if (OK > ( status = PRIMEFIELD_newElement( pPF, &addend)))
    {
        goto exit;
    }

    if ( additionalInput && additionalInputLen)
    {
        if (OK > ( status = NIST_RNG_Hash_df(MOC_HASH(hwAccelCtx) pCtx->pBHA, &additionalInput,
                                             &additionalInputLen, 1,
                                             seed, pCtx->seedLenBits)))
        {
            goto exit;
        }

        if (OK > ( status = NIST_ECDRBG_setPFEFromBitString( pPF, addend, seed,
                                                            pCtx->seedLenBits)))
        {
            goto exit;
        }
    }
    else
    {
        if (OK > ( status = PRIMEFIELD_setToUnsigned( pPF, addend, 0)))
        {
            goto exit;
        }
    }

    /* do two rounds */
    for ( i = 0; i < 2; ++i)
    {
        /* xor the two field elements */
        if (OK > ( status = PRIMEFIELD_xor( pPF, pCtx->s, addend)))
        {
            goto exit;
        }

        if (OK > ( status = EC_modOrder( pCtx->pCurve, pCtx->s)))
        {
            goto exit;
        }

        /* first point multiplication -- s(i) * P -> r */
        if (OK > (status = EC_multiplyPoint( pPF, pCtx->s, pCtx->tmpY, pCtx->s,
                                            pCtx->pCurve->pPx,
                                            pCtx->pCurve->pPy)))
        {
            goto exit;
        }

        /* second point multiplication -- r * Q -> t  */
        if (OK > (status = EC_multiplyPoint( pPF, pCtx->tmpX, pCtx->tmpY,
                                            pCtx->s, pCtx->pQx, pCtx->pQy)))
        {
            goto exit;
        }

        /* convert to byte string */
        if (OK > ( status = PRIMEFIELD_writeByteString( pPF, pCtx->tmpX,
                                                       secret + i * (SECRET_BYTES_LENGTH(pCtx)/2),
                                                       SECRET_BYTES_LENGTH(pCtx)/2)))
        {
            goto exit;
        }

        ++(pCtx->reseedCounter);

    }

    /* one more multiplication  -- this is the state */
    if (OK > (status = EC_multiplyPoint( pPF, pCtx->s, pCtx->tmpY, pCtx->s,
                                        pCtx->pCurve->pPx, pCtx->pCurve->pPy)))
    {
        goto exit;
    }

    /* clear other parts of the state */
    if (OK > ( status = PRIMEFIELD_setToUnsigned( pPF, pCtx->tmpX, 0)))
    {
        goto exit;
    }
    if (OK > ( status = PRIMEFIELD_setToUnsigned( pPF, pCtx->tmpY, 0)))
    {
        goto exit;
    }
    DIGI_MEMSET( pCtx->byteBuff, 0, (pPF->numBits + 7) / 8);

exit:

    PRIMEFIELD_deleteElement( pPF, &addend);

    return status;
}


/*-----------------------------------------------------------------------*/

MSTATUS NIST_ECDRBG_numberGenerator(MOC_HASH(hwAccelDescr hwAccelCtx)
                                    randomContext *pRandomContext,
                                    ubyte *pBuffer, sbyte4 bufSize)
{
    return NIST_ECDRBG_generate(MOC_HASH(hwAccelCtx)
                                (NIST_EC_DRBG_Ctx*) pRandomContext,
                                NULL, 0, pBuffer, bufSize * 8);
}


/*-----------------------------------------------------------------------*/

sbyte4 NIST_ECDRBG_rngFun(MOC_HASH(hwAccelDescr hwAccelCtx)
                          void* rngFunArg, ubyte4 length, ubyte *buffer)
{
    return NIST_ECDRBG_generate(MOC_HASH(hwAccelCtx)
                                (NIST_EC_DRBG_Ctx*) rngFunArg,
                                NULL, 0, buffer, length * 8);
}


#endif /* __ENABLE_DIGICERT_ECC__ */
#endif /* __ENABLE_DIGICERT_RNG_DRBG_ECC__ */
