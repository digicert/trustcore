/*
 * cert_chain_test.c
 *
 * unit test for cert_chain.c
 *
 * Copyright 2025 DigiCert Project Authors. All Rights Reserved.
 * 
 * DigiCert® TrustCore and TrustEdge are licensed under a dual-license model:
 * - **Open Source License**: GNU AGPL v3. See: https://github.com/digicert/trustcore-test/blob/main/LICENSE
 * - **Commercial License**: Available under DigiCert’s Master Services Agreement. See: https://github.com/digicert/trustcore-test/blob/main/LICENSE_COMMERCIAL.txt  
 *   or https://www.digicert.com/master-services-agreement/
 * 
 * *For commercial licensing, contact DigiCert at sales@digicert.com.*
 *
 */

#include "../../common/moptions.h"

#include "../../common/mtypes.h"
#include "../../common/mocana.h"
#include "../../crypto/hw_accel.h"

#include "../../common/mdefs.h"
#include "../../common/merrors.h"
#include "../../common/mrtos.h"
#include "../../common/mstdlib.h"
#include "../../common/absstream.h"
#include "../../common/random.h"
#include "../../crypto/ca_mgmt.h"
#include "../../crypto/cert_store.h"
#include "../../crypto/cert_chain.h"
#include "../../crypto/pubcrypto.h"

#include "../../common/tree.h"
#include "../../asn1/parseasn1.h"
#include "../../asn1/parsecert.h"
#include "../../asn1/oiddefs.h"

#include "../../../unit_tests/unittest.h"

typedef struct CertChainTest
{
    const char* fileName;
    ubyte keyUsage;
    int numCerts;
    int complete;
    const sbyte* goodNames;
    const sbyte* badNames;

} CertChainTest;

static CertChainTest gTests1[] =
{
    {
        "ssl_msg_certificate1.dat", (1 << digitalSignature) | (1  << keyEncipherment),
        3, 0,
        (const sbyte*)"server1.smoot.apple.com\0check.smoot.apple.com\0\0",
        (const sbyte*)"server1.sm0ot.apple.com\0store.apple.com\0google.com\0\0"
    },
    {
        "ssl_msg_certificate2.dat", (1 << digitalSignature) | (1  << keyEncipherment),
        3, 0,
        (const sbyte*)"gs-loc.apple.com\0\0",
        (const sbyte*)"server1.gs-loc.apple.com\0\0"
    },
    {
        "ssl_msg_certificate3.dat", (1 << digitalSignature),
        3, 0,
        (const sbyte*)"mocana.googleusercontent.com\0storage.googleapis.com\0mocana.blogspot.com\0spy.googlesyndication.com\0\0",
        (const sbyte*)"test.google.com\0google.com\0ggpht1.com\0\0"
    },
    {
        "ssl_msg_certificate4.dat", (1 << digitalSignature),
        3, 0,
        (const sbyte*)"mocana.android.com\0mocana.google.fr\0urchin.com\0test.urchin.com\0youtu.be\0youtube.com\0hell.gvt1.com\0\0",
        (const sbyte*)"www.google.co.fr\0test.gvt3.com\0\0"
    },
    {
        "ssl_msg_certificate5.dat",  (1 << digitalSignature) | (1  << keyEncipherment),
        3, 1,
        (const sbyte*)"static.wellsfargo.com\0\0",
        (const sbyte*)"rogue.static.wellsfargo.com\0wellsfargo.com\0wellsfargo.ru\0\0"
    },
};

/* These root certs are trust points for gTests1 chains */
static const char* gRootCerts[] =
{
    "Equifax_Secure_Certificate_Authority.der",
    "VerisignClass3RootG5.der",
    "VerisignClass3RootMD2.der",
    "VerisignClass3RootSHA1.der",
};


/* These ones are not trust points for gTests1 chains */
static const char* gOtherRootCerts[] =
{
    "VerisignClass1PublicPrimaryCAMD2.der",
    "VerisignClass1PublicPrimaryCASHA1.der",
};

/* These ones are fake trust points (issuer names are good but keys are wrong) */
static const char* gFakeRootCerts[] =
{
    "FakeEquifax_Secure_Certificate_Authority.der",
    "FakeVerisignClass3RootG5.der",
    "FakeVerisignClass3RootMD2.der",
    "FakeVerisignClass3RootSHA1.der",
};

static const sbyte4 kNumTests1 = COUNTOF(gTests1);

ubyte gpRoot[944] = {
  0x30, 0x82, 0x03, 0xac, 0x30, 0x82, 0x02, 0x94, 0xa0, 0x03, 0x02, 0x01,
  0x02, 0x02, 0x09, 0x00, 0xa6, 0x61, 0xb3, 0x73, 0xf2, 0xd8, 0x94, 0x70,
  0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
  0x0b, 0x05, 0x00, 0x30, 0x6b, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,
  0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03,
  0x55, 0x04, 0x08, 0x0c, 0x0a, 0x43, 0x61, 0x6c, 0x69, 0x66, 0x6f, 0x72,
  0x6e, 0x69, 0x61, 0x31, 0x16, 0x30, 0x14, 0x06, 0x03, 0x55, 0x04, 0x07,
  0x0c, 0x0d, 0x53, 0x61, 0x6e, 0x20, 0x46, 0x72, 0x61, 0x6e, 0x63, 0x69,
  0x73, 0x63, 0x6f, 0x31, 0x11, 0x30, 0x0f, 0x06, 0x03, 0x55, 0x04, 0x0a,
  0x0c, 0x08, 0x52, 0x6f, 0x6f, 0x74, 0x20, 0x4c, 0x74, 0x64, 0x31, 0x1c,
  0x30, 0x1a, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x13, 0x77, 0x77, 0x77,
  0x2e, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72, 0x6f, 0x6f, 0x74,
  0x2e, 0x63, 0x6f, 0x6d, 0x30, 0x1e, 0x17, 0x0d, 0x31, 0x39, 0x30, 0x33,
  0x31, 0x39, 0x32, 0x30, 0x31, 0x38, 0x33, 0x32, 0x5a, 0x17, 0x0d, 0x33,
  0x32, 0x31, 0x31, 0x32, 0x35, 0x32, 0x30, 0x31, 0x38, 0x33, 0x32, 0x5a,
  0x30, 0x6b, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13,
  0x02, 0x55, 0x53, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08,
  0x0c, 0x0a, 0x43, 0x61, 0x6c, 0x69, 0x66, 0x6f, 0x72, 0x6e, 0x69, 0x61,
  0x31, 0x16, 0x30, 0x14, 0x06, 0x03, 0x55, 0x04, 0x07, 0x0c, 0x0d, 0x53,
  0x61, 0x6e, 0x20, 0x46, 0x72, 0x61, 0x6e, 0x63, 0x69, 0x73, 0x63, 0x6f,
  0x31, 0x11, 0x30, 0x0f, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x08, 0x52,
  0x6f, 0x6f, 0x74, 0x20, 0x4c, 0x74, 0x64, 0x31, 0x1c, 0x30, 0x1a, 0x06,
  0x03, 0x55, 0x04, 0x03, 0x0c, 0x13, 0x77, 0x77, 0x77, 0x2e, 0x65, 0x78,
  0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72, 0x6f, 0x6f, 0x74, 0x2e, 0x63, 0x6f,
  0x6d, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48,
  0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f,
  0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xb6, 0xac,
  0x85, 0x72, 0x34, 0xc9, 0x49, 0xbc, 0xc1, 0x1d, 0x48, 0x70, 0x77, 0x43,
  0x09, 0x2a, 0xc9, 0xa8, 0xe7, 0x21, 0x40, 0x22, 0x21, 0xb0, 0x80, 0xc5,
  0xa1, 0x66, 0x40, 0xfb, 0x6c, 0xaf, 0x6e, 0x0a, 0x57, 0xf6, 0x27, 0xc7,
  0x9a, 0x6f, 0xd1, 0x64, 0x70, 0x14, 0x68, 0x60, 0x79, 0x7b, 0xdc, 0xf1,
  0xcd, 0xed, 0xb9, 0x9a, 0xe3, 0x74, 0x89, 0xfe, 0x7d, 0xe4, 0xdb, 0xef,
  0x2e, 0x26, 0x28, 0x37, 0xe7, 0x2a, 0xae, 0x7e, 0xe6, 0x96, 0x6e, 0x41,
  0x33, 0x83, 0x1f, 0x5c, 0x03, 0x0b, 0x0c, 0xf6, 0x27, 0xa4, 0xe5, 0x1c,
  0x0b, 0x9c, 0xb3, 0x34, 0x2e, 0xdf, 0xbf, 0x14, 0x1b, 0x53, 0x23, 0x21,
  0xd3, 0x3b, 0x2f, 0xe4, 0xf1, 0xbd, 0xc4, 0x29, 0xeb, 0x36, 0x31, 0xa5,
  0x57, 0xe2, 0x39, 0xb9, 0xfa, 0x53, 0x88, 0x7b, 0xfc, 0x70, 0xfb, 0x27,
  0x14, 0xb1, 0x7c, 0xb4, 0x7d, 0x90, 0x18, 0x07, 0x7a, 0x21, 0x54, 0x3d,
  0x7b, 0xa2, 0x12, 0x01, 0xe6, 0xe6, 0x0b, 0x6f, 0xd9, 0x40, 0x78, 0xcc,
  0xc7, 0xaa, 0xfa, 0x71, 0xcb, 0x7e, 0x26, 0x9e, 0x70, 0x6e, 0x98, 0x7f,
  0xff, 0x56, 0xd2, 0x56, 0xac, 0x55, 0x0f, 0xbf, 0xc2, 0xae, 0x0b, 0xbb,
  0x6b, 0x93, 0xd7, 0x99, 0x0c, 0xef, 0x71, 0x31, 0x93, 0x94, 0xe2, 0xdf,
  0x83, 0xcc, 0xfa, 0xd2, 0x5c, 0x52, 0x6b, 0xcb, 0xf4, 0x86, 0x2d, 0xdb,
  0xd9, 0x25, 0x9b, 0xd5, 0x94, 0x55, 0x7d, 0xfc, 0x66, 0x9e, 0x1a, 0x46,
  0x00, 0x26, 0xc7, 0x6e, 0x64, 0xbb, 0xb6, 0xf3, 0x5e, 0xbf, 0x69, 0xfc,
  0x44, 0x31, 0x3e, 0x5e, 0x40, 0x68, 0x0b, 0x68, 0x73, 0xb2, 0x62, 0x83,
  0xcc, 0x08, 0x58, 0x25, 0xdc, 0xe3, 0xc5, 0xa0, 0xc7, 0x00, 0x70, 0xe7,
  0x93, 0x41, 0x8f, 0x60, 0xe7, 0xb6, 0x93, 0xa2, 0xea, 0x20, 0x7b, 0xb6,
  0x5c, 0x97, 0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x53, 0x30, 0x51, 0x30,
  0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0x77, 0x79,
  0x41, 0x92, 0x66, 0x42, 0x4a, 0x14, 0x12, 0xc2, 0x4b, 0x28, 0x5d, 0xc9,
  0x1d, 0x1c, 0x9f, 0xe1, 0x1d, 0xcc, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d,
  0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0x77, 0x79, 0x41, 0x92, 0x66,
  0x42, 0x4a, 0x14, 0x12, 0xc2, 0x4b, 0x28, 0x5d, 0xc9, 0x1d, 0x1c, 0x9f,
  0xe1, 0x1d, 0xcc, 0x30, 0x0f, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x01, 0x01,
  0xff, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30, 0x0d, 0x06, 0x09,
  0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x03,
  0x82, 0x01, 0x01, 0x00, 0x7b, 0xbc, 0x66, 0x3c, 0x6f, 0x1b, 0x00, 0x23,
  0x2e, 0x8e, 0x1b, 0x6d, 0x26, 0x01, 0xd6, 0x17, 0x1c, 0x27, 0x82, 0xd6,
  0x9b, 0xd8, 0x76, 0xea, 0xc5, 0x9f, 0xa9, 0x12, 0x59, 0x32, 0x7e, 0x14,
  0x19, 0x6c, 0x53, 0x1a, 0xb3, 0x3a, 0xb6, 0x4b, 0xba, 0x28, 0x9c, 0x9a,
  0x8a, 0x1a, 0x5e, 0xb6, 0x3b, 0x39, 0x70, 0xb9, 0x17, 0xac, 0x05, 0x14,
  0x0a, 0x06, 0x7e, 0x3d, 0x84, 0x92, 0xef, 0x90, 0x0b, 0xb2, 0x17, 0x66,
  0x16, 0xca, 0x56, 0xeb, 0x21, 0x7f, 0x4d, 0x50, 0x12, 0x17, 0xcf, 0x1a,
  0xa7, 0x56, 0x46, 0xe7, 0x71, 0x41, 0xe2, 0x3e, 0x94, 0x33, 0x73, 0xde,
  0xe6, 0xda, 0x76, 0x53, 0xbd, 0x85, 0x6b, 0x43, 0x94, 0x2e, 0x18, 0x9e,
  0x9f, 0x45, 0x59, 0x91, 0x82, 0xb7, 0xf9, 0x10, 0xcc, 0x2b, 0xe2, 0x99,
  0x4c, 0xd2, 0xb9, 0xd6, 0xe7, 0x56, 0x0d, 0x90, 0xe2, 0x6c, 0x10, 0xbf,
  0x56, 0x06, 0x19, 0x9d, 0x51, 0x07, 0xda, 0x85, 0x03, 0xb6, 0x72, 0x61,
  0x85, 0x72, 0x9b, 0x52, 0x67, 0xba, 0x50, 0x30, 0x40, 0x33, 0x45, 0xf5,
  0x7a, 0xed, 0xd8, 0xe3, 0x6b, 0xe2, 0x5e, 0xbf, 0x64, 0xd2, 0xdf, 0xe9,
  0x78, 0xa2, 0x3b, 0x73, 0x6f, 0x15, 0x12, 0x2d, 0x3c, 0xe2, 0x9b, 0x31,
  0x42, 0xbe, 0xaf, 0x5a, 0x74, 0x48, 0xb9, 0x8d, 0xc3, 0xa8, 0x63, 0xa4,
  0x14, 0xe3, 0x73, 0xe9, 0x55, 0xfb, 0x03, 0x6c, 0x67, 0xc5, 0x6e, 0x51,
  0x00, 0x62, 0x8e, 0x1d, 0x9d, 0xd6, 0x62, 0xde, 0x88, 0xd4, 0x8b, 0x25,
  0x81, 0xc2, 0xc0, 0x61, 0x01, 0xc6, 0xeb, 0x34, 0x82, 0x99, 0x23, 0x92,
  0x48, 0xef, 0x4f, 0x61, 0x2a, 0x72, 0x3c, 0x36, 0x21, 0xd3, 0x61, 0xd2,
  0x28, 0xda, 0x33, 0x77, 0x01, 0x86, 0x08, 0x52, 0x39, 0xef, 0x63, 0xe3,
  0x5a, 0x00, 0xe3, 0x16, 0x8a, 0x6a, 0x10, 0xfc
};
ubyte4 gRootLen = 944;

ubyte gpIntermediate[881] = {
  0x30, 0x82, 0x03, 0x6d, 0x30, 0x82, 0x02, 0x55, 0xa0, 0x03, 0x02, 0x01,
  0x02, 0x02, 0x01, 0x02, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86,
  0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x30, 0x6b, 0x31, 0x0b, 0x30,
  0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x13,
  0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c, 0x0a, 0x43, 0x61, 0x6c,
  0x69, 0x66, 0x6f, 0x72, 0x6e, 0x69, 0x61, 0x31, 0x16, 0x30, 0x14, 0x06,
  0x03, 0x55, 0x04, 0x07, 0x0c, 0x0d, 0x53, 0x61, 0x6e, 0x20, 0x46, 0x72,
  0x61, 0x6e, 0x63, 0x69, 0x73, 0x63, 0x6f, 0x31, 0x11, 0x30, 0x0f, 0x06,
  0x03, 0x55, 0x04, 0x0a, 0x0c, 0x08, 0x52, 0x6f, 0x6f, 0x74, 0x20, 0x4c,
  0x74, 0x64, 0x31, 0x1c, 0x30, 0x1a, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c,
  0x13, 0x77, 0x77, 0x77, 0x2e, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65,
  0x72, 0x6f, 0x6f, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x30, 0x1e, 0x17, 0x0d,
  0x31, 0x39, 0x30, 0x33, 0x31, 0x39, 0x32, 0x30, 0x31, 0x38, 0x33, 0x32,
  0x5a, 0x17, 0x0d, 0x33, 0x32, 0x31, 0x31, 0x32, 0x35, 0x32, 0x30, 0x31,
  0x38, 0x33, 0x32, 0x5a, 0x30, 0x6a, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03,
  0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x11, 0x30, 0x0f, 0x06,
  0x03, 0x55, 0x04, 0x08, 0x0c, 0x08, 0x4e, 0x65, 0x77, 0x20, 0x59, 0x6f,
  0x72, 0x6b, 0x31, 0x11, 0x30, 0x0f, 0x06, 0x03, 0x55, 0x04, 0x07, 0x0c,
  0x08, 0x42, 0x72, 0x6f, 0x6f, 0x6b, 0x6c, 0x79, 0x6e, 0x31, 0x0f, 0x30,
  0x0d, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x06, 0x43, 0x41, 0x20, 0x4c,
  0x74, 0x64, 0x31, 0x24, 0x30, 0x22, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c,
  0x1b, 0x77, 0x65, 0x62, 0x61, 0x70, 0x70, 0x74, 0x61, 0x70, 0x2e, 0x73,
  0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x64, 0x65, 0x6d, 0x6f, 0x73,
  0x2e, 0x6e, 0x65, 0x74, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09,
  0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03,
  0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01,
  0x00, 0xdf, 0xe8, 0x95, 0x98, 0x40, 0xfa, 0xb3, 0x4f, 0x96, 0x76, 0xed,
  0x41, 0x8b, 0x57, 0xf2, 0xe9, 0xb3, 0x5e, 0xea, 0x30, 0x83, 0xcd, 0xb6,
  0x64, 0xf8, 0x6f, 0xec, 0x70, 0x2a, 0x55, 0x59, 0xde, 0xcb, 0xa3, 0xce,
  0x02, 0xd0, 0x6c, 0xde, 0x9a, 0xe0, 0x09, 0x61, 0xb2, 0xd6, 0x9f, 0x63,
  0x79, 0xdc, 0xec, 0x5d, 0xce, 0x9d, 0xf4, 0x4d, 0x3e, 0x57, 0xf6, 0x18,
  0xfb, 0x85, 0x12, 0x08, 0xc7, 0x10, 0x3e, 0xfb, 0x19, 0x25, 0xe4, 0xe2,
  0x18, 0x6b, 0x87, 0xae, 0xf6, 0x5b, 0x73, 0x22, 0x11, 0x87, 0xa2, 0x24,
  0xbb, 0xf7, 0xcd, 0xb9, 0x74, 0xbd, 0x1b, 0xd4, 0x24, 0xca, 0xce, 0x52,
  0x09, 0xda, 0x06, 0x3c, 0x83, 0xb9, 0x97, 0x17, 0x14, 0xfc, 0x65, 0x7b,
  0x04, 0xc3, 0xad, 0xe3, 0x69, 0xe1, 0x26, 0x19, 0xbd, 0x86, 0x7d, 0x7a,
  0xf8, 0x36, 0x8a, 0x6c, 0x01, 0xb3, 0x7c, 0xde, 0xdc, 0x87, 0xb0, 0xf4,
  0xb5, 0x82, 0x0e, 0xf3, 0x1d, 0x12, 0xe9, 0x1d, 0x5d, 0x4d, 0x49, 0xed,
  0x59, 0x73, 0x74, 0xdc, 0xa3, 0xe2, 0x69, 0x17, 0xca, 0x32, 0xc8, 0x7c,
  0x0d, 0x30, 0xf2, 0x23, 0x12, 0x6a, 0x14, 0x66, 0x86, 0x2e, 0xe3, 0xaa,
  0xa3, 0x5a, 0x96, 0x4b, 0xda, 0x15, 0xe8, 0x25, 0x7a, 0xee, 0xe4, 0x92,
  0x6b, 0xc1, 0x17, 0x0d, 0x9d, 0xc4, 0x7d, 0x17, 0x21, 0x26, 0xf1, 0x2c,
  0x66, 0xe3, 0xc4, 0x51, 0x42, 0x3b, 0x5c, 0x89, 0x21, 0x0a, 0x60, 0x21,
  0x72, 0xe9, 0x5e, 0xb3, 0xee, 0xd1, 0xe9, 0x1a, 0x0a, 0xcc, 0x26, 0x19,
  0x83, 0x07, 0x7d, 0x91, 0x56, 0x36, 0x8f, 0x89, 0xa4, 0x8c, 0x83, 0x3a,
  0x98, 0x9c, 0x0e, 0xaf, 0x67, 0xcf, 0xa8, 0x61, 0x8b, 0xe6, 0xa9, 0x1b,
  0xed, 0x11, 0x6b, 0xeb, 0x38, 0x3e, 0x73, 0xd9, 0x10, 0x33, 0xeb, 0xd6,
  0x80, 0x5c, 0xe0, 0xe7, 0x39, 0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x1d,
  0x30, 0x1b, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x04, 0x05, 0x30,
  0x03, 0x01, 0x01, 0xff, 0x30, 0x0b, 0x06, 0x03, 0x55, 0x1d, 0x0f, 0x04,
  0x04, 0x03, 0x02, 0x02, 0xa4, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48,
  0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01,
  0x00, 0x7d, 0x71, 0x78, 0xde, 0xb1, 0xa6, 0x48, 0xdc, 0x69, 0x94, 0xc0,
  0x14, 0x17, 0x75, 0xfe, 0x5f, 0x64, 0xf2, 0xb6, 0x7a, 0xea, 0xdb, 0xf0,
  0xdb, 0x9e, 0xc8, 0x17, 0x32, 0xa9, 0xfe, 0x0f, 0xab, 0x52, 0x2b, 0xe7,
  0x41, 0xe3, 0xc7, 0xbb, 0xdd, 0x4c, 0x7c, 0xb1, 0x44, 0x0b, 0x88, 0xc0,
  0xef, 0x63, 0x53, 0x00, 0x89, 0xa3, 0x1a, 0x53, 0x87, 0x64, 0x44, 0x99,
  0x2a, 0xdd, 0x6e, 0xbd, 0x25, 0x85, 0xbf, 0xdd, 0xf5, 0x93, 0xb6, 0xde,
  0x40, 0x8b, 0xc4, 0x9f, 0x00, 0x89, 0xc2, 0xe2, 0xbe, 0xed, 0x07, 0xd1,
  0x7c, 0x9c, 0x54, 0xce, 0x9f, 0xe5, 0x32, 0x05, 0x5e, 0x79, 0xb1, 0x97,
  0xf4, 0x15, 0x99, 0x6c, 0x82, 0x02, 0xae, 0x0a, 0xe4, 0x1e, 0xcb, 0xcf,
  0x73, 0xf2, 0x78, 0x3f, 0x42, 0xbb, 0x45, 0xe6, 0x27, 0xe3, 0x80, 0x3f,
  0x9d, 0x7e, 0xc1, 0xbd, 0x7a, 0xf7, 0x5a, 0xf3, 0xc8, 0x05, 0x9c, 0x44,
  0xf4, 0x1b, 0x61, 0x03, 0x1a, 0x10, 0x23, 0x6a, 0xaa, 0xc6, 0x01, 0x6e,
  0x78, 0x54, 0x40, 0x36, 0x2a, 0xc5, 0xa6, 0xe8, 0xcf, 0x49, 0x2f, 0x3f,
  0xf2, 0xd9, 0x3b, 0x85, 0x98, 0xd2, 0xc6, 0x93, 0x8f, 0x57, 0xa7, 0x5f,
  0x94, 0xdc, 0x57, 0xa4, 0x37, 0x76, 0xb1, 0xe2, 0x6b, 0xb7, 0xcb, 0xab,
  0x47, 0x65, 0x99, 0x17, 0xe6, 0x10, 0xdd, 0xd3, 0x13, 0x08, 0x98, 0xc2,
  0xbc, 0x74, 0x2e, 0x61, 0x34, 0xff, 0xce, 0x68, 0xe2, 0x5a, 0x0a, 0x2b,
  0x63, 0xc3, 0x1c, 0xd9, 0x6c, 0xd8, 0x49, 0x60, 0x89, 0xfe, 0xd4, 0xbc,
  0x1f, 0x48, 0xa1, 0x8d, 0x5a, 0x23, 0x68, 0xf4, 0xcf, 0xaa, 0xcd, 0xc2,
  0x30, 0x52, 0x67, 0x4c, 0x72, 0x62, 0xd5, 0xcf, 0xbc, 0x9c, 0xe3, 0x8e,
  0x45, 0xbd, 0xfd, 0x25, 0x72, 0xc4, 0x77, 0x7b, 0x9e, 0x40, 0x44, 0xeb,
  0x93, 0xc7, 0x1b, 0xea, 0x10
};
ubyte4 gIntermediateLen = 881;

ubyte gpChild[847] = {
  0x30, 0x82, 0x03, 0x4b, 0x30, 0x82, 0x02, 0x33, 0x02, 0x01, 0x03, 0x30,
  0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b,
  0x05, 0x00, 0x30, 0x6a, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04,
  0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x11, 0x30, 0x0f, 0x06, 0x03, 0x55,
  0x04, 0x08, 0x0c, 0x08, 0x4e, 0x65, 0x77, 0x20, 0x59, 0x6f, 0x72, 0x6b,
  0x31, 0x11, 0x30, 0x0f, 0x06, 0x03, 0x55, 0x04, 0x07, 0x0c, 0x08, 0x42,
  0x72, 0x6f, 0x6f, 0x6b, 0x6c, 0x79, 0x6e, 0x31, 0x0f, 0x30, 0x0d, 0x06,
  0x03, 0x55, 0x04, 0x0a, 0x0c, 0x06, 0x43, 0x41, 0x20, 0x4c, 0x74, 0x64,
  0x31, 0x24, 0x30, 0x22, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x1b, 0x77,
  0x65, 0x62, 0x61, 0x70, 0x70, 0x74, 0x61, 0x70, 0x2e, 0x73, 0x65, 0x63,
  0x75, 0x72, 0x69, 0x74, 0x79, 0x64, 0x65, 0x6d, 0x6f, 0x73, 0x2e, 0x6e,
  0x65, 0x74, 0x30, 0x1e, 0x17, 0x0d, 0x31, 0x39, 0x30, 0x33, 0x31, 0x39,
  0x32, 0x30, 0x31, 0x38, 0x33, 0x32, 0x5a, 0x17, 0x0d, 0x33, 0x32, 0x31,
  0x31, 0x32, 0x35, 0x32, 0x30, 0x31, 0x38, 0x33, 0x32, 0x5a, 0x30, 0x6d,
  0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x47,
  0x42, 0x31, 0x1b, 0x30, 0x19, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c, 0x12,
  0x47, 0x72, 0x65, 0x61, 0x74, 0x65, 0x72, 0x20, 0x4d, 0x61, 0x6e, 0x63,
  0x68, 0x65, 0x73, 0x74, 0x65, 0x72, 0x31, 0x10, 0x30, 0x0e, 0x06, 0x03,
  0x55, 0x04, 0x07, 0x0c, 0x07, 0x53, 0x61, 0x6c, 0x66, 0x6f, 0x72, 0x64,
  0x31, 0x11, 0x30, 0x0f, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x08, 0x4c,
  0x65, 0x61, 0x66, 0x20, 0x4c, 0x74, 0x64, 0x31, 0x1c, 0x30, 0x1a, 0x06,
  0x03, 0x55, 0x04, 0x03, 0x0c, 0x13, 0x77, 0x77, 0x77, 0x2e, 0x65, 0x78,
  0x61, 0x6d, 0x70, 0x6c, 0x65, 0x6c, 0x65, 0x61, 0x66, 0x2e, 0x63, 0x6f,
  0x6d, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48,
  0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f,
  0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0x99, 0xed,
  0xec, 0x4c, 0x3b, 0xc2, 0x34, 0x55, 0x0d, 0x7c, 0x54, 0x5c, 0x16, 0xeb,
  0xa6, 0x70, 0x16, 0x5c, 0x64, 0x04, 0x59, 0xdd, 0x3f, 0xc9, 0x15, 0x75,
  0x45, 0xc1, 0xf5, 0x77, 0x17, 0xe3, 0x45, 0xb4, 0x7a, 0xce, 0xba, 0x7c,
  0x1d, 0x64, 0x6f, 0x8c, 0x7e, 0x13, 0xf8, 0x41, 0x90, 0x9b, 0x21, 0xdf,
  0x01, 0x19, 0x6a, 0x2e, 0x3e, 0x96, 0x53, 0xe9, 0x34, 0x36, 0x61, 0x53,
  0x57, 0xab, 0x2e, 0xa0, 0x68, 0xa6, 0x5d, 0x74, 0xda, 0x9a, 0x20, 0x01,
  0x15, 0x89, 0x6f, 0xdf, 0x42, 0xce, 0xbb, 0x79, 0xfa, 0xbc, 0x96, 0x8c,
  0xbe, 0xab, 0xbc, 0x6d, 0xc2, 0x87, 0x20, 0xe8, 0x7c, 0x47, 0x17, 0x21,
  0xb6, 0x08, 0x32, 0x48, 0xc0, 0xe8, 0xb2, 0x71, 0x91, 0x98, 0x7f, 0xb0,
  0xba, 0x69, 0x57, 0x22, 0xc9, 0x6d, 0x0d, 0xf1, 0x84, 0xbd, 0x36, 0x5a,
  0xe4, 0xfb, 0x94, 0xc4, 0x17, 0x9f, 0x57, 0x7d, 0x5b, 0x75, 0x44, 0x1a,
  0xa2, 0x07, 0x12, 0x77, 0x61, 0xa4, 0xa3, 0x2d, 0xb2, 0x50, 0xe7, 0xd6,
  0x95, 0xd8, 0xe2, 0x2e, 0x9d, 0x99, 0x40, 0x66, 0xd9, 0xbd, 0x8c, 0x63,
  0x09, 0xa3, 0x64, 0x7e, 0x1d, 0x5d, 0x43, 0x47, 0xec, 0xc7, 0x6a, 0xcc,
  0xb5, 0xb5, 0xac, 0x14, 0x77, 0x38, 0x8a, 0x46, 0x5e, 0x48, 0x3c, 0x56,
  0x40, 0x18, 0x8d, 0x58, 0xd9, 0x53, 0xed, 0x13, 0xf5, 0xe6, 0x10, 0xf3,
  0x49, 0x53, 0x09, 0x82, 0x15, 0x42, 0x57, 0xdd, 0x65, 0x63, 0xa7, 0xa6,
  0xce, 0x61, 0xb7, 0x14, 0x66, 0x3a, 0x05, 0xca, 0x66, 0x78, 0x3e, 0xc4,
  0x80, 0x6a, 0xa3, 0x8c, 0x8e, 0x30, 0x3a, 0x8e, 0xd3, 0x95, 0x6a, 0x65,
  0xe4, 0xb2, 0x96, 0xbd, 0xfd, 0x00, 0x9c, 0x86, 0xf2, 0x7f, 0xc4, 0x90,
  0x8c, 0x2b, 0x13, 0x79, 0xb2, 0x45, 0xe2, 0xdd, 0xa8, 0x09, 0xfa, 0x19,
  0x43, 0xf1, 0x02, 0x03, 0x01, 0x00, 0x01, 0x30, 0x0d, 0x06, 0x09, 0x2a,
  0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x03, 0x82,
  0x01, 0x01, 0x00, 0x8a, 0xb5, 0x76, 0x63, 0x5a, 0x6d, 0x31, 0xb4, 0x12,
  0x8a, 0x40, 0x54, 0x4f, 0x6b, 0x31, 0xe4, 0x38, 0xef, 0x76, 0xdd, 0xb6,
  0x6c, 0xae, 0xd9, 0xf9, 0xae, 0x64, 0x51, 0x8f, 0xc9, 0xad, 0x51, 0x14,
  0x1a, 0xac, 0x9d, 0xfd, 0x42, 0x70, 0x19, 0x20, 0x9e, 0x53, 0x6d, 0x4c,
  0xd7, 0x7e, 0xfd, 0xe5, 0x83, 0x48, 0x72, 0x96, 0xae, 0x65, 0xd1, 0xc9,
  0x5e, 0xe0, 0x18, 0x9c, 0xeb, 0x9d, 0x02, 0xb7, 0x77, 0x0d, 0x9d, 0x27,
  0xdf, 0xc6, 0x85, 0x03, 0x36, 0xa5, 0x3e, 0xa2, 0x1c, 0xc9, 0xaa, 0x7d,
  0xa4, 0x1d, 0xee, 0xc6, 0x3f, 0x04, 0x40, 0xf9, 0x2c, 0x78, 0x95, 0xfd,
  0x2e, 0x37, 0xbf, 0xc4, 0xc1, 0x6a, 0x0c, 0x36, 0x40, 0x37, 0x8c, 0x17,
  0xdb, 0xb9, 0x9d, 0x5c, 0x05, 0x3b, 0x05, 0x51, 0x93, 0xae, 0x54, 0xc5,
  0x5b, 0x3a, 0x85, 0xe5, 0xbf, 0x9c, 0x36, 0x5e, 0x6e, 0xea, 0xa7, 0x77,
  0x42, 0xe6, 0xdc, 0x53, 0xc5, 0x46, 0x91, 0xbd, 0x01, 0xda, 0x8c, 0x79,
  0x71, 0x2b, 0x2b, 0x65, 0xc6, 0x67, 0x48, 0x1d, 0xa4, 0x8c, 0xe0, 0xc5,
  0x1e, 0x38, 0x9c, 0x52, 0x0f, 0xc5, 0x9f, 0x0f, 0x60, 0x32, 0xda, 0x3a,
  0x83, 0xbf, 0x94, 0x39, 0xc9, 0xbd, 0xc9, 0x8f, 0x0e, 0xec, 0x1c, 0xd6,
  0x4d, 0x16, 0x23, 0x73, 0x35, 0xef, 0x62, 0x98, 0x08, 0xc6, 0xdb, 0xf4,
  0x62, 0x43, 0xde, 0x43, 0xf9, 0x95, 0xce, 0x8b, 0xcd, 0x89, 0x7a, 0x93,
  0xd8, 0x06, 0xa3, 0x19, 0x2c, 0xe4, 0xad, 0x4d, 0xbc, 0xba, 0xd1, 0x6e,
  0x66, 0x05, 0x4a, 0xf6, 0xec, 0x15, 0x8e, 0x7e, 0x8c, 0xc9, 0x69, 0x49,
  0x76, 0xaa, 0x77, 0x2a, 0x79, 0x29, 0xe3, 0xd0, 0xdc, 0x8c, 0xf8, 0x0e,
  0x8a, 0xa6, 0xa1, 0x44, 0x29, 0xd3, 0x62, 0x81, 0xca, 0xd2, 0xfa, 0x3b,
  0x42, 0x07, 0xa8, 0x5f, 0x28, 0xb9, 0x60
};
ubyte4 gChildLen = 847;

/*----------------------------------------------------------------------------*/

static int BuildSSLCertChain(MOC_ASYM(hwAccelDescr hwAccelCtx)
                             int hint, CertChainTest* pTest,
                             certChainPtr* pRetCertChain)
{
    int retVal = 0;
    ubyte* msgBuffer = 0;
    ubyte* msg;
    ubyte4 msgBufferLen;
    certChainPtr certChain = 0;
    ubyte2 msgLen;
    ubyte4 numCertsInChain;
    int i;
    intBoolean isComplete;
    MSTATUS status;
    TimeDate td;
    const sbyte* names;
    int nameLen;
    ValidationConfig vc = { 0};
    char certFileName[] = "cert_x_from_cert_chain_x.der";
                        /* 0    56789|         |123        */


    UNITTEST_STATUS_GOTO(hint,
                         DIGICERT_readFile(pTest->fileName, &msgBuffer, &msgBufferLen),
                         retVal, exit);

    /* internal consistency test: the buffer should start at the 'certificate' byte (11) */
    UNITTEST_GOTO(UNITTEST_TRUE(hint, msgBufferLen > 4), retVal, exit);
    UNITTEST_GOTO(UNITTEST_INT(hint, *msgBuffer, 0x0B), retVal, exit);
    msg = msgBuffer+1;
    /* message len is in the next medium */
    msgLen = (ubyte2)((msg[1] << 8) | msg[2]);
    msg += 3;
    /* internal consistency test: msgLen is correct */
    UNITTEST_GOTO(UNITTEST_INT(hint, msgBufferLen-4, msgLen), retVal, exit);

    UNITTEST_STATUS_GOTO(hint, CERTCHAIN_createFromSSLRecord(MOC_RSA(hwAccelCtx)
                                                             &certChain,
                                                             msg,
                                                             msgLen),
                         retVal, exit);

    UNITTEST_STATUS_GOTO(hint, CERTCHAIN_numberOfCertificates(certChain,
                                                              &numCertsInChain),
                         retVal, exit);

    retVal += UNITTEST_INT(hint, numCertsInChain, pTest->numCerts);

    retVal += UNITTEST_STATUS(hint, CERTCHAIN_isComplete(certChain, &isComplete));
    retVal += UNITTEST_TRUE(hint, pTest->complete ? isComplete : !isComplete);

    certFileName[23] = (char) ((hint < 10) ? ('0' + hint) : (hint < 36) ? 'A' + hint - 10 : '+');
    /* write out the certs */
    for (i = 0; i < numCertsInChain; ++i)
    {
        const ubyte* certData;
        ubyte4 certLen;
        AsymmetricKey pubKey = {0};

        status = CERTCHAIN_getCertificate(certChain, i, &certData, &certLen);
        retVal += UNITTEST_STATUS((hint << 16 | i), status);
        if (OK <= status)
        {
            certFileName[5] = (char) ((i < 10) ? '0' + i: (i < 36) ? 'A' + i - 10 : '+');

            DIGICERT_writeFile(certFileName, certData, certLen);
        }
        status = CERTCHAIN_getKey(MOC_ASYM(hwAccelCtx) certChain, i, &pubKey);
        retVal += UNITTEST_STATUS((hint << 16 | i), status);

        CRYPTO_uninitAsymmetricKey(&pubKey, NULL);

    }


    /* validate the chain for time  -- some of these certificates 
     expire on 9/16/2015 00:00:00 GMT and all of them are expired on
     3/3/2017 */
    td.m_year = 45;
    td.m_month = 9;
    td.m_day = 15;
    td.m_hour = 12;
    td.m_minute = td.m_second = 0;

    vc.td = &td;

    /* positive tests for names */
    names = pTest->goodNames;
    nameLen = DIGI_STRLEN(names);
    i = 0;
    while (nameLen > 0)
    {
        vc.commonName = names;
        status = CERTCHAIN_validate(MOC_ASYM(hwAccelCtx) certChain, &vc);
        retVal += UNITTEST_TRUE((hint<<16|i), status >= OK);

        names += nameLen + 1;
        nameLen = DIGI_STRLEN(names);
        ++i;
    }

    /* negative test for time */
    td.m_year = 47;
    td.m_month = 3;
    td.m_day = 3;

    names = pTest->goodNames;
    nameLen = DIGI_STRLEN(names);
    i = 0;
    while (nameLen > 0)
    {
        vc.commonName = names;
        status = CERTCHAIN_validate(MOC_ASYM(hwAccelCtx) certChain, &vc);
        retVal += UNITTEST_TRUE((hint<<16|i), status == ERR_CERT_EXPIRED);

        names += nameLen + 1;
        nameLen = DIGI_STRLEN(names);
        ++i;
    }

    /* negative tests for names */
    vc.td = 0; /* no time test */
    names = pTest->badNames;
    nameLen = DIGI_STRLEN(names);
    i = 0;
    while (nameLen > 0)
    {
        vc.commonName = names;

        status = CERTCHAIN_validate(MOC_ASYM(hwAccelCtx) certChain, &vc);
        retVal += UNITTEST_TRUE((hint<<16|i), status < OK);

        names += nameLen + 1;
        nameLen = DIGI_STRLEN(names);
        ++i;
    }

    if (0 == retVal && pRetCertChain)
    {
        *pRetCertChain = certChain;
        certChain = 0;
    }

exit:

    CERTCHAIN_delete(&certChain);

    FREE( msgBuffer);

    return retVal;

}


/*---------------------------------------------------------------------------*/

static int build_test_certStore( int hint, certStorePtr* pNewCertStore,
                          const char* rootCertFileNames[],
                          int numRootCertFileNames)
{
    int i, retVal = 0;
    MSTATUS status;
    ubyte* certData;
    ubyte4 certLength;

    UNITTEST_STATUS_GOTO(hint, CERT_STORE_createStore(pNewCertStore), retVal, exit);

    for (i = 0; i < numRootCertFileNames; ++i)
    {

        status = DIGICERT_readFile(rootCertFileNames[i], &certData, &certLength);
        if (OK > status)
        {
            retVal += UNITTEST_STATUS((hint << 16 | i), status);
            continue;
        }

        retVal += UNITTEST_STATUS((hint << 16 | i),
                                  CERT_STORE_addTrustPoint(*pNewCertStore,
                                                           certData,
                                                           certLength));
        FREE(certData);
    }

exit:

    return retVal;
}


/*---------------------------------------------------------------------------*/

int cert_chain_test()
{
    int i, retVal = 0;
    MSTATUS status;
    certStorePtr pCertStore = 0;
    certStorePtr pOtherCertStore = 0;
    certStorePtr pFakeCertStore = 0;
    certStorePtr pEmptyCertStore = 0;

    ValidationConfig vc = { 0};

    const ubyte serverAuth_OID[] = { 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x01 };
    const ubyte clientAuth_OID[] = { 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x02 };

    const ubyte* extendedKeyUsages[3] = { serverAuth_OID, clientAuth_OID, (ubyte*) 0};
        

    certChainPtr pTestCertChains[COUNTOF(gTests1)] = {0};
    
    hwAccelDescr hwAccelCtx;
    if (OK > (MSTATUS)(retVal = HARDWARE_ACCEL_OPEN_CHANNEL(MOCANA_SSL, &hwAccelCtx)))
        return retVal;

    for (i = 0; i < kNumTests1; ++i)
    {
        retVal += BuildSSLCertChain(MOC_ASYM(hwAccelCtx) i, gTests1 + i, pTestCertChains+i);
    }

    /* build cert stores for testing */
    retVal += build_test_certStore(0, &pCertStore,
                                   gRootCerts, COUNTOF(gRootCerts));
    retVal += build_test_certStore(1, &pOtherCertStore,
                                   gOtherRootCerts, COUNTOF(gOtherRootCerts));

    retVal += build_test_certStore(2, &pFakeCertStore,
                                   gFakeRootCerts, COUNTOF(gFakeRootCerts));

    retVal += build_test_certStore(3, &pEmptyCertStore, NULL, 0);

    /* good: should succeed */
    vc.pCertStore = pCertStore;

    for ( i = 0; i < kNumTests1; ++i)
    {
        if (!pTestCertChains[i])
        {
            continue;
        }
        vc.anchorCert = 0;
        vc.anchorCertLen = 0;
        status = CERTCHAIN_validate(MOC_ASYM(hwAccelCtx) pTestCertChains[i], &vc);

        retVal += UNITTEST_STATUS(i, status);

        /* unless the cert chain is already complete, we should get a trusted
         point here */
        if ( !gTests1[i].complete)
        {
            retVal += UNITTEST_TRUE(i, vc.anchorCertLen > 0);
            retVal += UNITTEST_TRUE(i, vc.anchorCert != 0);
        }
        else
        {
            retVal += UNITTEST_TRUE(i, 0 == vc.anchorCertLen);
            retVal += UNITTEST_TRUE(i, 0 == vc.anchorCert);
        }
    }

    /* not the right root certs */
    vc.pCertStore = pOtherCertStore;

    for ( i = 0; i < kNumTests1; ++i)
    {
        if (!pTestCertChains[i])
        {
            continue;
        }
        vc.anchorCert = 0;
        vc.anchorCertLen = 0;
        status = CERTCHAIN_validate(MOC_ASYM(hwAccelCtx) pTestCertChains[i], &vc);

        retVal += UNITTEST_INT(i, status, ERR_CERT_CHAIN_NO_TRUST_ANCHOR);
    }


    /* fake root certs */
    vc.pCertStore = pFakeCertStore;

    for ( i = 0; i < kNumTests1; ++i)
    {
        if (!pTestCertChains[i])
        {
            continue;
        }
        vc.anchorCert = 0;
        vc.anchorCertLen = 0;
        status = CERTCHAIN_validate(MOC_ASYM(hwAccelCtx) pTestCertChains[i], &vc);

        retVal += UNITTEST_INT(i, status, ERR_CERT_CHAIN_NO_TRUST_ANCHOR);
    }

    /* no root certs */
    vc.pCertStore = pEmptyCertStore;

    for ( i = 0; i < kNumTests1; ++i)
    {
        if (!pTestCertChains[i])
        {
            continue;
        }
        vc.anchorCert = 0;
        vc.anchorCertLen = 0;
        status = CERTCHAIN_validate(MOC_ASYM(hwAccelCtx) pTestCertChains[i], &vc);

        retVal += UNITTEST_INT(i, status, ERR_CERT_CHAIN_NO_TRUST_ANCHOR);
    }


    /* key usage tests */
    /* reset config */
    DIGI_MEMSET((ubyte*) &vc, 0, sizeof(vc));

    for ( i = 0; i < kNumTests1; ++i)
    {
        if (!pTestCertChains[i])
        {
            continue;
        }
        vc.keyUsage = gTests1[i].keyUsage;

        status = CERTCHAIN_validate(MOC_ASYM(hwAccelCtx) pTestCertChains[i], &vc);

        retVal += UNITTEST_STATUS(i, status);

        vc.keyUsage |= (1 << 9);

        status = CERTCHAIN_validate(MOC_ASYM(hwAccelCtx) pTestCertChains[i], &vc);

        retVal += UNITTEST_TRUE(i, status == ERR_CERT_INVALID_KEYUSAGE);

    }


    /* extended key usage tests */
    /* reset config */
    /* positive tests */
    DIGI_MEMSET((ubyte*) &vc, 0, sizeof(vc));
    vc.extendedKeyUsage = extendedKeyUsages;

    for ( i = 0; i < kNumTests1; ++i)
    {
        if (!pTestCertChains[i])
        {
            continue;
        }

        status = CERTCHAIN_validate(MOC_ASYM(hwAccelCtx) pTestCertChains[i], &vc);

        retVal += UNITTEST_STATUS(i, status);
    }

    /* negative tests: add one that is not there */
    extendedKeyUsages[1] = serialNumber_OID; /* crazy value */

    for ( i = 0; i < kNumTests1; ++i)
    {
        if (!pTestCertChains[i])
        {
            continue;
        }

        status = CERTCHAIN_validate(MOC_ASYM(hwAccelCtx) pTestCertChains[i], &vc);

        retVal += UNITTEST_TRUE(i, status == ERR_CERT_INVALID_EXTENDED_KEYUSAGE);
    }


    for (i = 0; i < kNumTests1; ++i)
    {
        CERTCHAIN_delete(pTestCertChains+i);
    }

    CERT_STORE_releaseStore(&pCertStore);
    CERT_STORE_releaseStore(&pOtherCertStore);
    CERT_STORE_releaseStore(&pFakeCertStore);
    CERT_STORE_releaseStore(&pEmptyCertStore);
    
    HARDWARE_ACCEL_CLOSE_CHANNEL(MOCANA_SSL, &hwAccelCtx);

    return retVal;
}

/*---------------------------------------------------------------------------*/

int validateSelfSigned()
{
    MSTATUS status, fstatus;
    ValidationConfig config = { 0 };
    certStorePtr pCertStore = NULL;
    certChainPtr pValidatedChain = NULL;
    ubyte *pCertificates = NULL;
    ubyte4 totalCertLen;

    status = CERT_STORE_createStore(&pCertStore);
    if (OK != status)
        goto exit;
    
    config.pCertStore = pCertStore;

    totalCertLen = gRootLen;
    status = DIGI_MALLOC((void **) &pCertificates, totalCertLen);
    if (OK != status)
        goto exit;
    
    status = DIGI_MEMCPY(pCertificates, gpRoot, gRootLen);
    if (OK != status)
        goto exit;

    status = CERTCHAIN_validateAll(MOC_ASYM(hwAccelCtx) 
        pCertificates, totalCertLen, &config, &pValidatedChain);

exit:

    if (NULL != pValidatedChain)
    {
        fstatus = CERTCHAIN_delete(&pValidatedChain);
        if (OK == status)
            status = fstatus;
    }

    if (NULL != pCertStore)
    {
        fstatus = CERT_STORE_releaseStore(&pCertStore);
        if (OK == status)
            status = fstatus;
    }

    if (NULL != pCertificates)
    {
        fstatus = DIGI_FREE((void **) &pCertificates);
        if (OK == status)
            status = fstatus;
    }

    return status ? 1 : 0;
}

int validateFullChainTest(
    ubyte *pCert1,
    ubyte4 cert1Len,
    ubyte *pCert2,
    ubyte4 cert2Len,
    ubyte *pCert3,
    ubyte4 cert3Len
    )
{
    MSTATUS status, fstatus;
    ValidationConfig config = { 0 };
    certStorePtr pCertStore = NULL;
    certChainPtr pValidatedChain = NULL;
    ubyte *pCertificates = NULL, *pTemp;
    ubyte4 totalCertLen;

    status = CERT_STORE_createStore(&pCertStore);
    if (OK != status)
        goto exit;
    
    config.pCertStore = pCertStore;

    totalCertLen = cert1Len + cert2Len + cert3Len;
    status = DIGI_MALLOC((void **) &pCertificates, totalCertLen);
    if (OK != status)
        goto exit;
    
    pTemp = pCertificates;
    
    status = DIGI_MEMCPY(pTemp, pCert1, cert1Len);
    if (OK != status)
        goto exit;
    
    pTemp += cert1Len;

    status = DIGI_MEMCPY(pTemp, pCert2, cert2Len);
    if (OK != status)
        goto exit;
    
    pTemp += cert2Len;

    status = DIGI_MEMCPY(pTemp, pCert3, cert3Len);
    if (OK != status)
        goto exit;

    status = CERTCHAIN_validateAll(MOC_ASYM(hwAccelCtx) 
        pCertificates, totalCertLen, &config, &pValidatedChain);

exit:

    if (NULL != pValidatedChain)
    {
        fstatus = CERTCHAIN_delete(&pValidatedChain);
        if (OK == status)
            status = fstatus;
    }

    if (NULL != pCertStore)
    {
        fstatus = CERT_STORE_releaseStore(&pCertStore);
        if (OK == status)
            status = fstatus;
    }

    if (NULL != pCertificates)
    {
        fstatus = DIGI_FREE((void **) &pCertificates);
        if (OK == status)
            status = fstatus;
    }

    return status ? 1 : 0;
}

int validateFullChain()
{
    int errorCount = 0;

    errorCount += validateFullChainTest(
        gpRoot, gRootLen, gpIntermediate, gIntermediateLen, gpChild, gChildLen);
    errorCount += validateFullChainTest(
        gpChild, gChildLen, gpIntermediate, gIntermediateLen, gpRoot, gRootLen);
    errorCount += validateFullChainTest(
        gpRoot, gRootLen, gpChild, gChildLen, gpIntermediate, gIntermediateLen);

    return errorCount;
}

int validateAgainstTrustStore()
{
    MSTATUS status, fstatus;
    ValidationConfig config = { 0 };
    certStorePtr pCertStore = NULL;
    certChainPtr pValidatedChain = NULL;
    ubyte *pCertificates = NULL;
    ubyte4 totalCertLen;

    status = CERT_STORE_createStore(&pCertStore);
    if (OK != status)
        goto exit;
    
    status = CERT_STORE_addTrustPoint(pCertStore, gpRoot, gRootLen);
    if (OK != status)
        goto exit;
    
    config.pCertStore = pCertStore;

    totalCertLen = gIntermediateLen;
    status = DIGI_MALLOC((void **) &pCertificates, totalCertLen);
    if (OK != status)
        goto exit;
    
    status = DIGI_MEMCPY(pCertificates, gpIntermediate, gIntermediateLen);
    if (OK != status)
        goto exit;

    status = CERTCHAIN_validateAll(MOC_ASYM(hwAccelCtx) 
        pCertificates, totalCertLen, &config, &pValidatedChain);

exit:

    if (NULL != pValidatedChain)
    {
        fstatus = CERTCHAIN_delete(&pValidatedChain);
        if (OK == status)
            status = fstatus;
    }

    if (NULL != pCertStore)
    {
        fstatus = CERT_STORE_releaseStore(&pCertStore);
        if (OK == status)
            status = fstatus;
    }

    if (NULL != pCertificates)
    {
        fstatus = DIGI_FREE((void **) &pCertificates);
        if (OK == status)
            status = fstatus;
    }

    return status ? 1 : 0;
}

int validateSingleCertNoTrustAnchor()
{
    MSTATUS status, fstatus;
    ValidationConfig config = { 0 };
    certStorePtr pCertStore = NULL;
    certChainPtr pValidatedChain = NULL;
    ubyte *pCertificates = NULL;
    ubyte4 totalCertLen;

    status = CERT_STORE_createStore(&pCertStore);
    if (OK != status)
        goto exit;
    
    config.pCertStore = pCertStore;

    totalCertLen = gIntermediateLen;
    status = DIGI_MALLOC((void **) &pCertificates, totalCertLen);
    if (OK != status)
        goto exit;
    
    status = DIGI_MEMCPY(pCertificates, gpIntermediate, gIntermediateLen);
    if (OK != status)
        goto exit;


    status = CERTCHAIN_validateAll(MOC_ASYM(hwAccelCtx) 
        pCertificates, totalCertLen, &config, &pValidatedChain);
    if (OK != status)
        status = OK;
    else
        status = ERR_CERT_STORE;

exit:

    if (NULL != pCertStore)
    {
        fstatus = CERT_STORE_releaseStore(&pCertStore);
        if (OK == status)
            status = fstatus;
    }

    if (NULL != pCertificates)
    {
        fstatus = DIGI_FREE((void **) &pCertificates);
        if (OK == status)
            status = fstatus;
    }

    return status ? 1 : 0;
}

int validateCertChainNoTrustAnchor()
{
    MSTATUS status, fstatus;
    ValidationConfig config = { 0 };
    certStorePtr pCertStore = NULL;
    certChainPtr pValidatedChain = NULL;
    ubyte *pCertificates = NULL;
    ubyte4 totalCertLen;

    status = CERT_STORE_createStore(&pCertStore);
    if (OK != status)
        goto exit;
    
    config.pCertStore = pCertStore;

    totalCertLen = gIntermediateLen + gChildLen;
    status = DIGI_MALLOC((void **) &pCertificates, totalCertLen);
    if (OK != status)
        goto exit;
    
    status = DIGI_MEMCPY(pCertificates, gpIntermediate, gIntermediateLen);
    if (OK != status)
        goto exit;

    status = DIGI_MEMCPY(pCertificates + gIntermediateLen, gpChild, gChildLen);
    if (OK != status)
        goto exit;

    status = CERTCHAIN_validateAll(MOC_ASYM(hwAccelCtx) 
        pCertificates, totalCertLen, &config, &pValidatedChain);
    if (OK != status)
        status = OK;
    else
        status = ERR_CERT_STORE;

exit:

    if (NULL != pCertStore)
    {
        fstatus = CERT_STORE_releaseStore(&pCertStore);
        if (OK == status)
            status = fstatus;
    }

    if (NULL != pCertificates)
    {
        fstatus = DIGI_FREE((void **) &pCertificates);
        if (OK == status)
            status = fstatus;
    }

    return status ? 1 : 0;
}

int validateInverseChildParentLink()
{
    MSTATUS status, fstatus;
    ValidationConfig config = { 0 };
    certStorePtr pCertStore = NULL;
    certChainPtr pValidatedChain = NULL;
    ubyte *pCertificates = NULL;
    ubyte4 totalCertLen;

    status = CERT_STORE_createStore(&pCertStore);
    if (OK != status)
        goto exit;
    
    status = CERT_STORE_addTrustPoint(pCertStore, gpChild, gChildLen);
    if (OK != status)
        goto exit;
    
    config.pCertStore = pCertStore;

    totalCertLen = gIntermediateLen;
    status = DIGI_MALLOC((void **) &pCertificates, totalCertLen);
    if (OK != status)
        goto exit;
    
    status = DIGI_MEMCPY(pCertificates, gpIntermediate, gIntermediateLen);
    if (OK != status)
        goto exit;

    status = CERTCHAIN_validateAll(MOC_ASYM(hwAccelCtx) 
        pCertificates, totalCertLen, &config, &pValidatedChain);
    if (OK != status)
        status = OK;
    else
        status = ERR_CERT_STORE;

exit:

    if (NULL != pCertStore)
    {
        fstatus = CERT_STORE_releaseStore(&pCertStore);
        if (OK == status)
            status = fstatus;
    }

    if (NULL != pCertificates)
    {
        fstatus = DIGI_FREE((void **) &pCertificates);
        if (OK == status)
            status = fstatus;
    }

    return status ? 1 : 0;
}

int validateMissingIntermediateLink()
{
    MSTATUS status, fstatus;
    ValidationConfig config = { 0 };
    certStorePtr pCertStore = NULL;
    certChainPtr pValidatedChain = NULL;
    ubyte *pCertificates = NULL;
    ubyte4 totalCertLen;

    status = CERT_STORE_createStore(&pCertStore);
    if (OK != status)
        goto exit;
    
    config.pCertStore = pCertStore;

    totalCertLen = gIntermediateLen + gChildLen;
    status = DIGI_MALLOC((void **) &pCertificates, totalCertLen);
    if (OK != status)
        goto exit;
    
    status = DIGI_MEMCPY(pCertificates, gpIntermediate, gIntermediateLen);
    if (OK != status)
        goto exit;
    
    status = DIGI_MEMCPY(
        pCertificates + gIntermediateLen, gpChild, gChildLen);
    if (OK != status)
        goto exit;

    status = CERTCHAIN_validateAll(MOC_ASYM(hwAccelCtx) 
        pCertificates, totalCertLen, &config, &pValidatedChain);
    if (OK != status)
        status = OK;
    else
        status = ERR_CERT_STORE;

exit:

    if (NULL != pCertStore)
    {
        fstatus = CERT_STORE_releaseStore(&pCertStore);
        if (OK == status)
            status = fstatus;
    }

    if (NULL != pCertificates)
    {
        fstatus = DIGI_FREE((void **) &pCertificates);
        if (OK == status)
            status = fstatus;
    }

    return status ? 1 : 0;
}


int cert_chain_test_validate_all()
{
    int errorCount = 0;

    /* Positive tests
     */
    errorCount += validateSelfSigned();
    errorCount += validateFullChain();
    errorCount += validateAgainstTrustStore();

    /* Negative tests
     */
    errorCount += validateSingleCertNoTrustAnchor();
    errorCount += validateCertChainNoTrustAnchor();
    errorCount += validateInverseChildParentLink();
    errorCount += validateMissingIntermediateLink();

    return errorCount;
}

/*---------------------------------------------------------------------------*/
